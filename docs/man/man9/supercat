.TH AT_PID "9" "2007-05-12" "Documentacion de LinuxCNC" "Componentes HAL"
.de TQ
.br
.ns
.TP \\$1
..

.SH NOMBRE
at_pid \- controlador proporcional/integral/derivativo con ajuste automatico
.SH SINOPSIS
\fBloadrt at_pid [num_chan=\fInum\fB | nombres=\fIname1\fB[,\fIname2 ...\fB]]



.SH DESCRIPCION
\fBat_pid\fR es un controlador proporcional/integral/derivativo clasico.
Se utiliza para controlar los bucles de realimentacion de posicion o velocidad para servomotores y
otras aplicaciones de lazo cerrado.
.P
\fBat_pid\fR admite un maximo de dieciseis controladores. El numero que
en realidad se cargan se establece mediante el argumento \fBnum_chan\fR cuando
se carga el modulo. Alternativamente, especifique \fBnombres=\fR y nombres unicos
separados por comas.
.P
Los especificadores \fBnum_chan=\fR y \fBnombres=\fR se excluyen mutuamente.
Si no se especifica \fBnum_chan=\fR ni \fBnombres=\fR, el valor predeterminado es tres.
.P
Si \fBdebug\fR se establece en 1 (el valor predeterminado es 0), 
se exportaran algunos parametros HAL adicionales, lo que podria ser util
para la puesta a punto, pero por lo demas son innecesarios.
.P
\fBat_pid\fR tiene incorporado un modo de sintonizacion automatica. Funciona estableciendo un
ciclo limite para caracterizar el proceso. A partir de esto, \fBPgain/Igain/Dgain\fR o
\fBPgain/Igain/FF1\fR se pueden determinar usando Ziegler-Nichols. Cuando se usa
\fBFF1\fR, la escala debe establecerse de modo que \fBoutput\fR este en unidades de usuario por segundo.
.P
Durante el ajuste automatico, la entrada \fBcommand\fR no debe cambiar.
El ciclo limite se configura alrededor de la posicion ordenada. No hay valores iniciales de ajuste
requeridos para iniciar la sintonizacion automatica. Solo \fBtune\-cycles\fR, \fBtune\-effort\fR
y \fBtune\-mode\fR debe configurarse antes de iniciar la sintonizacion automatica. Cuando la sintonizacion automatica
se completa, se estableceran los parametros de ajuste. Si se ejecuta desde LinuxCNC, el
ajuste de FERROR para el eje que se esta afinando puede necesitar ser mas permisivo, ya que debe
ser mas grande que el limite de amplitud del ciclo para evitar un error de seguimiento.
.P
Para realizar la sintonizacion automatica, siga los siguientes pasos:
.P 
\- Mueva el eje a afinar a un lugar cercano al centro de su carrera.
.P
\- Establecer \fBtune\-cycles\fR (el valor predeterminado deberia estar bien en la mayoria de los casos) y \fBtune\-mode\fR.
.P
\- Establezca \fBtune\-effort\fR a un valor peque\[~n]o.
.P
\- Establezca \fBenable\fR en VERDADERO.
.P
\- Establezca \fBtune\-mode\fR en VERDADERO. 
.P
\- Establezca \fBtune\-start\fR en VERDADERO.
.P
\- Si no hay oscilacion, o si la oscilacion es muy peque\[~n]a, aumente lentamente \fBtune\-effort\fR.
.P
\- La sintonizacion automatica puede abortarse en cualquier momento configurando \fBenable\fR o \fBtune\-mode\fR a FALSO.

.SH DANDO NOMBRES
Los nombres de los pines, parametros y funciones tienen como prefijo:
  \fBpid.N.\fR para N=0,1, ..., num\-1 cuando se usa \fBnum_chan=num\fR
  \fBnombreN.\fR para nombreN=nombre1, nombre2, ... cuando se usa \fBnombres=nombre1, nombre2, ...\fR

El formato de \fBpid.N.\fR se muestra en las siguientes descripciones.


.SH FUNCIONES
.TP
\fBpid.\fIN\fB.do\-pid\-calcs\fR (usa punto flotante)
Hace los calculos PID para el bucle de control \fIN\fR.

.SH PINES

.TP
\fBpid.\fIN\fB.command\fR float in
El valor deseado (ordenado) para el bucle de control.
.TP
\fBpid.\fIN\fB.feedback\fR float in
El valor real (realimentacion), de algun sensor como un encoder.
.TP
\fBpid.\fIN\fB.error\fR float in
La diferencia entre el comando y la retroalimentacion.
.TP
\fBpid.\fIN\fB.output\fR float out
La salida del bucle PID, que va a algun actuador como un motor.
.TP
\fBpid.\fIN\fB.enable\fR bit in
Cuando es VERDADERO, habilita los calculos PID. Cuando es FALSO, \fBoutput\fR es cero,
y todos los integradores internos, etc, se reinician.
.TP
\fBpid.\fIN\fB.tune\-mode\fR bit in
Cuando es VERDADERO, habilita el modo de sintonizacion automatica. Cuando es FALSO, se realizan los calculos PID normales.
.TP
\fBpid.\fIN\fB.tune\-start\fR bit io
Cuando se establece en VERDADERO, comienza la sintonizacion automatica. Se borra cuando se completa la sintonizacion automatica.

.SH PARAMETROS
.TP
\fBpid.\fIN\fB.Pgain\fR float rw
Ganancia proporcional. Es la contribucion a la salida, que es el error
multiplicado por \fBPgain\fR.
.TP
\fBpid.\fIN\fB.Igain\fR float rw
Ganancia integral. Es la contribucion a la salida que es la integral
del error multiplicado por \fBIgain\fR. Por ejemplo un error de 0.02 con
una duracion de 10 segundos, daria como resultado un error integrado (\fBerrorI\fR) de 0.2,
y si \fBIgain\fR es 20, el termino integral agregaria 4.0 a la salida.
.TP
\fBpid.\fIN\fB.Dgain\fR float rw
Ganancia derivada. Es la contribucion a la salida que es la tasa de
cambio (derivada) del error multiplicado por \fBDgain\fR. Por ejemplo un
error que cambio de 0,02 a 0,03 en 0,2 segundos resultaria en un error
derivado (\fBerrorD\fR) de ((0,03-0,02)/0,2) = 0,05, y si \fBDgain\fR es 5, 
el termino derivado agregaria 0,25 a la salida.
.TP
\fBpid.\fIN\fB.bias\fR float rw
\fBbias\fR es una cantidad constante que se agrega a la salida. En la mayoria de los casos
se debe dejar a cero. Sin embargo, a veces puede ser util
para compensar offsets en servoamplificadores, o para equilibrar el peso de un objeto que
se mueve verticalmente. \fBbias\fR se desactiva cuando el bucle PID esta deshabilitado,
al igual que todos los demas componentes de la salida. Si se necesita una salida que no sea cero
incluso cuando el bucle PID esta deshabilitado, debe agregarse con una HAL externa sum2.
.TP
\fBpid.\fIN\fB.FF0\fR float rw
Termino de avance de orden cero. Produce una contribucion a la salida que es
\fBFF0\fR multiplicado por el valor ordenado. Para los bucles de posicion,
generalmente se deja en cero. Para los bucles de velocidad, \fBFF0\fR puede compensar
friccion o fuerza contraelectromotriz (FCEM) del motor y puede permitir una mejor sintonizacion si se usa correctamente.
.TP
\fBpid.\fIN\fB.FF1\fR float rw
Termino de avance de primer orden. Produce una contribucion a la salida que es
\fBFF1\fR multiplicado por la derivada del valor ordenado. Para
lazos de posicion, la contribucion es proporcional a la velocidad, y se puede utilizar
Para compensar la friccion o la FCEM del motor. Para los bucles de velocidad, es
proporcional a la aceleracion y puede compensar la inercia. En ambos
casos, puede resultar en un mejor ajuste si se usa correctamente.
.TP
\fBpid.\fIN\fB.FF2\fR float rw
Termino de avance de segundo orden. Produce una contribucion a la salida que es
\fBFF2\fR multiplicado por la segunda derivada del valor ordenado. Para
lazos de posicion, la contribucion es proporcional a la aceleracion, y puede ser
utilizada para compensar la inercia. Para los bucles de velocidad, normalmente deberia ser
proxima a cero.
.TP
\fBpid.\fIN\fB.deadband\fR float rw
Define un rango de error "aceptable". Si el valor absoluto de \fBerror\fR
es menor que \fBdeadband\fR, se tratara como si el error fuera cero.
Cuando se utilizan dispositivos de retroalimentacion tales como encoders, que inherentemente estan "cuantificados" (sin valores intermedios entre dos cuentas), la banda muerta debe configurarse un poco mas de la mitad de una cuenta, para evitar
que el bucle de control entre en una busqueda de ida y vuelta si el comando esta entre dos
valores del codificador. Cuando el valor absoluto del error es mayor
que la banda muerta, el valor de la banda muerta se resta del error anterior
antes de realizar los calculos de bucle, para evitar un paso en la funcion de transferencia
en el borde de la banda muerta. (Vea \fBBUGS\fR.)
.TP
\fBpid.\fIN\fB.maxoutput\fR float rw
Limite de salida. No se permitira superar, en valor absoluto de la salida, \fBmaxoutput\fR, a menos que \fBmaxoutput\fR sea cero.
Cuando la salida esta limitada, el integrador de errores mantendra en lugar de integrar, para evitar los efecto de 
windup y overshoot.

(N.T. Los actuadores (motores) tienen unos limites (fisicos o impuestos), llegados a los cuales se dice que se entra en "saturacion".
Si una variable de control llega a ese limite, el bucle permanece alli, sin importar el valor de la salida. Para el termino integral, esto significa que el error se volvera a integrar y su valor sera cada vez mas grande. Este efecto indeseable es llamado "windup".
Como efecto colateral, se produce una respuesta excesiva, sobredisparo u "overshoot")

.TP
\fBpid.\fIN\fB.maxerror\fR float rw
Limite de la variable de error interno utilizada para P, I y D. Se puede usar para
evitar que valores altos de \fBPgain\fR generen valores excesivos
cuando el error es grande (por ejemplo, cuando el comando realiza un cambio de paso).
Normalmente no es necesario, pero puede ser util para ajustar sistemas no lineales.
.TP
\fBpid.\fIN\fB.maxerrorD\fR float rw
Limite del error derivado. La tasa de cambio de error utilizada por el
termino \fBDgain\fR se limitara a este valor, a menos que el valor sea
cero. Puede usarse para limitar el efecto de \fBDgain\fR y evitar grandes
picos de salida debido a pasos en el comando y/o retroalimentacion. No es normalmente
necesario.
.TP
\fBpid.\fIN\fB.maxerrorI\ fR float rw
Limite en el integrador de errores. El integrador de errores utilizado por el termino \fBIgain\fR
se limitara a este valor, a menos que sea cero. Puede ser utilizado para prevenir
el windup del integrador y el rebasamiento resultante durante/despues de errores sostenidos.
Normalmente no es necesario.
.TP
\fBpid.\fIN\fB.maxcmdD\fR float rw
Limite en el comando derivado. El comando derivado utilizado por \fBFF1\fR sera
limitado a este valor, a menos que el valor sea cero. Puede ser utilizado para prevenir
que \fBFF1\fR produzca picos de salida grandes si hay un cambio de paso en el
comando. Normalmente no es necesario.
.TP
\fBpid.\fIN\fB.maxcmdDD\fR float rw
Limite de la segunda derivada del comando. La segunda derivada del comando, utilizada por
\fBFF2\fR estara limitada a este valor, a menos que el valor sea cero. Puede ser
utilizado para evitar que \fBFF2\fR produzca picos de salida grandes si hay un
cambio de paso en el comando. Normalmente no es necesario.
.TP
\fBpid.\fIN\fB.tune\-type\fR u32 rw
Cuando se establece a 0, se calculan \fBPgain / Igain / Dgain\fR. Cuando se establece en 1, se calculan
\fBPgain / Igain / FF1 \fR .
.TP
\fBpid.\fIN\fB.tune\-cycles\fR u32 rw
Determina el numero de ciclos a ejecutar para caracterizar el proceso.
\fBtune\-cycles\fR en realidad establece el numero de semiciclos. Mas ciclos resulta
en una caracterizacion mas precisa, ya que se utiliza el promedio de todos los ciclos.
.TP
\fBpid.\fIN\fB.tune\-effort\fR float rw
Determina el esfuerzo utilizado en la configuracion del ciclo limite en el proceso.
\fBtune\-effort\fR se debe establecer en un valor positivo menor que \fBmaxoutput\fR.
Comience con algo peque\[~n]o hasta llegar a un valor que resulte en una buena
parte de la corriente maxima del motor que se esta utilizando. Cuanto menor sea el valor,
menor es la amplitud del ciclo limite.
.TP
\fBpid.\fIN\fB.errorI\fR float ro (solo si debug = 1)
Integral de error. Este es el valor que se multiplica por \fBIgain\fR para producir el termino integral de la salida.
.TP
\fBpid.\fIN\fB.errorD\fR float ro (solo si debug = 1)
Derivada del error. Este es el valor que se multiplica por \fBDgain\fR para producir el termino derivado de la salida.
.TP
\fBpid.\fIN\fB.commandD\fR float ro (solo si debug = 1)
Derivada del comando. Este es el valor que se multiplica por \fBFF1\fR para producir el termino de avance de primer orden de la salida.
.TP
\fBpid.\fIN\fB.commandDD\fR float ro (solo si debug = 1)
Segunda derivada del comando. Este es el valor que se multiplica por
\fBFF2\fR para producir el segundo termino de alimentacion de la salida.
.TP
\fBpid.\fIN\fB.ultimate\-gain\fR float ro (solo si debug = 1)
Determinado a partir de la caracterizacion del proceso. \fBultimate\-gain\fR es la relacion de
\fBtune\-effort\fR a la amplitud del ciclo limite multiplicada por 4.0 dividida por Pi.
\fBpid.\fIN\fB.ultimate\-period\fR float ro (solo si debug = 1)
Determinado a partir de la caracterizacion del proceso. \fBultimate\-period\fR es el periodo
del ciclo limite.

.SH ERRORES
Algunas personas argumentarian que la banda muerta deberia implementarse de tal manera que el error sea
tratado como cero si esta dentro de la banda muerta, y no se modifica si esta fuera de
la banda muerta. Esto no se hizo porque causaria un paso en la funcion de transferencia
igual al tama\[~n]o de la banda muerta. Las personas que prefieren ese comportamiento estan
invitadas a agregar un parametro que cambiara el comportamiento, o a escribir su propia
version de \fBat_pid\fR. Sin embargo, el comportamiento predeterminado no debe ser cambiado.
.so man9/motion.9
.\"
.TH CLASSICLADDER "9" "2008-11-23" "LinuxCNC Documentation" "HAL Component" 
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
classicladder \- realtime software plc based on ladder logic
.SH SYNOPSIS
\fBloadrt classicladder_rt  [numRungs=\fIN\fB] [numBits=\fIN\fB] [numWords=\fIN\fB] [numTimers=\fIN\fB] [numMonostables=\fIN\fB] [numCounters=\fIN\fB] [numPhysInputs=\fIN\fB] [numPhysOutputs=\fIN\fB] [numArithmExpr=\fIN\fB] [numSections=\fIN\fB] [numSymbols=\fIN\fB] [numS32in=\fIN\fB] [numS32out=\fIN\fB] [numFloatIn=\fIN\fB] [numFloatOut=\fIN\fB]

.SH DESCRIPTION
These pins and parameters are created by the realtime \fBclassicladder_rt\fR module. Each period (minimum 1000000 ns), classicladder reads the inputs, evaluates the ladder logic defined in the GUI, and then writes the outputs.

.SH PINS

.TP
\fBclassicladder.0.in\-\fINN\fB\fR IN bit
These bit signal pins map to \fB%I\fINN\fR variables in classicladder

.TP
\fBclassicladder.0.out\-\fINN\fB\fR OUT bit
These bit signal pins map to \fB%Q\fINN\fR variables in classicladder
Output from classicladder

.TP
\fBclassicladder.0.s32in\-\fINN\fB\fR IN s32
Integer input from classicladder
These s32 signal pins map to \fB%IW\fINN\fR variables in classicladder

.TP
\fBclassicladder.0.s32out\-\fINN\fB\fR OUT s32
Integer output from classicladder
These s32 signal pins map to \fB%QW\fINN\fR variables in classicladder

.TP
\fBclassicladder.0.floatin\-\fINN\fB\fR IN float
Integer input from classicladder
These float signal pins map to \fB%IF\fINN\fR variables in classicladder
These are truncated to S32 values internally. eg 7.5 will be 7

.TP
\fBclassicladder.0.floatout\-\fINN\fB\fR OUT float
Float output from classicladder
These float signal pins map to \fB%QF\fINN\fR variables in classicladder

.TP
\fBclassicladder.0.hide_gui IN bit
This bit pin hides the classicladder window, while still having the userspace code
run. This is usually desirable when modbus is used, as modbus requires the userspace
code to run.

.SH PARAMETERS

.TP
\fBclassicladder.0.refresh.time\fR RO s32
Tells you how long the last refresh took

.TP
\fBclassicladder.0.refresh.tmax\fR RW s32
Tells you how long the longest refresh took

.TP
\fBclassicladder.0.ladder\-state\fR RO s32
Tells you if the program is running or not
.SH FUNCTIONS

.TP
\fBclassicladder.0.refresh\fR FP 
The rung update rate. Add this to the servo thread.
You can added it to a faster thread but it
Will update no faster than once every 1 millisecond (1000000 ns).

.SH BUGS
See http://wiki.linuxcnc.org/cgi\-bin/wiki.pl?ClassicLadder_Ver_7.124 for the latest.

.SH SEE ALSO
\fIClassicladder\fR chapters in the LinuxCNC documentation for a full description of the \fBClassicladder\fR syntax and examples

http://wiki.linuxcnc.org/cgi\-bin/wiki.pl?ClassicLadder_Ver_7.124
.TH COUNTER "9" "2007-01-19" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

counter \- counts input pulses \fB(DEPRECATED)\fB

.SH SYNOPSIS
.B loadrt counter [num_chan=\fIN\fB]
.SH DESCRIPTION
\fBcounter\fR is a deprecated HAL component and will be removed in a future
release.  Use the \fBencoder\fR component with encoder.X.counter\-mode set to
TRUE.

\fBcounter\fR is a HAL component that provides software-
based counting that is useful for spindle position sensing and
maybe other things.  Instead of using a real encoder that outputs
quadrature, some lathes have a sensor that generates a simple pulse
stream as the spindle turns and an index pulse once per revolution.
This component simply counts up when a "count" pulse (phase\-A)
is received, and if reset is enabled, resets when the "index"
(phase\-Z) pulse is received.

This is of course only useful for a unidirectional spindle, as it
is not possible to sense the direction of rotation.

\fBcounter\fR conforms to the "canonical encoder" interface described
in the HAL manual.
.SH FUNCTIONS
.TP
.B \fBcounter.capture\-position\fR (uses floating-point)
Updates the counts, position and velocity outputs based on internal counters.
.TP
.B \fBcounter.update\-counters\fR
Samples the phase\-A and phase\-Z inputs and updates internal counters.


.SH PINS
.TP
.B \fBcounter.\fIN\fB.phase\-A\fR bit in
The primary input signal.  The internal counter is incremented on each
rising edge.
.TP
.B \fBcounter.\fIN\fB.phase\-Z\fR bit in
The index input signal.  When the \fBindex\-enable\fR pin is TRUE and a rising
edge on \fBphase\-Z\fR is seen, \fBindex\-enable\fR is set to FALSE and the
internal counter is reset to zero.
.TP
.B \fBcounter.\fIN\fB.index\-enable\fR bit io
.TQ
.B \fBcounter.\fIN\fB.reset\fR bit io
.TQ
.B \fBcounter.\fIN\fB.counts\fR signed out
.TQ
.B \fBcounter.\fIN\fB.position\fR float out
.TQ
.B \fBcounter.\fIN\fB.velocity\fR float out
These pins function according to the canonical digital encoder interface.
.TP
.B \fBcounter.\fIN\fB.position\-scale\fR float rw
This parameter functions according to the canonical digital encoder interface.
.TP
.B \fBcounter.\fIN\fB.rawcounts\fR signed ro
The internal counts value, updated from \fBupdate\-counters\fR and reflected
in the output pins at the next call to \fBcapture\-position\fR.
.SH SEE ALSO
\fBencoder(9)\fR. in the LinuxCNC documentation.
.TH DEBOUNCE "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

debounce \- filter noisy digital inputs
.SH SYNOPSIS
.B loadrt debounce cfg=\fIsize[,size,...]\fB
.P
Creates debounce groups with the number of filters specified by (\fIsize\fR).
Every filter in the same group has the same sample rate and delay. For example
cfg=2,3 creates two filter groups with 2 filters in the first group and 3
filters in the second group.

.SH DESCRIPTION
The debounce filter works by incrementing a counter whenever the input is true,
and decrementing the counter when it is false.  If the counter decrements to
zero, the output is set false and the counter ignores further decrements.  If
the counter increments up to a threshold, the output is set true and the
counter ignores further increments.  If the counter is between zero and the
threshold, the output retains its previous state.  The threshold determines the
amount of filtering: a threshold of 1 does no filtering at all, and a threshold
of N requires a signal to be present for N samples before the output changes
state.  

.SH FUNCTIONS
.TP
.B debounce.\fIG\fR
Sample all the input pins in group G and update the output pins.
.SH PINS
.TP
.B debounce.\fIG\fB.\fIF\fB.in\fR bit in
The F'th input pin in group G.  
.TP
.B debounce.\fIG\fB.\fIF\fB.out\fR bit out
The F'th output pin in group G.  Reflects the last "stable" input seen on the
corresponding input pin.
.TP
.B debounce.\fIG\fB.delay\fR signed rw
Sets the amount of filtering for all pins in group G.
.TH ENCODER "9" "2009-04-15" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
encoder \- software counting of quadrature encoder signals
.SH SYNOPSIS
.B loadrt encoder [num_chan=\fInum\fB | names=\fIname1\fB[,\fIname2...\fB]]

.SH DESCRIPTION
\fBencoder\fR is used to measure position by counting the pulses
generated by a quadrature encoder.  As a software-based implementation
it is much less expensive than hardware, but has a limited maximum
count rate.  The limit is in the range of 10KHz to 50KHz, depending
on the computer speed and other factors.  If better performance is
needed, a hardware encoder counter is a better choice.  
Some hardware-based systems can count at MHz rates.
.P
\fBencoder\fR supports a maximum of eight channels.  The number of
channels actually loaded is set by the \fBnum_chan\fR argument when
the module is loaded.  Alternatively, specify names= and unique names
separated by commas.
.P
The \fBnum_chan=\fR and \fBnames=\fR specifiers are mutually exclusive.
If neither \fBnum_chan=\fR nor \fBnames=\fR are specified, or if
\fBnum_chan=0\fR is specified, the default value is three.
.P
\fBencoder\fR has a one-phase, unidirectional mode called \fIcounter\fR.
In this mode, the \fBphase\-B\fR input is ignored; the counts increase on
each rising edge of \fBphase\-A\fR.  This mode may be useful for counting
a unidirectional spindle with a single input line, though the noise-resistant
characteristics of quadrature are lost.

.SH FUNCTIONS
.TP 
\fBencoder.update\-counters\fR (no floating-point)
Does the actual counting, by sampling the encoder signals and decoding
the quadrature waveforms.  Must be called as frequently as possible,
preferably twice as fast as the maximum desired count rate.  Operates
on all channels at once.
.TP
\fBencoder.capture\-position\fR (uses floating point)
Captures the raw counts from \fBupdate\-counters\fR and performs scaling
and other necessary conversion, handles counter rollover, etc.  Can
(and should) be called less frequently than \fBupdate\-counters\fR.
Operates on all channels at once.

.SH NAMING
The names for pins and parameters are prefixed as:
  \fBencoder.N.\fR for N=0,1,...,num\-1 when using \fBnum_chan=num\fR
  \fBnameN.\fR for nameN=name1,name2,... when using \fBnames=name1,name2,...\fR

The \fBencoder.N.\fR format is shown in the following descriptions.


.SH PINS

.TP
\fBencoder.\fIN\fB.counter\-mode\fR bit i/o
Enables counter mode.  When true, the counter counts each rising edge of the
phase\-A input, ignoring the value on phase\-B.  This is useful for counting
the output of a single channel (non-quadrature) sensor.  When false (the
default), it counts in quadrature mode.
.TP
\fBencoder.\fIN\fB.counts\fR s32 out
Position in encoder counts.
.TP
\fBencoder.\fIN\fB.index\-enable\fR bit i/o
When true, \fBcounts\fR and \fBposition\fR are reset to zero on the next
rising edge of \fBPhase\-Z\fR.  At the same time, \fBindex\-enable\fR is reset
to zero to indicate that the rising edge has occurred.
.TP
\fBencoder.\fIN\fB.min\-speed\-estimate\fR float in (default: 1.0)
Determine the minimum speed at which \fBvelocity\fR will be
estimated as nonzero and \fBpostition\-interpolated\fR will be interpolated.
The units of \fBmin\-speed\-estimate\fR are the same as the units of
\fBvelocity\fR.  Setting this parameter too low will cause it to take a long
time for \fBvelocity\fR to go to 0 after encoder pulses have stopped arriving.
.TP
\fBencoder.\fIN\fB.phase\-A\fR bit in
Quadrature input for encoder channel \fIN\fR.
.TP
\fBencoder.\fIN\fB.phase\-B\fR bit in
Quadrature input.
.TP
\fBencoder.\fIN\fB.phase\-Z\fR bit in
Index pulse input.
.TP
\fBencoder.\fIN\fB.position\fR float out
Position in scaled units (see \fBposition\-scale\fR)
.TP
\fBencoder.\fIN\fB.position\-interpolated\fR float out
Position in scaled units, interpolated between encoder counts.  Only valid when
velocity is approximately constant and above \fBmin\-speed\-estimate\fR.  Do
not use for position control.
.TP
\fBencoder.\fIN\fB.position\-scale\fR float i/o
Scale factor, in counts per length unit.  For example, if \fBposition\-scale\fR
is 500, then 1000 counts of the encoder will be reported as a position of 2.0
units.
.TP
\fBencoder.\fIN\fB.rawcounts\fR s32 out
The raw count, as determined by \fBupdate\-counters\fR.  This value is updated
more frequently than \fBcounts\fR and \fBposition\fR.  It is also unaffected
by \fBreset\fR or the index pulse.
.TP
\fBencoder.\fIN\fB.reset\fR bit in
When true, \fBcounts\fR and \fBposition\fR are reset to zero immediately.
.TP
\fBencoder.\fIN\fB.velocity\fR float out
Velocity in scaled units per second.  \fBencoder\fR uses an algorithm that
greatly reduces quantization noise as compared to simply differentiating the
\fBposition\fR output.  When the magnitude of the true velocity is below
\fRmin\-speed\-estimate\fR, the \fRvelocity\fR output is 0.
.TP
\fBencoder.\fIN\fB.velocity-rpm\fR float out
Velocity in scaled units per minute. Simply \fBencoder.\fIN\fB.velocity\fR 
scaled by a factor of 60 for convenience.
.TP
\fBencoder.\fIN\fB.x4\-mode\fR bit i/o
Enables times\-4 mode.  When true (the default), the counter counts each edge
of the quadrature waveform (four counts per full cycle).  When false, it only
counts once per full cycle.  In \fBcounter\-mode\fR, this parameter is ignored.
.TP
\fBencoder.\fIN\fB.latch\-input\fR bit in
.TQ
\fBencoder.\fIN\fB.latch\-falling\fR bit in (default: \fBTRUE\fR)
.TQ
\fBencoder.\fIN\fB.latch\-rising\fR bit in (default: \fBTRUE\fR)
.TQ
\fBencoder.\fIN\fB.counts\-latched\fR s32 out
.TQ
\fBencoder.\fIN\fB.position\-latched\fR float out
Update \fBcounts\-latched\fR and \fBposition\-latched\fR on the rising and/or
falling edges of \fBlatch\-input\fR as indicated by \fBlatch\-rising\fR and
\fBlatch\-falling\fR.
.TP
\fBencoder.\fIN\fB.counter\-mode\fR bit rw
Enables counter mode.  When true, the counter counts each rising edge of the
phase\-A input, ignoring the value on phase\-B.  This is useful for counting
the output of a single channel (non-quadrature) sensor.  When false (the
default), it counts in quadrature mode.
\fBencoder.\fIN\fB.capture\-position.tmax\fR s32 rw
Maximum number of CPU cycles it took to execute this function.

.SH PARAMETERS
The encoder component has no HAL Parameters.


.TH ENCODER_RATIO "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
encoder_ratio \- an electronic gear to synchronize two axes
.SH SYNOPSIS
\fBloadrt encoder_ratio [num_chan=\fInum\fB | names=\fIname1\fB[,\fIname2...\fB]]

.SH DESCRIPTION
\fBencoder_ratio\fR can be used to synchronize two axes (like an "electronic
gear").  It counts encoder pulses from both axes in software, and produces an
error value that can be used with a PID loop to make the slave encoder track
the master encoder with a specific ratio.

This module supports up to eight axis pairs.  The number of pairs is set by the
module parameter \fBnum_chan\fR.  Alternatively, specify \fBnames=\fR and unique names
separated by commas.
.P
The \fBnum_chan=\fR and \fBnames=\fR specifiers are mutually exclusive.
If neither \fBnum_chan=\fR nor \fBnames=\fR are specified, the default value is one.


.SH FUNCTIONS
.TP
.B encoder\-ratio.sample
Read all input pins.  Must be called at twice the maximum desired count rate.
.TP
.B encoder\-ratio.update (uses floating-point)
Updates all output pins.  May be called from a slower thread.

.SH NAMING
The names for pins and parameters are prefixed as:
  \fBencoder\-ratio.N.\fR for N=0,1,...,num\-1 when using \fBnum_chan=num\fR
  \fBnameN.\fR for nameN=name1,name2,... when using \fBnames=name1,name2,...\fR

The \fBencoder\-ratio.N.\fR format is shown in the following descriptions.

.SH PINS

.TP
.B encoder\-ratio.\fIN\fB.master\-A\fR bit in
.TQ
.B encoder\-ratio.\fIN\fB.master\-B\fR bit in
.TQ
.B encoder\-ratio.\fIN\fB.slave\-A\fR bit in
.TQ
.B encoder\-ratio.\fIN\fB.slave\-B\fR bit in
The encoder channels of the master and slave axes
.TP
.B encoder\-ratio.\fIN\fB.enable\fR bit in
When the enable pin is FALSE, the error pin simply reports the slave axis
position, in revolutions.  As such, it would normally be connected to the
feedback pin of a PID block for closed loop control of the slave axis.
Normally the command input of the PID block is left unconnected (zero), so the
slave axis simply sits still.  However when the enable input goes TRUE, the
error pin becomes the slave position minus the scaled master position.  The
scale factor is the ratio of master teeth to slave teeth.  As the master moves,
error becomes non-zero, and the PID loop will drive the slave axis to track the
master.  
.TP
.B encoder\-ratio.\fIN\fB.error\fR float out
The error in the position of the slave (in revolutions)
.SH PARAMETERS
.TP
.B encoder\-ratio.N.master\-ppr\fR unsigned rw
.TQ
.B encoder\-ratio.N.slave\-ppr\fR unsigned rw
The number of pulses per revolution of the master and slave axes
.TP
.B encoder\-ratio.N.master\-teeth\fR unsigned rw
.TQ
.B encoder\-ratio.N.slave\-teeth\fR unsigned rw
The number of "teeth" on the master and slave gears.

.SH SEE ALSO
\fBencoder(9)\fR
.TH GANTRYKINS "9" "" "LinuxCNC Documentation" "Kinematics Module"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

gantrykins \- \fBSuperseded\fR by the general purpose \fBtrivkins\fR kinematics module.

To specify a gantry with non-identity kinematics: use trivkins with
the kinstype parameter set for KINEMATICS_BOTH.  Example:

.PP
  loadrt trivkins coordinates=xyyz \fBkinstypes=BOTH\fR

For more information:

$ man \-s 9 trivkins





.so man9/kins.9
.so man9/kins.9
.TH GENTRIVKINS "9" "LinuxCNC Documentation" "Kinematics Module"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

gentrivkins \- \fBSuperseded\fR by the general purpose \fBtrivkins\fR kinematics module.

For more information:

$ man -s 9 trivkins





.\"
.TH gladevcp "9" "2010-08-24" "LinuxCNC Documentation" "HAL Component" 
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
gladevcp \- displays Virtual control Panels built with GTK / GLADE 
.SH SYNOPSIS
\fBloadusr gladevcp  [\-c componentname0x\fIN\fB] [\-g WxH+Xoffset+Yoffset0x\fIN\fB] [\-H halcmdfile] [\-x windowid] gladefile.glade

.SH DESCRIPTION
gladevcp parses a glade file and displays the widgets in a window.
Then calls gladevcp_makepins which again parses the gladefile looking for specific HAL widgets
then makes HAL pins and sets up updating for them. 
The HAL component name defaults to the basename of the glade file.
The \-x option directs gladevcp to reparent itself under this X window id instead of creating its own toplevel window.
The \-H option passes an input file for halcmd to be run after the gladevcp component is initialized. This is used in Axis when 
running gladevcp under a tab with the EMBED_TAB_NAME/EMBED_TAB_COMMAND ini file feature.

gladevcp supports gtkbuilder or libglade files though some widgets are not fully supported in gtkbuilder yet.

.SH ISSUES
For now system links need to be added in the glade library folders to point to our new widgets and catalog files. look in lib/python/gladevcp/READ_ME for details

.TH hal_bb_gpio "9" "" "LinuxCNC Documentation" "HAL Component"
.SH NAME

hal_bb_gpio \- Driver for beaglebone GPIO pins

.SH SYNOPSIS
.HP
.B loadrt hal_bb_gpio \fIuser_leds=#,...\fR \fIinput_pins=#,...\fR \fIoutput_pins=#,...\fB

.SH USER LEDS
The \fIuser_leds\fR loadrt parameter controls which LEDs are available to HAL.
Valid range: 0..3.  These LEDs are next to the ethernet jack and the linuxcnc
numbers match the silkscreen on beaglbone black.  Empirically, these seem to be
OR'd with whatever function is assigned to the LED in Linux.

.SS PINS
.TP
\fBbb_gpio.userled\fIN\fR bit in
.TQ
\fBbb_gpio.userled\fIN\fB-invert\fR bit in
The associated LED is lit if \fBuserled\fIN\fR xor \fBuserled\fIN\fR-invert\fB
is TRUE.

.SH INPUT PINS
The \fIinput_pins\fR loadrt parameter controls which physical I/O pins are
available to HAL as input pins.  The numbering is "800+N" for pin N on
connector P8, and "900+N" for pin N on connector P9.  For example, "803"
means connector P8 pin 3, which is also described in BeagleBone documentation
as "gpmc_ad6".

Specifying pins that are otherwise in use by the system may have undesirable
side effects, such as crashing rtapi_app or the whole system.

.SS PINS
.TP
\fBbb_gpio.p\fIN\fB.in-\fINN\fR bit out
.TQ
\fBbb_gpio.p\fIN\fB.in-\fINN\fB-invert\fR bit in
\fBin-\fINN\fR is a snapshot of the value of the corresponding physical pin XOR
the value of the corresponding \fBin-\fINN\fB-invert\fR pin.

.SH OUTPUT PINS
The \fIinput_pins\fR loadrt parameter controls which physical I/O pins are
available to HAL as input pins.  The numbering is "800+N" for pin N on
connector P8, and "900+N" for pin N on connector P9.

Specifying pins that are otherwise in use by the system may have undesirable
side effects, such as crashing rtapi_app or the whole system.

.SS PINS
.TP
\fBbb_gpio.p\fIN\fB.out-\fINN\fR bit out
.TQ
\fBbb_gpio.p\fIN\fB.out-\fINN\fB-invert\fR bit in
The corresponding physical pin is driven with the result of
\fBin-\fINN\fR xor \fBin-\fINN\fB-invert\fR.

.SH PARAMETERS
None

.SH FUNCTIONS
.TP
.B bb_gpio.read
Update HAL pins from physical pins
.TP
.B bb_gpio.write
Update physical pins from HAL pins

.SH LICENSE
GPL
.TH HM2_7I43 "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..
.SH NAME

hm2_7i43 \- LinuxCNC HAL driver for the Mesa Electronics 7i43 EPP Anything IO board with HostMot2 firmware.
.SH SYNOPSIS

.HP
.B loadrt hm2_7i43 [ioaddr=\fIN\fB[,\fIN\fB...]] [ioaddr_hi=\fIN\fB[,\fIN\fB...]] [epp_wide=\fIN\fB[,\fIN\fB...]] [config=\fI"str[,str...]"\fB] [debug_epp=\fIN\fB[,\fIN\fB...]]
.RS 4
.TP
\fBioaddr\fR [default: 0 (parport0)]
The base address of the parallel port.

The number of ioaddr indexes/addresses given is used by the driver to
determine how many boards to search for.
.TP
\fBioaddr_hi\fR [default: 0]
The secondary address of the parallel port, used to set EPP mode.
0 means to use ioaddr + 0x400.
.TP
\fBepp_wide\fR [default: 1]
Set to zero to disable the "wide EPP mode".  "Wide" mode allows a 16-
and 32-bit EPP transfers, which can reduce the time spent in the read
and write functions.  However, this may not work on all EPP parallel
ports.
.TP
\fBconfig\fR [default: ""]
HostMot2 config strings, described in the hostmot2(9) manpage.
.TP
\fBdebug_epp\fR [default: 0]
Developer/debug use only!  Enable debug logging of most EPP
transfers.
.RE
.SH DESCRIPTION

hm2_7i43 is a device driver that interfaces the Mesa 7i43 board with
the HostMot2 firmware to the LinuxCNC HAL.  Both the 200K and the 400K
FPGAs are supported.

The driver talks with the 7i43 over the parallel port, not over USB.  USB
can be used to power the 7i43, but not to talk to it.  USB communication
with the 7i43 will not be supported any time soon, since USB has poor
real-time qualities.

The driver programs the board's FPGA with firmware when it registers
the board with the hostmot2 driver.  The firmware to load is specified
in the \fBconfig\fR modparam, as described in the hostmot2(9) manpage,
in the \fIconfig modparam\fR section.

.SH Jumper settings

To send the FPGA configuration from the PC, the board must be configured
to get its firmware from the EPP port.  To do this, jumpers W4 and W5
must both be down, ie toward the USB connector.

The board must be configured to power on whether or not the USB interface
is active.  This is done by setting jumper W7 up, ie away from the edge
of the board.
.SH Communicating with the board

The 7i43 communicates with the LinuxCNC computer over EPP, the Enhanced
Parallel Port.  This provides about 1 MBps of throughput, and the
communication latency is very predictable and reasonably low.

The parallel port must support EPP 1.7 or EPP 1.9.  EPP 1.9 is prefered,
but EPP 1.7 will work too.  The EPP mode of the parallel port is sometimes
a setting in the BIOS.

Note that the popular "NetMOS" aka "MosChip 9805" PCI parport cards \fBdo
not work\fR.  They do not meet the EPP spec, and cannot be reliably used
with the 7i43.  You have to find another card, sorry.

EPP is very reliable under normal circumstances, but bad cabling
or excessively long cabling runs may cause communication timeouts.
The driver exports a parameter named hm2_7i43.<BoardNum>.io_error to
inform HAL of this condition.  When the driver detects an EPP timeout,
it sets io_error to True and stops communicating with the 7i43 board.
Setting io_error back to False makes the driver start trying to
communicate with the 7i43 again.

Access to the EPP bus is not threadsafe: only one realtime thread may
access the EPP bus.
.SH SEE ALSO

hostmot2(9)
.SH LICENSE

GPL
.TH HM2_7I90 "9" "2013-10-27" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..
.SH NAME

hm2_7i90 \- LinuxCNC HAL driver for the Mesa Electronics 7i90 EPP Anything IO board with HostMot2 firmware.
.SH SYNOPSIS

.HP
.B loadrt hm2_7i90 [ioaddr=\fIN\fB[,\fIN\fB...]] [ioaddr_hi=\fIN\fB[,\fIN\fB...]] [epp_wide=\fIN\fB[,\fIN\fB...]] [debug_epp=\fIN\fB[,\fIN\fB...]]
.RS 4
.TP
\fBioaddr\fR [default: 0 (parport0)]
The base address of the parallel port.

The number of ioaddr indexes/addresses given is used by the driver to
determine how many boards to search for. Previously the number of config
strings was used, but a blank config string is perfectly acceptable for
7i90.
.TP
\fBioaddr_hi\fR [default: 0]
The secondary address of the parallel port, used to set EPP mode.
0 means to use ioaddr + 0x400.
.TP
\fBepp_wide\fR [default: 1]
Set to zero to disable the "wide EPP mode".  "Wide" mode allows a 16-
and 32-bit EPP transfers, which can reduce the time spent in the read
and write functions.  However, this may not work on all EPP parallel
ports.
.TP
\fBconfig\fR [default: ""]
HostMot2 config strings, described in the hostmot2(9) manpage.
.TP
\fBdebug_epp\fR [default: 0]
Developer/debug use only!  Enable debug logging of most EPP
transfers.
.RE
.SH DESCRIPTION

hm2_7i90 is a device driver that interfaces the Mesa 7i90 board with
the HostMot2 firmware to the LinuxCNC HAL.

The 7i90 firmware is stored on the 7i90 itself, it is not programmed
by the driver at load time.  The 7i90 firmware can be changed using the
mesaflash program.

The driver talks with the 7i90 over the parallel port, via EPP.
.SH Communicating with the board

The 7i90 communicates with the LinuxCNC computer over EPP, the Enhanced
Parallel Port.  This provides about 1 MBps of throughput, and the
communication latency is very predictable and reasonably low.

The parallel port must support EPP 1.7 or EPP 1.9.  EPP 1.9 is prefered,
but EPP 1.7 will work too.  The EPP mode of the parallel port is sometimes
a setting in the BIOS.

Note that the popular "NetMOS" aka "MosChip 9805" PCI parport cards \fBdo
not work\fR.  They do not meet the EPP spec, and cannot be reliably used
with the 7i90.  You have to find another card, sorry.

EPP is very reliable under normal circumstances, but bad cabling
or excessively long cabling runs may cause communication timeouts.
The driver exports a parameter named hm2_7i90.<BoardNum>.io_error to
inform HAL of this condition.  When the driver detects an EPP timeout,
it sets io_error to True and stops communicating with the 7i90 board.
Setting io_error back to False makes the driver start trying to
communicate with the 7i90 again.

Access to the EPP bus is not threadsafe: only one realtime thread may
access the EPP bus.
.SH SEE ALSO

hostmot2(9)
.SH LICENSE

GPL
.\" Copyright (c) 2014 Jeff Epler
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
.\" USA.
.TH HM2_ETH "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

hm2_eth \- LinuxCNC HAL driver for the Mesa Electronics Ethernet Anything IO boards, with HostMot2 firmware.
.SH SYNOPSIS

.HP
.B loadrt hm2_eth [config=\fI"str[,str...]"\fB] [board_ip=\fIip[,ip...]\fB] [board_mac=\fImac[,mac...]\fB]
.RS 4
.TP
\fBconfig\fR [default: ""]
HostMot2 config strings, described in the hostmot2(9) manpage.
.TP
\fBboard_ip\fR [default: ""]
The IP address of the board(s), separated by commas.  As shipped, the board address is 192.168.1.121.
.SH DESCRIPTION

hm2_eth is a device driver that interfaces Mesa's ethernet
based Anything I/O boards (with the HostMot2 firmware) to the LinuxCNC
HAL.

The supported boards are: 7i76E, 7I80DB, 7I80HD, 7i92, 7i93, 7i96.

The board must have its hardware loaded on the board by the mesaflash(1) program.

hm2_eth is only available when linuxcnc is configured with "uspace" realtime.

.SH INTERFACE CONFIGURATION

hm2_eth should be used on a dedicated network interface, with only a cable
between the PC and the board.  Wireless and USB network interfaces are not
suitable.

These instructions assume your dedicated network interface is "eth1",
192.168.1/24 is an unused private network, that the hostmot2 board is using the
default address of 192.168.1.121, that you are using Debian 7 or similar, and
that you do not otherwise use iptables.  If any of these are false, you will
need to modify the instructions accordingly.  After following all the
instructions, reboot so that the changes take effect.

It is particularly important to check that the network 192.168.1/24 is not
already the private network used by your internet router, because this is a
commonly-used value.  If you use another network, you will also need to
reconfigure the hostmot2 card to use an IP address on that network by using the
mesaflash(1) utility and change jumper settings.  Typically, you will choose
one of the networks in the
.UR http://en.wikipedia.org/wiki/IPv4#Private_networks
Private IPv4 address space.
.UE
One common alternative is PC address 10.10.10.1, hostmot2 address 10.10.10.10.

Use of the dedicated ethernet interface while linuxcnc is running can cause
violation of realtime guarantees.  hm2_eth will automatically mitigate most
accidental causes of interference.

.SS Configure network with static address
Add these lines to the file /etc/network/interfaces to configure eth1 with a
static address:

.EX
auto eth1
iface eth1 inet static
    address 192.168.1.1
    hardware\-irq\-coalesce\-rx\-usecs 0
.EE

.SH PACKET LOSS
While ethernet is fairly resistant to electrical noise, many systems will not
have 100% perfect packet reception.
The hm2_eth driver has a limited ability to deal with lost packets.  Packet
loss is detected by transmitting an expected read or write packet count with
each request, and checking the value with each read response.  When a lost
packet is detected, the
.B packet\-error
pin is asserted in that cycle, the
.B packet\-error\-level
pin is increased, and if it reaches a threshold then a permanent low-level
I/O error is signaled.

However, not all hm2 special functions know how to properly recover from lost
packets.  For instance, the encoder special function does not properly manage
the index feature when packets are lost.  The author believes that this can
lead to rare failures in home-to-index, which can have severe consequences.

On the other hand, pid-stepper systems will run properly for extended periods
of time with packet loss on the order of .01%, as long as following error is
increased enough that having stale position feedback does not trigger a
following error.  Altering the HAL configuration so that during transient
packet loss the pid and motion feedback value is equal to the command value,
instead of the stale feedback value, appears to improve tuning.  This can be
accomplished with a
.B mux2(9)
component for each feedback signal, using
.B packet\-error
as the mux2
.B sel
input.

.SH PINS
In addition to the pins documented in
.BR hostmot2(9) ", " hm2_eth(9)
creates additional pins:

.TP
(bit, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-error
This pin is TRUE when the most recent cycle detected a read or write error,
and FALSE at other times.
.TP
(s32, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-error\-level
This pin shows the current error level, with higher numbers indicating
a greater number of recent detected errors.  The error level is always in
the range from 0 to packet\-error\-limit, inclusive.
.TP
(bit, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-error\-exceeded
This pin is TRUE when the current error level is equal to the maximum,
and FALSE at other times.

.SH PARAMETERS
In addition to the parameters documented in
.BR hostmot2(9) ", " hm2_eth(9)
creates additional parameters:

.TP
(s32, rw) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-error\-decrement
The amount deducted from \fIpacket\-error\-level\fR in a cycle without
detected read or write errors, without going below zero.

.TP
(s32, rw) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-error\-increment
The amount added to \fIpacket\-error\-level\fR in a cycle without
detected read or write errors, without going above packet\-error\-limit.

.TP
(s32, rw) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-error\-limit
The level at which a detected read or write error is treated as a permament
error.  When this error level is reached, the board's \fIio\-error\fR pin
becomes TRUE and the condition must be manually reset.

.TP
(s32, rw) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.packet\-read\-timeout
The length of time that must pass before a read request times out.
If the value is less than or equal to 0, it is interpreted as 80% of the thread
period.  If the value is less than 100, it is interpreted as a percentage of
the thread period.  Otherwise, it is interpreted as a time in nanoseconds.  In
any case, the timeout is never less than 100 microseconds.

Setting this value too low can cause spurious read errors.  Setting it too
high can cause realtime delay errors.


.SH NOTES
hm2_eth uses an iptables chain called "hm2\-eth\-rules\-output" to control access
to the network interface while hal is running.  The chain is created if it does
not exist, and a jump to it is inserted at the beginning of the OUTPUT chain if
it is not there already.  If you have an existing iptables setup, you can insert
a direct jump from OUTPUT to hm2\-eth\-rules\-output in an order appropriate to
your local network.

At (normal) exit, hm2_eth will remove the rules.  After a crash, you can
manually clear the rules with \fBsudo iptables \-F hm2\-eth\-rules\-output\fR;
the rules are also removed by a reboot.

"hardware\-irq\-coalesce\-rx\-usecs" decreases time waiting to receive a packet
on most systems, but on at least some Marvel-chipset NICs it is harmful.
If the line does not improve system performance, then remove it.  A reboot
is required for the value to be set back to its power-on default.  This
requires the ethtool package to be installed.

.SH BUGS
Some hostmot2 functions such uart are coded in a way that causes additional
latency when used with hm2_eth.

On the 7i92, the HAL pins for the LEDs are called CR01..CR04, but the
silkscreens are CR3..CR6.  Depending on the FPGA firmware, the LEDs may
initially be under control of the ethernet engine.  This can be changed until
power cycle with

.EX
elbpcom 01D914000000
.EE

Depending on firmware version, this driver may cause the hardware error
LED to light even though the driver and hardware are functioning normally.
This will reportedly be fixed in future bitfile updates from Mesa.

.SH SEE ALSO

.BR hostmot2 "(9), " elbpcom (1)
.SH LICENSE

GPL
.TH HM2_PCI "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

hm2_pci \- LinuxCNC HAL driver for the Mesa Electronics PCI-based Anything IO boards, with HostMot2 firmware.
.SH SYNOPSIS

.HP
.B loadrt hm2_pci [config=\fI"str[,str...]"\fB]
.RS 4
.TP
\fBconfig\fR [default: ""]
HostMot2 config strings, described in the hostmot2(9) manpage.
.RE
.SH DESCRIPTION

hm2_pci is a device driver that interfaces Mesa's PCI and PC-104/Plus
based Anything I/O boards (with the HostMot2 firmware) to the LinuxCNC
HAL.

The supported boards are: the 5i20, 5i21, 5i22, 5i23, 5i24, and 5i25 (all on
PCI); the 4i65, 4i68, and 4i69 (on PC-104/Plus), and the 3x20 (using a
6i68 or 7i68 carrier card) and 6i25 (on PCI Express).

The driver optionally programs the board's FPGA with firmware when it registers
the board with the hostmot2 driver.  The firmware to load is specified
in the \fBconfig\fR modparam, as described in the hostmot2(9) manpage,
in the \fIconfig modparam\fR section.
.SH SEE ALSO

hostmot2(9)
.SH LICENSE

GPL
.\" Copyright (c) 2016 W. Martinjak
.\" Copyright (c) 2017 B. Stultiens
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
.\" USA.
.TH HM2_RPSPI "9" "2017-06-05" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

hm2_rpspi \- LinuxCNC HAL driver for the Mesa Electronics SPI Anything IO boards, with HostMot2 firmware.
.SH SYNOPSIS

.HP
.B loadrt hm2_rpspi
.RS 4
.TP
\fBconfig\fR [default: ""]
HostMot2 config strings, described in the
.BR hostmot2 (9)
manpage.
.TP
\fBspiclk_rate\fR [default: 31250]
Specify the SPI clock rate in kHz. See
.BR SPI\ CLOCK\ RATES
below.
.TP
\fBspiclk_rate_rd\fR [default: -1 (same as \fBspiclk_rate\fR)]
Specify the SPI read clock rate in kHz. Usually you read and write at the same
speed. However, you may want to reduce the reading speed if the round-trip is
too long (see
.BR SPI\ CLOCK\ RATES
below).
.TP
\fBspiclk_base\fR [default: 400000000]
This is the SPI clock divider calculation fallback value. Usually, the base
rate is read from
.I /sys/kernel/debug/clk/vpu/clk_rate
and used in the divider calculation (for the Rpi3 it should be 250\ MHz). The
\fBspiclk_base\fR is \fIonly\fR used as a fallback if the system's cannot be
read. It is normally safe (and recommended) that you leave this parameter as
is.
.br
You should set this manually to 250000000 if your system does not provide
access to the kernel clock settings. Otherwise, your SPI clock frequency will
be only 62.5% of the requested value.
.TP
\fBspi_pull_miso\fR [default: 1 (pull\-down)]
.TP
\fBspi_pull_mosi\fR [default: 1 (pull\-down)]
.TP
\fBspi_pull_sclk\fR [default: 1 (pull\-down)]
Enable or disable pull\-up/pull-down on the SPI lines. A value of 0 disables
any pull\-up/down on the pin. A value of 1 means pull\-down and 2 means
pull\-up. The chip enable line(s) are always pull\-up enabled.
.TP
\fBspi_probe\fR [default: 1]
Probe SPI port and CE lines for a card. This is a bit\-field indicating which
combinations of SPI and CE should be probed:
 \-  1 = SPI0/CE0,
 \-  2 = SPI0/CE1,
 \-  4 = SPI1/CE0,
 \-  8 = SPI1/CE1,
 \- 16 = SPI1/CE2.

The probe is performed exactly in above order. Any boards found will be
numbered 0...4 in the order found. See also
.BR INTERFACE\ CONFGURATION
below.

It is an error if a probe fails and the driver will abort.  The SPI0/SPI1
peripherals are located at gpio pins (with 40-pin I/O header pin\-number in
parentheses):
 \- SPI0: MOSI=10(19), MISO=9(21), SCLK=11(23), CE0=8(24), CE1=7(26)
 \- SPI1: MOSI=20(38), MISO=19(35), SCLK=21(40), CE0=18(12), CE1=17(11), CE2=16(36)

.TP
\fBspi_debug\fR [default: \-1]
Set the message level of the running process. The message level is set if
\fBspi_debug\fR is set to a positive value between 0 and 5, where 0 means no
messages at all and 5 means everything. A value of \-1 does not touch the
current message level.

Caveat Emptor: changing the message level is process-wide and all modules
within the process will spit out messages at the requested level. This may
cause quite some clutter in your terminal.

.SH DESCRIPTION

hm2_rpspi is a device driver for the Raspberry Pi 2/3 that interfaces Mesa's
SPI based Anything I/O boards (with the HostMot2 firmware) to the LinuxCNC HAL.
This driver is not based on the linux spidev driver, but on a dedicated
BCM2835\-SPI driver.

It is \fBstrongly\fR recommended that you unload/disable the kernel's spidev
driver by disabling it using
.BR raspi-config .
Please note that having both kernel and user\-space SPI drivers installed can
result in unexpected interactions and system instabilities.

The supported boards are: 7I90HD.

The board must have a compatible firmware (ie.: 7i90_spi_svst4_8.bit) loaded on
the board by the
.BR mesaflash (1)
program.

hm2_rpspi is only available when linuxcnc is configured with "uspace" realtime.
It works with Raspian and PREEMPT_RT kernel.

.SH INTERFACE CONFIGURATION

Up to five devices (7i90 boards) are supported. Two on SPI0 and three on SPI1.
It is recommended that you, at most, use two devices and each device connected
to a separate SPI port. You can choose which CE lines you prefer or fit the
design and setup the \fBspi_probe\fR parameter to instruct the driver where to
search for the board(s).

.SH REALTIME PERFORMANCE OF THE BCM2835-SPI DRIVER

TBD.
.\"As of kernel 3.8, most or all kernel SPI drivers do not achieve the high"
.\"realtime response rate required for a typical linuxcnc configuration.  The"
.\"driver was tested with ..."

.SH SPI CLOCK RATES
The maximum SPI clock of the BCM2835-SPI driver and the 7i90 is documented over
32MHz. The SPI driver can provide frequencies well beyond what is acceptable
for the 7i90. A safe value to start with would be 12.5\ MHz (spiclk_rate=12500)
and then work your way up from there.

The SPI driver generates (very) discrete clock frequency values, especially in
the MHz range because of a simple clock divider structure. The base frequency
is 250\ MHz and the divider for SPI0/SPI1 scales using discrete factors. The
following list specifies the \fBspiclk_rate\fR setting and the discrete SPI
clock frequency (250\ MHz\ /\ (2n) for n\ >\ 1):
 \- 62500 \- 62.500\ MHz,
 \- 41667 \- 41.667\ MHz,
 \- 31250 \- 31.250\ MHz,
 \- 25000 \- 25.000\ MHz,
 \- 20834 \- 20.833\ MHz,
 \- 17858 \- 17.857\ MHz,
 \- 15625 \- 15.625\ MHz,
 \- 13889 \- 13.889\ MHz,
 \- 12500 \- 12.500\ MHz,
 \- 11364 \- 11.364\ MHz,
 \- 10417 \- 10.417\ MHz,
 \-  9616 \-  9.615\ MHz,
 \- ....

The lowest selectable SPI clock frequency is 30\ kHz (spiclk_rate=30) for SPI0
and SPI1. Theoretically, the SPI0 port could go slower, but there is no point
in doing so. You should not expect any real\-time performance with such slow
setting, unless your machine is located next to a black hole.

The highest SPI clock frequency is, theoretically, 125\ MHz. However, you will
not be able to build any reliable hardware interface at that frequency. The
driver limits the clock to 62.5\ MHz (cpiclk_rate=62500). The chances are
rather slim that you get the interface to work reliably at this frequency. The
7i90 interface only supports frequencies up to 50\ MHz and that is with perfect
cabling and impedance matching (in write direction only).

Writing to the 7i90 may be done faster than reading. This is especially
important if you have "long" wires or any buffers on the SPI\-bus path. You can
set the read clock frequency to a lower value (using \fBspiclk_rate_rd\fR) to
counter the effects of the SPI\-bus round-trip needed for read actions. For
example, you can write at 41.67\ MHz and read at 25.00\ MHz.

It should be noted that the Rpi3 \fBmust\fR have an adequate 5V power supply
and the power should be properly decoupled right on the 40\-pin I/O header. At
high speeds and noise on the supply, there is the possibility of noise throwing
off the SoC's PLL(s), resulting in strange behaviour.

For optimal performance on the Rpi3, you must disable the "ondemand" CPU
frequency governor. You may add the following to your /etc/rc.local file:
 echo -n 1200000 > /sys/devices/system/cpu/cpufreq/policy0/scaling_min_freq
 echo -n performance > /sys/devices/system/cpu/cpufreq/policy0/scaling_governor

Be sure to have a proper heatsink mounted on the SoC or it will get too warm
and crash.

.SH SEE ALSO

.BR hostmot2 (9)

.SH LICENSE

GPL
.\" Copyright (c) 2014 Jeff Epler
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
.\" USA.
.TH HM2_SPI "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

hm2_spi \- LinuxCNC HAL driver for the Mesa Electronics SPI Anything IO boards, with HostMot2 firmware.
.SH SYNOPSIS

.HP
.B loadrt hm2_spi [config=\fI"str[,str...]"\fB] [spidev_path=path[,path...]\fB] [spidev_rate=\fIrate[,rate...]\fB]
.RS 4
.TP
\fBconfig\fR [default: ""]
HostMot2 config strings, described in the hostmot2(9) manpage.
.TP
\fBspidev_path\fR [default: "/dev/spidev1.0"]
The path to the spi device node, a character special device in /dev
.TP
\fBspidev_rate\fR [default: 24000]
The desired rate of the SPI clock in kHz.  If the exact specified clock is not
available, a lower clock is used.  Due to shortcomings in the spidev API, it is
not possible for hal to report the actual clock used.
.SH DESCRIPTION

hm2_spi is a device driver that interfaces Mesa's SPI
based Anything I/O boards (with the HostMot2 firmware) to the LinuxCNC
HAL.

The supported boards are: 7I90HD.

The board must have a compatible firmware loaded on the board by the
mesaflash(1) program.

hm2_spi is only available when linuxcnc is configured with "uspace" realtime.

.SH INTERFACE CONFIGURATION

It is possible for one SPI bus to connect several devices; in this
configuration, a master device has several chip select lines.  In order to meet
realtime deadlines,  hm2_spi should be used on a dedicated SPI interface not
shared with any other slaves.

.SH REALTIME PERFORMANCE OF LINUX SPIDEV DRIVERS

As of kernel 3.8, most or all kernel SPI drivers do not achieve the high
realtime response rate required for a typical linuxcnc configuration.  The
driver was tested with a modified version of the spi\-s3c64xx SPI driver on the
Odroid U3 platform.  The patched kernel resides
.UR https://github.com/jepler/odroid\-linux/tree/odroid\-3.8.13\-rt
on github
.UE .

.SH SPI CLOCK RATES
The maximum SPI clock of the 7i90 is documented as 50MHz.  Other elements of
the data path between HAL and the 7i90 may impose other limitations.

.SH SEE ALSO

hostmot2(9)
.SH LICENSE

GPL
.TH HOSTMOT2 "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..
.SH NAME

hostmot2 \- LinuxCNC HAL driver for the Mesa Electronics HostMot2 firmware.
.SH SYNOPSIS
See the config modparam section below for Mesa card configuration. Typically
hostmot2 is loaded with no parameters unless debugging is required.
.HP
.B loadrt hostmot2 [debug_idrom=\fIN\fB] [debug_module_descriptors=\fIN\fB] [debug_pin_descriptors=\fIN\fB] [debug_modules=\fIN\fB]
.TP
\fBdebug_idrom\fR [default: 0]
Developer/debug use only!  Enable debug logging of the HostMot2
IDROM header.
.TP
\fBdebug_module_descriptors\fR [default: 0]
Developer/debug use only!  Enable debug logging of the HostMot2
Module Descriptors.
.TP
\fBdebug_pin_descriptors\fR [default: 0]
Developer/debug use only!  Enable debug logging of the HostMot2
Pin Descriptors.
.TP
\fBdebug_modules\fR [default: 0]
Developer/debug use only!  Enable debug logging of the HostMot2
Modules used.
.TP
\fBuse_serial_numbers\fR [default: 0]
When creating HAL pins for smart-serial devices name the pins by the board serial
number rather than which board and port they are connected to. 
With this option set to 1 pins will have names like \fBhm2_8i20.1234.current\fR rather than
\fBhm2_5i23.0.8i20.0.1.current\fR. The identifier consists of the last 4 digits of the board
serial number, which is normally on a sticker on the board. 
This will make configs less portable, but does mean that boards can be re-connected less
carefully. 

.SH DESCRIPTION
hostmot2 is a device driver that interfaces the Mesa HostMot2 firmware
to the LinuxCNC HAL.  This driver by itself does nothing, the boards
that actually run the firmware require their own drivers before anything
can happen.  Currently drivers are available for the 5i20, 5i22, 5i23,
5i25, 3x20, 4i65, and 4i68 (all using the hm2_pci module) and the 7i43
(using the hm2_7i43 module).

The HostMot2 firmware provides modules such as encoders, PWM generators,
step/dir generators, and general purpose I/O pins (GPIOs).  These things are
called "Modules".  The firmware is configured, at firmware compile time,
to provide zero or more instances of each of these Modules.
.SH Board I/O Pins

The HostMot2 firmware runs on an FPGA board.  The board interfaces with
the computer via PCI, PC-104/Plus, or EPP, and interfaces with motion
control hardware such as servos and stepper motors via I/O pins on
the board.

Each I/O pin can be configured, at board-driver load time, to serve
one of two purposes: either as a particular I/O pin of a particular
Module instance (encoder, pwmgen, stepgen etc), or as a general purpose
digital I/O pin.  By default all Module instances are enabled, and all the
board's pins are used by the Module instances.

The user can disable Module instances at board-driver load time, by
specifying a hostmot2 config string modparam.  Any pins which belong to
Module instances that have been disabled automatically become GPIOs.

All IO pins have some HAL presence, whether they belong to an active
module instance or are full GPIOs.  GPIOs can be changed (at run-time)
between inputs, normal outputs, and open drains, and have a flexible
HAL interface.  IO pins that belong to active Module instances are
constrained by the requirements of the owning Module, and have a more
limited interface in HAL.  This is described in the General Purpose
I/O section below.
.SH config modparam

All the board-driver modules (hm2_pci and hm2_7i43) accept a load-time
modparam of type string array, named "config".  This array has one config
string for each board the driver should use.  Each board's config string
is passed to and parsed by the hostmot2 driver when the board-driver
registers the board.

The config string can contain spaces, so it is usually a good idea to
wrap the whole thing in double-quotes (the " character).

The comma character (,) separates members of the config array from
each other.

For example, if your control computer has one 5i20 and one 5i23 you
might load the hm2_pci driver with a HAL command (in halcmd) something
like this:

.B
.nf
loadrt hm2_pci config="firmware=hm2/5i20/SVST8_4.BIT num_encoders=3 num_pwmgens=3 num_stepgens=3,firmware=hm2/5i23/SVSS8_8.BIT sserial_port_0=0000 num_encoders=4"
.fi

Note: this assumes that the hm2_pci driver detects the 5i20 first and
the 5i23 second.  If the detection order does not match the order
of the config strings, the hostmot2 driver will refuse to load the
firmware and the board-driver (hm2_pci or hm2_7i43) will fail to load.
To the best of my knowledge, there is no way to predict the order in
which PCI boards will be detected by the driver, but the detection
order will be consistent as long as PCI boards are not moved around.
Best to try loading it and see what the detection order is.

The valid entries in the format string are:

.B
 [firmware=\fIF\fB]
 \fB[num_encoders=\fIN\fB]
 [ssi_chan_\fIN\fB=\fIabc%nq\fB]
 [biss_chan_\fIN\fB=\fIabc%nq\fB]
 [fanuc_chan_\fIN\fB=\fIabc%nq\fB]
 [num_resolvers=\fIN\fB]
 [num_pwmgens=\fIN\fB]
 [num_3pwmgens=\fIN\fB]
 [num_stepgens=\fIN\fB]
 [stepgen_width=\fIN\fB]
 [sserial_port_\fI0\fB=\fI00000000\fB]
 [num_leds=\fIN\fB]
 [num_ssrs=\fIN\fB]
 [enable_raw]

.TP
\fBfirmware [\fIoptional\fB]
Load the firmware specified by F into the FPGA on this board.  If no
"\fBfirmware=\fIF\fR" string is specified, the FPGA will not be
re-programmed but may continue to run a previously downloaded firmware.

The requested firmware F is fetched by udev.  udev searches for the
firmware in the system's firmware search path, usually /lib/firmware.
F typically has the form "hm2/<BoardType>/file.bit"; a typical value
for F might be "hm2/5i20/SVST8_4.BIT".  The hostmot2 firmware files are
supplied by the hostmot2\-firmware packages, available from linuxcnc.org and can
normally be installed by entering the command "sudo apt\-get install
hostmot2\-firmware\-5i23" to install the support files for the 5i23 for example.

The 5i25 / 6i25 come pre-programmed with firmware and no "firmware=" string
should be used with these cards. To change the firmware on a 5i25 or 6i25 the
"mesaflash" utility should be used (available from Mesa). It is perfectly
valid and reasonable to load these cards with no config string at all.
.TP
\fBnum_dplls\fR [optional, default: \-1]
The hm2dpll is a phase-locked loop timer module which may be used to trigger
certain types of encoder. This parameter can be used to disable the hm2dpll by
setting the number to 0. There is only ever one module of this type, with 4 
timer channels, so the other valid numbers are \-1 (enable all) and 1, both of
which end up meaning the same thing. 
.TP
\fBnum_encoders\fR [optional, default: \-1]
Only enable the first N encoders.  If N is \-1, all encoders are enabled.
If N is 0, no encoders are enabled.  If N is greater than the number of
encoders available in the firmware, the board will fail to register.
.TP
\fBssi_chan_N\fR [optional, default: ""]
Specifies how the bit stream from a Synchronous Serial Interface device will be
interpreted. There should be an entry for each device connected. Only channels
with a format specifier will be enabled. (as the software can not guess data
rates and bit lengths) 
.TP
\fBbiss_chan_N\fR [optional, default: ""]
As for ssi_chan_N, but for BiSS devices
.TP
\fBfanuc_chan_N\fR [optional, default: ""]
Specifies how the bit stream from a Fanuc absolute encoder will be
interpreted. There should be an entry for each device connected. Only channels
with a format specifier will be enabled. (as the software can not guess data
rates and bit lengths) 
.TP
\fBnum_resolvers\fR [optional, default: \-1]
Only enable the first N resolvers. If N = \-1 then all resolvers are enabled.
This module does not work with generic resolvers (unlike the encoder module
which works with any encoder). At the time of writing the  Hostmot2 Resolver
function only works with the Mesa 7i49 card.
.TP
\fBnum_pwmgens\fR [optional, default: \-1]
Only enable the first N pwmgens.  If N is \-1, all pwmgens are enabled.
If N is 0, no pwmgens are enabled.  If N is greater than the number of
pwmgens available in the firmware, the board will fail to register.
.TP
\fBnum_3pwmgens\fR [optional, default: \-1]
Only enable the first N Three-phase pwmgens.  If N is \-1, all 3pwmgens
are enabled. If N is 0, no pwmgens are enabled.  If N is greater than the
number of pwmgens available in the firmware, the board will fail to register.
.TP
\fBnum_stepgens\fR [optional, default: \-1]
Only enable the first N stepgens.  If N is \-1, all stepgens are enabled.
If N is 0, no stepgens are enabled.  If N is greater than the number of
stepgens available in the firmware, the board will fail to register.
.TP
.TP
\fBstepgen_width\fR [optional, default: 2]
Used to mask extra, unwanted, stepgen pins. Stepper drives typically require
only two pins (step and dir) but the Hostmot2 stepgen can drive up to 8 output
pins for specialised applications (depending on firmware). This parameter
applies to all stepgen instances. Unused, masked pins will be available as GPIO.
.TP
\fBsserial_port_N (N = 0 .. 3)\fR [optional, default: 00000000 for all ports]
Up to 32 Smart Serial devices can be connected to a Mesa Anything IO board
depending on the firmware used and the number of physical connections on the
board. These are arranged in 1-4 ports of 1 to 8 channels.
 Some Smart Serial (SSLBP) cards offer more than one load-time configuration,
for example all inputs, or all outputs, or offering additional analogue input on
some digital pins.
 To set the modes for port 0 use, for example \fBsserial_port_0=0120xxxx\fR
 A '0'in the string sets the corresponding port to mode 0, 1 to mode 1, and so
on up to mode 9. An "x" in any position disables that channel and makes the
corresponding FPGA pins available as GPIO. 
 The string can be up to 8 characters long, and if it defines more
modes than there are channels on the port then the extras are ignored. Channel
numbering is left to right so the example above would set sserial device 0.0
to mode 0, 0.2 to mode2 and disable channels 0.4 onwards. 
 The sserial driver will auto-detect connected devices, no further configuration
should be needed. Unconnected channels will default to GPIO, but the pin values
will vary semi-randomly during boot when card-detection runs, to it is best to 
actively disable any channel that is to be used for GPIO. 
.TP
\fBnum_bspis\fR [optional, default: \-1]
Only enable the first N Buffered SPI drivers. If N is \-1 then all the drivers 
are enabled. Each BSPI driver can address 16 devices.
.TP
\fBnum_leds\fR [optional, default: \-1]
Only enable the first N of the LEDs on the FPGA board. If N is \-1, then HAL
pins for all the LEDs will be created. If N=0 then no pins will be added.
.TP
\fBnum_ssrs\fR [optional, default: -1]
Only enable the first N of the SSR modules on the FPGA board. If N is
\-1, then HAL pins for all the SSR outputs will be created. If N=0 then
no pins will be added.
.TP
\fBenable_raw\fR [optional]
If specified, this turns on a raw access mode, whereby a user can peek and
poke the firmware from HAL.  See Raw Mode below.

.SH dpll
The hm2dpll module has pins like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll\fR"
It is likely that the pin-count will decrease in the future and that some pins
will become parameters. 
This module is a phase-locked loop that will synchronise itself with the thread
in which the hostmot2 "read" function is installed and will trigger other
functions that are allocated to it at a specified time before or after the 
"read" function runs. This can be applied to the three absolute
encoder types, quadrature encoders and stepgen. In the case of the absolute
encoders this allows the system to trigger a data transmission just prior to
the time when the HAL driver reads the data. In the case of stepgens and
quadrature encoders the timers can be used to reduce position sampling
jitter. This is especially valuable with the ethernet-interfaced cards.

Pins:
.TP
(float, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.NN.timer\-us
This pin sets the triggering offset of the associated timer. There are 4 timers
numbered 01 to 04, represented by the NN digits in the pin name.  The units are
micro-seconds.  Generally the value will be negative, so that some action is
undertaken by the fpga prior to the execution of the main hostmot2 read.

For stepgen and quadrature encoders, the value needs to be more than the
maximum variation between read times.  \-100 will suffice for most systems, and
\-50 will work on systems with good performance and latency.

For serial encoders, the value also needs to include the time it takes to
transfer the absolute encoder position.  For instance, if 50 bits must be read
at 500kHz then subtract an additional 50/500kHz = 100uS to get a starting value
of \-200.

.TP
(float, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.base\-freq\-khz
This pin sets the base frequency of the phase-locked loop. by default it will 
be set to the nominal frequency of the thread in which the PLL is running and
wil not normally need to be changed. 
.TP
(float, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.phase\-error\-us
Indicates the phase eror of the DPLL. If the number cycles by a large amount 
it is likely that the PLL has failed to achieve lock and adjustments will need
to be made. 
.TP
(u32, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.time\-const
The filter time-constant for the PLL.  The default value is a compromise
between insensitivity to single-cycle variations and being resilient to changes
to the Linux CLOCK_MONOTONIC timescale, which can instantly change by up to
±500ppm from its nominal value, usually by timekeeping software like ntpd and
ntpdate. Default 2000 (0x7d0)
.TP
(u32, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.plimit
Sets the phase adjustment limit of the PLL. If the value is zero then the PLL
will free-run at the base frequency independent of the servo thread rate. This
is probably not what you want. Default 4194304 (0x400000) Units not known...
.TP
(u32, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.ddsize
Used internally by the driver, likely to disappear. 
.TP
(u32, in)  hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.prescale
Prescale factor for the rate generator. Default 1. 


.SH encoder

Encoders have names like 
""hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.encoder.\fI<Instance>\fR".".
"Instance" is a two-digit number that corresponds to the HostMot2 encoder
instance number.  There are "num_encoders" instances, starting with 00.

So, for example, the HAL pin that has the current position of the second
encoder of the first 5i20 board is: hm2_5i20.0.encoder.01.position (this
assumes that the firmware in that board is configured so that this HAL
object is available)

Each encoder uses three or four input IO pins, depending on how the
firmware was compiled.  Three-pin encoders use A, B, and Index (sometimes
also known as Z).  Four-pin encoders use A, B, Index, and Index-mask.

The hm2 encoder representation is similar to the one described by the
Canonical Device Interface (in the HAL General Reference document),
and to the software encoder component.  Each encoder instance has the
following pins and parameters:

Pins:

.TP
(s32 out) count
Number of encoder counts since the previous reset.

.TP
(float out) position
Encoder position in position units (count / scale).

.TP
(float out) velocity
Estimated encoder velocity in position units
per second.

.TP
(float out) velocity-rpm
Estimated encoder velocity in position units
per minute.

.TP
(bit in) reset
When this pin is TRUE, the count and position pins are
set to 0.  (The value of the velocity pin is not affected by this.)
The driver does not reset this pin to FALSE after resetting the count
to 0, that is the user's job.

.TP
(bit in/out) index\-enable
When this pin is set to True, the count
(and therefore also position) are reset to zero on the next Index
(Phase\-Z) pulse.  At the same time, index\-enable is reset to zero to
indicate that the pulse has occurred.

.TP
(s32 out) rawcounts
Total number of encoder counts since the start,
not adjusted for index or reset.

Parameters:

.TP
(float r/w) scale
Converts from 'count' units to 'position' units.

.TP
(bit r/w) index\-invert
If set to True, the rising edge of the Index
input pin triggers the Index event (if index\-enable is True).  If set
to False, the falling edge triggers.

.TP
(bit r/w) index\-mask
If set to True, the Index input pin only has an
effect if the Index\-Mask input pin is True (or False, depending on the
index\-mask\-invert pin below).

.TP
(bit r/w) index\-mask\-invert
If set to True, Index\-Mask must be False
for Index to have an effect.  If set to False, the Index\-Mask pin must
be True.

.TP
(bit r/w) counter\-mode
Set to False (the default) for Quadrature.
Set to True for Step/Dir (in which case Step is on the A pin and Dir is
on the B pin).

.TP
(bit r/w) filter
If set to True (the default), the quadrature counter
needs 15 clocks to register a change on any of the three input lines
(any pulse shorter than this is rejected as noise).  If set to False, the
quadrature counter needs only 3 clocks to register a change.  The encoder
sample clock runs at 33 MHz on the PCI AnyIO cards and 50 MHz on the 7i43.

.TP
(float r/w) vel\-timeout
When the encoder is moving slower than one
pulse for each time that the driver reads the count from the FPGA (in
the hm2_read() function), the velocity is harder to estimate.  The driver
can wait several iterations for the next pulse to arrive, all the while
reporting the upper bound of the encoder velocity, which can be accurately
guessed.  This parameter specifies how long to wait for the next pulse,
before reporting the encoder stopped.  This parameter is in seconds.

.TP
(s32 r/w) hm2_XiXX.N.encoder.timer\-number (default: \-1)
Sets the hm2dpll timer instance to be used to latch encoder counts.  A setting
of \-1 does not latch encoder counts.  A setting of 0 latches at the same time
as the main hostmot2 write.  A setting of 1..4 uses a time offset from the main
hostmot2 write according to the dpll's timer\-us setting.

Typically, timer\-us should be a negative number with a magnitude larger than
the largest latency (e.g., \-100 for a system with mediocre latency, \-50 for a
system with good latency).

If no DPLL module is present in the FPGA firmware, or if the encoder module
does not support DPLL, then this pin is not created.

When available, this feature should typically be enabled.  Doing so generally
reduces following errors.

.SH Synchronous Serial Interface (SSI)
(Not to be confused with the Smart Serial Interface)

One pin is created for each SSI instance regardless of data format:
(bit, in) hm2_XiXX.NN.ssi.MM.data\-incomplete
This pin will be set "true" if the module was still transferring data when the 
value was read. When this problem exists there will also be a limited number of 
error messages printed to the UI. This pin should be used to monitor whether 
the problem has been addressed by config changes. 
Solutions to the problem dpend on whether the encoder read is being triggered by
the hm2dpll phase-locked-loop timer (described above) or by the trigger\-encoders
function (described below).

The names of the pins created by the SSI module will depend entirely on the 
format string for each channel specified in the loadrt command line. 
A typical format string might be
 \fBssi_chan_0=error%1bposition%24g\fR
 
This would interpret the LSB of the bit-stream as a bit-type pin named "error"
and the next 24 bits as a Gray-coded encoder counter. The encoder-related HAL 
pins would all begin with "position".

There should be no spaces in the format string, as this is used as a delimiter
by the low-level code. 

The format consists of a string of alphanumeric characters that will form the 
HAL pin names, followed by a % symbol, a bit-count and a data type. All bits
in the packet must be defined, even if they are not used. There is a limit of 
64 bits in total.

The valid format characters and the pins they create are:
.TP
p: (Pad). Does not create any pins, used to ignore sections of the bit stream that are not required. 
.TP
b: (Boolean). 
  (bit, out) hm2_XiXX.N.ssi.MM.<name>. If any bits in the designated field width 
are non-zero then the HAL pin will be "true".
  (bit, out) hm2_XiXX.N.ssi.MM.<name>\-not. An inverted version of the above, the 
HAL pin will be "true" if all bits in the field are zero. 
.TP
u: (Unsigned)
  (float, out) hm2_XiXX.N.ssi.MM.<name>. The value of the bits interpeted as an
unsigned integer then scaled such that the pin value will equal the scalemax 
parameter value when all bits are high. (for example if the field is 8 bits 
wide and the scalmax parameter was 20 then a value of 255 would return 20, and
0 would return 0. 
.TP
s: (Signed)
  (float, out) hm2_XiXX.N.ssi.MM.<name>. The value of the bits interpreted as a
2s complement signed number then scaled similarly to the unsigned variant,
except symmetrical around zero. 
.TP
f: (bitField)
  (bit, out) hm2_XiXX.N.ssi.MM.<name>\-NN. The value of each individual bit in the
data field. NN starts at 00 up to the number of bits in the field. 
  (bit, out) hm2_XiXX.N.ssi.MM.<name>\-NN\-not. An inverted version of the individual
bit values. 
.TP
e: (Encoder)
 (s32, out) hm2_XiXX.N.ssi.MM.<name>.count. The lower 32 bits of the 
total encoder counts. This value is reset both by the ...reset and the ...index\-enable
pins.
 (s32, out) hm2_XiXX.N.ssi.MM.<name>.rawcounts. The lower 32 bits of 
the total encoder counts. The pin is not affected by reset and index. 
 (float, out) hm2_XiXX.N.ssi.MM.<name>.position. The encoder position
in machine units. This is calculated from the full 64-bit buffers so will show
a true value even after the counts pins have wrapped. It is zeroed by reset and
index enable. 
 (bit, IO) hm2_XiXX.N.ssi.MM.<name>.index\-enable. When this pin is set
"true" the module will wait until the raw encoder counts next passes through an 
integer multiple of the number of counts specified by counts\-per\-rev parameter
and then it will zero the counts and position pins, and set the index\-enable
pin back to "false" as a signal to the system that "index" has been passed. 
this pin is used for spindle-synchronised motion and index-homing. 
 (bit, in) (bit, out) hm2_XiXX.N.ssi.MM.<name>.reset. When this pin is set high 
the counts and position pins are zeroed. 
.TP
h: (Split encoder, high-order bits)
Some encoders (Including Fanuc) place the encoder part-turn counts and full-turn
counts in separate, non-contiguous fields. This tag defines the high-order bits
of such an encoder module. There can be only one h and one l tag per channel, 
the behaviour with multiple such channels will be undefined. 
.TP
l: (Split encoder, low-order bits)
Low order bits (see "h")
.TP
g: (Gray-code). This is a modifier that indicates that the following
format string is gray-code encoded. This is only valid for encoders (e, h l) and 
unsigned (u) data types.
.TP
m: (Multi-turn). This is a modifier that indicates that the following
format string is a multi-turn encoder. This is only valid for encoders (e, h l).
A jump in encoder position of more than half the full scale is interpreted as a
full turn and the counts are wrapped. With a multi-turn encoder this is only
likely to be a data glitch and will lead to a permanent offset. This flag
endures that such encoders will never wrap.

.TP
Parameters:
Two parameters is universally created for all SSI instances

.TP
(float r/w) hm2_XiXX.N.ssi.MM.frequency\-khz
This parameter sets the SSI clock frequency. The units are kHz, so 500 will give
a clock frequency of 500,000 Hz. 

.TP 
(s32 r/w) hm2_XiXX.N.ssi.timer-number\-num
This parameter allocates the SSI module to a specific hm2dpll timer instance.
This pin is only of use in firmwares which contain a hm2dpll function and will
default to 1 in cases where there is such a function, and 0 if there is not. 
The pin can be used to disable reads of the encoder, by setting to a
nonexistent timer number, or to 0. 

Other parameters depend on the data types specified in the config string.
.TP
p: (Pad) No Parameters.
.TP
b: (Boolean) No Parameters.
.TP
u: (Unsigned) 
(float, r/w) hm2_XiXX.N.ssi.MM.<name>.scalemax. The scaling factor for the
 channel.
.TP
s: (Signed)
(float, r/w) hm2_XiXX.N.ssi.MM.<name>.scalemax. The scaling factor for the
channel.
.TP
f: (bitField): No parameters.
.TP
e: (Encoder): 
 (float, r/w) hm2_XiXX.N.ssi.MM.<name>.scale: (float, r.w) The encoder scale in
counts per machine unit.
 (u32, r/w) hm2_XiXX.N.ssi.MM.<name>.counts\-per\-rev (u32, r/w) Used to emulate
the index behaviour of an incemental+index encoder. This would normally be set
to the actual counts per rev of the encoder, but can be any whole number of
revs. Integer divisors or multimpilers of the true PPR might be useful for 
index-homing. Non-integer factors might be appropriate where there is a 
synchronous drive ratio between the encoder and the spindle or ballscrew. 


.SH BiSS
BiSS is a bidirectional variant of SSI. Currently only a single direction is
supported by LinuxCNC (encoder to PC). 

One pin is created for each BiSS instance regardless of data format:

(bit, in) hm2_XiXX.NN.biss.MM.data\-incomplete
This pin will be set "true" if the module was still transferring data when the 
value was read. When this problem exists there will also be a limited number of 
error messages printed to the UI. This pin should be used to monitor whether 
the problem has been addressed by config changes. 
Solutions to the problem dpend on whether the encoder read is being triggered by
the hm2dpll phase-locked-loop timer (described above) or by the trigger\-encoders
function (described below)
 
The names of the pins created by the BiSS module will depend entirely on the 
format string for each channel specified in the loadrt command line and follow
closely the format defined above for SSI. 
Currently data packets of up to 96 bits are supported by the LinuxCNC driver, 
although the Mesa Hostmot2 module can handle 512 bit packets. It should be
possible to extend the number of packets supported by the driver if there is a
requirement to do so. 

.SH Fanuc encoder. 
The pins and format specifier for this module are identical to the SSI module
described above, except that at least one pre-configured format is provided. 
A modparam of fanuc_chan_N=AA64 (case sensitive) will configure the channel for
a Fanuc Aa64 encoder. The pins created are:
 hm2_XiXX.N.fanuc.MM.batt                indicates battery state
 hm2_XiXX.N.fanuc.MM.batt\-not            inverted version of above
 hm2_XiXX.N.fanuc.MM.comm                The 0-1023 absolute output for motor commutation
 hm2_XXiX.N.fanuc.MM.crc                 The CRC checksum. Currently HAL has no way to use this
 hm2_XiXX.N.fanuc.MM.encoder.count       Encoder counts
 hm2_XiXX.N.fanuc.MM.encoder.index\-enable Simulated index. Set by counts\-per\-rev parameter
 hm2_XiXX.N.fanuc.MM.encoder.position    Counts scaled by the ...scale parameter
 hm2_XiXX.N.fanuc.MM.encoder.rawcounts   Raw counts, unaffected by reset or index
 hm2_XiXX.N.fanuc.MM.encoder.reset       If high/true then counts and position = 0
 hm2_XiXX.N.fanuc.MM.valid               Indicates that the absolute position is valid
 hm2_XiXX.N.fanuc.MM.valid\-not           Inverted version

.SH resolver
Resolvers have names like 
hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.resolver.\fI<Instance>\fR.
<Instance is a 2-digit number, which for the 7i49 board will be between 00 and
05. This function only works with the Mesa Resolver interface boards (of which
the 7i49 is the only example at the time of writing). This board uses an SPI
interface to the FPGA card, and will only work with the correct firmware.
The pins allocated will be listed in the dmesg output, but are unlikely to be
usefully probed with HAL tools.

Pins:

.TP
(float, out) angle
This pin indicates the angular position of the resolver. It
is a number between 0 and 1 for each electrical rotation.

.TP
(float, out) position
Calculated from the number of complete and partial
revolutions since startup, reset, or  index\-reset multiplied by the scale
parameter. 

.TP
(float, out) velocity
Calculated from the rotational velocity and the 
velocity\-scale parameter. The default scale is electrical rotations per second. 

.TP
(float, out) velocity-rpm
Simply velocity scaled by a factor of 60 for convenience. 


.TP
(s32, out) count
This pins outputs a simulated encoder count at 2^24
counts per rev (16777216 counts).

.TP
(s32, out) rawcounts
This is identical to the counts pin, except it is not
reset by the 'index' or 'reset' pins. This is the pin which would be linked to
the bldc HAL component if the resolver was being used to commutate a motor.

.TP
(bit, in) reset
Resets the position and counts pins to zero immediately.

.TP
(bit, in)  joint-pos-fb
The Mesa resolver driver has the capability of emulating an absolute
encoder using a position file (see the INI-config section of the manual)
and the single-turn absolute operation of resolvers.
At startup, and only if the \fBuse-position-file\fR parameter is set to "true"
the resolver driver will wait for a value to be written by the system to
the axis.N.joint-pos-fb pin (which must be netted to this resolver pin)
and will calculate the number of full turns that best matches the
current reolver position. It will then pre-load the driver output with this
offset. This should only be used on systems where axis movement in the
unpowered state is unlikely. This feature will only work properly if the
machine is initially homed to "index" and if the axis home positions are
exactly zero.

.TP
(bit, in/out) index\-enable
When this pin is set high the position and counts
pins will be reset the next time the resolver passes through the zero position.
At the same time the pin is driven low to indicate to connected modules that the
index has been seen, and that the counters have been reset.  

.TP
(bit, out) error
Indicates an error in the particular channel. If this value is
"true" then the reported position and velocity are invalid. 

Parameters:
.TP
(float, read/write) scale
The position scale, in machine units per resolver
electrical revolution. 

.TP
(float, read/write) velocity\-scale
The conversion factor between resolver
rotation speed and machine velocity. A value of 1 will typically give motor
speed in rps, a value of 0.01666667 will give (approximate) RPM. 

.TP
(u32, read/write) index\-divisor (default 1)
The resolver component emulates an index at a fixed point in the sin/cos cycle.
Some resolvers have multiple cycles per rev (often related to the number of
pole-pairs on the attached motor). LinuxCNC requires an index once per
revolution for proper threading etc.
This parameter should be set to the number of cycles per rev of the resolver.
CAUTION: Which pseudo-index is used will not necessarily be consistent between
LinuxCNC runs. Do not expect to re-start a thread after restarting LinuxCNC.
It is not appropriate to use this parameter for index-homing of axis drives.

.TP
(float, read/write) excitation\-khz
This pin sets the excitation frequency for
the resolver. This pin is module-level rather than instance-level as all
resolvers share the same excitation frequency.
 Valid values are 10 (~10kHz), 5 (~5kHz) and 2.5 (~2.5kHz). The
actual frequency depends on the FPGA frequency, and they correspond to 
CLOCK_LOW/5000, CLOCK_LOW/10000 and CLOCK_LOW/20000 respectively. 
The parameter will be set to the closest available of the three frequencies.
 A value of \-1 (the default) indicates that the current setting should be
retained. 

.TP
(bit, read/write) use-position-file
In conjunction with \fBjoint-pos-fb\fR (qv) emulate absolute encoders.



.SH pwmgen

pwmgens have names like
"hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.pwmgen.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 pwmgen
instance number.  There are 'num_pwmgens' instances, starting with 00.

So, for example, the HAL pin that enables output from the fourth pwmgen
of the first 7i43 board is: hm2_7i43.0.pwmgen.03.enable (this assumes
that the firmware in that board is configured so that this HAL object
is available)

In HM2, each pwmgen uses three output IO pins: Not\-Enable, Out0, and
Out1.

The function of the Out0 and Out1 IO pins varies with output\-type
parameter (see below).

The hm2 pwmgen representation is similar to the software pwmgen component.
Each pwmgen instance has the following pins and parameters:

Pins:

.TP
(bit input) enable
If true, the pwmgen will set its Not\-Enable pin
false and output its pulses.  If 'enable' is false, pwmgen will set its
Not\-Enable pin true and not output any signals.

.TP
(float input) value
The current pwmgen command value, in arbitrary units.

Parameters:

.TP
(float rw) scale
Scaling factor to convert 'value' from arbitrary units
to duty cycle: dc = value / scale.  Duty cycle has an effective range
of \-1.0 to +1.0 inclusive, anything outside that range gets clipped.
The default scale is 1.0.

.TP
(s32 rw) output\-type
This emulates the output_type load-time argument to
the software pwmgen component.  This parameter may be changed at runtime,
but most of the time you probably want to set it at startup and then leave
it alone.  Accepted values are 1 (PWM on Out0 and Direction on Out1), 2
(Up on Out0 and Down on Out1), 3 (PDM mode, PDM on Out0 and Dir on Out1),
and 4 (Direction on Out0 and PWM on Out1, "for locked antiphase").

In addition to the per-instance HAL Parameters listed above, there are
a couple of HAL Parameters that affect all the pwmgen instances:

.TP
(u32 rw) pwm_frequency
This specifies the PWM frequency, in Hz, of all
the pwmgen instances running in the PWM modes (modes 1 and 2).  This is
the frequency of the variable-duty-cycle wave.  Its effective range is
from 1 Hz up to 193 kHz.  Note that the max frequency is determined by the
ClockHigh frequency of the Anything IO board; the 5i20 and 7i43 both have
a 100 MHz clock, resulting in a 193 kHz max PWM frequency.  Other boards
may have different clocks, resulting in different max PWM frequencies.
If the user attempts to set the frequency too high, it will be clipped
to the max supported frequency of the board.  Frequencies below about
5 Hz are not terribly accurate, but above 5 Hz they're pretty close.
The default pwm_frequency is 20,000 Hz (20 kHz).

.TP
(u32 rw) pdm_frequency
This specifies the PDM frequency, in Hz, of
all the pwmgen instances running in PDM mode (mode 3).  This is the
"pulse slot frequency"; the frequency at which the pdm generator in the
AnyIO board chooses whether to emit a pulse or a space.  Each pulse (and
space) in the PDM pulse train has a duration of 1/pdm_frequency seconds.
For example, setting the pdm_frequency to 2e6 (2 MHz) and the duty cycle
to 50% results in a 1 MHz square wave, identical to a 1 MHz PWM signal
with 50% duty cycle.  The effective range of this parameter is from
about 1525 Hz up to just under 100 MHz.  Note that the max frequency
is determined by the ClockHigh frequency of the Anything IO board; the
5i20 and 7i43 both have a 100 MHz clock, resulting in a 100 Mhz max
PDM frequency.  Other boards may have different clocks, resulting in
different max PDM frequencies.  If the user attempts to set the frequency
too high, it will be clipped to the max supported frequency of the board.
The default pdm_frequency is 20,000 Hz (20 kHz).

.SH 3ppwmgen
Three-Phase PWM generators (3pwmgens) are intended for controlling the high-side
and low-side gates in a 3-phase motor driver. The function is included to
support the Mesa motor controller daughter-cards but can be used to control
an IGBT or similar driver directly.
3pwmgens have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.3pwmgen.\fI<Instance>\fR"
where <Instance> is a 2-digit number. There will be num_3pwmgens instances,
starting at 00.
Each instance allocates 7 output and one input pins on the Mesa card connectors.
Outputs are: PWM A, PWM B, PWM C, /PWM A, /PWM B, /PWM C, Enable. The first three
pins are the high side drivers, the second three are their complementary low-side
drivers. The enable bit is intended to control the servo amplifier.
The input bit is a fault bit, typically wired to over-current detection. When set
the PWM generator is disabled.
The three phase duty-cycles are individually controllable from \-Scale to +Scale.
Note that 0 corresponds to a 50% duty cycle and this is the inialization value.

Pins:

(float input) A\-value, B\-value, C\-value: The PWM command value for each phase,
limited to +/\- "scale". Defaults to zero which is 50% duty cycle on high-side and
low-sidepins (but see the "deadtime" parameter)

.TP
(bit input) enable
When high the PWM is enabled as long as the fault bit is not
set by the external fault input pin. When low the PWM is disabled, with both high-
side and low-side drivers low. This is not the same as 0 output (50% duty cycle on
both sets of pins) or negative full scale (where the low side drivers are "on"
100% of the time)

.TP
(bit output) fault
Indicates the status of the fault bit. This output latches high
once set by the physical fault pin until the "enable" pin is set to high.

Parameters:

.TP
(u32 rw) deadtime
Sets the dead-time between the high-side driver turning off and
the low-side driver turning on and vice-versa. Deadtime is subtracted from on time
and added to off time symmetrically. For example with 20 kHz PWM (50 uSec period),
50% duty cycle and zero dead time, the PWM and NPWM outputs would be square
waves (NPWM being inverted from PWM) with high times of 25 uS. With the same
settings but 1 uS of deadtime, the PWM and NPWM outputs would both have high
times of 23 uS (25 \- (2X 1 uS), 1 uS per edge).
The value is specified in nS and defaults to a rather conservative 5000nS. Setting
this parameter to too low a value could be both expensive and dangerous as if both
gates are open at the same time there is effectively a short circuit accross the
supply.

.TP
(float rw) scale
Sets the half-scale of the specified 3-phase PWM generator.
PWM values from \-scale to +scale are valid. Default is +/\- 1.0

.TP
(bit rw) fault\-invert
Sets the polarity of the fault input pin. A value of 1 means
that a fault is triggered with the pin high, and 0 means that a fault it triggered
when the pin is pulled low. Default 0, fault = low so that the PWM works with the
fault pin unconnected.

.TP
(u32 rw) sample\-time
Sets the time during the cycle when an ADC pulse
is generated.  0 = start of PWM cycle and 1 = end. Not currently useful
to LinuxCNC. Default 0.5.

In addition the per-instance parameters above there is the following parameter
that affects all instances

.TP
(u32 rw) frequency
Sets the master PWM frequency. Maximum is approx 48kHz, minimum
is 1kHz. Defaults to 20kHz.


.SH stepgen

stepgens have names like
"hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.stepgen.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 stepgen
instance number.  There are 'num_stepgens' instances, starting with 00.

So, for example, the HAL pin that has the current position
feedback from the first stepgen of the second 5i22 board is:
hm2_5i22.1.stepgen.00.position\-fb (this assumes that the firmware in
that board is configured so that this HAL object is available)

Each stepgen uses between 2 and 6 IO pins.  The signals on these pins depends on
the step_type parameter (described below).

The stepgen representation is modeled on the stepgen software component.
Each stepgen instance has the following pins and parameters:

Pins:

.TP
(float input) position\-cmd
Target position of stepper motion, in
arbitrary position units.  This pin is only used when the stepgen is in
position control mode (control\-type=0).

.TP
(float input) velocity\-cmd
Target velocity of stepper motion, in
arbitrary position units per second.  This pin is only used when the
stepgen is in velocity control mode (control\-type=1).

.TP
(s32 output) counts
Feedback position in counts (number of steps).

.TP
(float output) position\-fb
Feedback position in arbitrary position
units.  This is similar to "counts/position_scale", but has finer than
step resolution.

.TP
(float output) velocity\-fb
Feedback velocity in arbitrary position
units per second.

.TP
(bit input) enable
This pin enables the step generator instance.
When True, the stepgen instance works as expected.  When False, no steps
are generated and velocity\-fb goes immediately to 0.  If the stepgen is
moving when enable goes false it stops immediately, without obeying the
maxaccel limit.

.TP
(bit input) control\-type
Switches between position control mode (0)
and velocity control mode (1).  Defaults to position control (0).

Parameters:

.TP
(float r/w) position\-scale
Converts from counts to position units.
position = counts / position_scale

.TP
(float r/w) maxvel
Maximum speed, in position units per second.  If set
to 0, the driver will always use the maximum possible velocity based
on the current step timings and position\-scale.  The max velocity will
change if the step timings or position\-scale changes.  Defaults to 0.

.TP
(float r/w) maxaccel
Maximum acceleration, in position units per second
per second.  Defaults to 1.0.  If set to 0, the driver will not limit its
acceleration at all - this requires that the position\-cmd or velocity\-cmd
pin is driven in a way that does not exceed the machine's capabilities.
This is probably what you want if you're going to be using the LinuxCNC
trajectory planner to jog or run G-code.

.TP
(u32 r/w) steplen
Duration of the step signal, in nanoseconds.

.TP
(u32 r/w) stepspace
Minimum interval between step signals, in
nanoseconds.

.TP
(u32 r/w) dirsetup
Minimum duration of stable Direction signal before
a step begins, in nanoseconds.

.TP
(u32 r/w) dirhold
Minimum duration of stable Direction signal after a
step ends, in nanoseconds.

.TP
(u32 r/w) step_type
Output format, like the step_type modparam to the
software stegen(9) component.  0 = Step/Dir, 1 = Up/Down, 2 = Quadrature, 3+ =
table-lookup mode. In this mode the step_type parameter determines how long the
step sequence is. Additionally the stepgen_width parameter in the loadrt
config string must be set to suit the number of pins per stepgen required. Any
stepgen pins above this number will be available for GPIO. This mask defaults
to 2.
The maximum length is 16.
Note that Table mode is not enabled in all firmwares but if you see GPIO
pins between the stepgen instances in the dmesg/log hardware pin list then
the option may be available.

In Quadrature mode (step_type=2), the stepgen outputs one complete Gray
cycle (00 → 01 → 11 → 10 → 00) for each "step" it takes. In table mode
up to 6 IO pins are individually controlled in an arbitrary sequence up to 16
phases long. 

.TP
(u32 r/w) table\-data\-N
There are 4 table\-data\-N parameters, table\-data\-0 to table\-data\-3. These each 
contain 4 bytes corresponding to 4 stages in the step sequence. For example 
table\-data\-0 = 0x00000001 would set stepgen pin 0 (always called "Step" in 
the dmesg output) on the first phase of the step sequence, and table\-data\-4 =
0x20000000 would set stepgen pin 6 ("Table5Pin" in the dmesg output) on the 16th
stage of the step sequence. 

.TP
(s32 r/w) hm2_XiXX.N.stepgen.timer\-number (default: \-1)
Sets the hm2dpll timer instance to be used to latch stepgen counts.  A setting
of \-1 does not latch encoder counts.  A setting of 0 latches at the same time
as the main hostmot2 write.  A setting of 1..4 uses a time offset from the main
hostmot2 write according to the dpll's timer\-us setting.

Typically, timer\-us should be a negative number with a magnitude larger than
the largest latency (e.g., \-100 for a system with mediocre latency, \-50 for a
system with good latency).

If no DPLL module is present in the FPGA firmware, or if the stepgen module
does not support DPLL, then this pin is not created.

When available, this feature should typically be enabled.  Doing so generally
reduces following errors.

.SH Smart Serial Interface

The Smart Serial Interface allows up to 32 different devices such as the Mesa
8i20 2.2kW 3-phase drive or 7i64 48-way IO cards to be connected to a single
FPGA card.
The driver auto-detects the connected hardware port, channel and device type.
Devices can be connected in any order to any active channel of an active port.
(see the config modparam definition above).

For full details of the smart-serial devices see \fBman sserial\fR.

.SH BSPI
The BSPI (Buffered SPI) driver is unusual in that it does not create any HAL
pins. Instead the driver exports a set of functions that can be used by a sub-driver
for the attached hardware. Typically these would be written in the "comp"

pre-processing language: see http://linuxcnc.org/docs/html/hal/comp.html or man
halcompile for further details. See man mesa_7i65 and the source of mesa_7i65.comp for
details of a typical sub-driver.
See man hm2_bspi_setup_chan, man hm2_bspi_write_chan, man hm2_tram_add_bspi_frame,
man hm2_allocate_bspi_tram, man hm2_bspi_set_read_funtion and
man hm2_bspi_set_write_function for the exported functions.

The names of the available channels are printed to standard output during the
driver loading process and take the form
hm2_<board name>.<board index>.bspi.<index> For example hm2_5i23.0.bspi.0

.SH UART
The UART driver also does not create any HAL pins, instead it declares two 
simple read/write functions and a setup function to be utilised by user-written
code.  Typically this would be written in the "comp"
pre-processing language: see http://linuxcnc.org/docs/html/hal/comp.html or man
halcompile for further details. See man mesa_uart and the source of mesa_uart.comp for
details of a typical sub-driver.
See man hm2_uart_setup_chan, man hm2_uart_send, man hm2_uart_read and man 
hm2_uart_setup.

The names of the available uart channels are printed to standard output during the
driver loading process and take the form
hm2_<board name>.<board index>uart.<index> For example hm2_5i23.0.uart.0
.SH General Purpose I/O

I/O pins on the board which are not used by a module instance are exported
to HAL as "full" GPIO pins.  Full GPIO pins can be configured at run-time
to be inputs, outputs, or open drains, and have a HAL interface that
exposes this flexibility.  IO pins that are owned by an active module
instance are constrained by the requirements of the owning module,
and have a restricted HAL interface.

GPIOs have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.gpio.\fI<IONum>\fR".
IONum is a three-digit number.  The mapping from IONum to connector and
pin-on-that-connector is written to the syslog when the driver loads,
and it's documented in Mesa's manual for the Anything I/O boards.

So, for example, the HAL pin that has the current inverted input value
read from GPIO 012 of the second 7i43 board is: hm2_7i43.1.gpio.012.in\-not
(this assumes that the firmware in that board is configured so that this
HAL object is available)

The HAL parameter that controls whether the last GPIO of the first 5i22
is an input or an output is: hm2_5i22.0.gpio.095.is_output (this assumes
that the firmware in that board is configured so that this HAL object
is available)

The hm2 GPIO representation is modeled after the Digital Inputs and
Digital Outputs described in the Canonical Device Interface (part of
the HAL General Reference document).  Each GPIO can have the following
HAL Pins:

.TP
(bit out) in & in_not
State (normal and inverted) of the hardware
input pin.  Both full GPIO pins and IO pins used as inputs by active
module instances have these pins.

.TP
(bit in) out
Value to be written (possibly inverted) to the hardware
output pin.  Only full GPIO pins have this pin.

.PP
Each GPIO can have the following Parameters:

.TP
(bit r/w) is_output
If set to 0, the GPIO is an input.  The IO pin
is put in a high-impedance state (weakly pulled high), to be driven by
other devices.  The logic value on the IO pin is available in the "in" and
"in_not" HAL pins.  Writes to the "out" HAL pin have no effect.  If this
parameter is set to 1, the GPIO is an output; its behavior then depends
on the "is_opendrain" parameter.  Only full GPIO pins have this parameter.

.TP
(bit r/w) is_opendrain
This parameter only has an effect if the
"is_output" parameter is true.  If this parameter is false, the GPIO
behaves as a normal output pin: the IO pin on the connector is driven
to the value specified by the "out" HAL pin (possibly inverted), and the
value of the "in" and "in_not" HAL pins is undefined.  If this parameter
is true, the GPIO behaves as an open-drain pin.  Writing 0 to the "out"
HAL pin drives the IO pin low, writing 1 to the "out" HAL pin puts the
IO pin in a high-impedance state.  In this high-impedance state the IO
pin floats (weakly pulled high), and other devices can drive the value;
the resulting value on the IO pin is available on the "in" and "in_not"
pins.  Only full GPIO pins and IO pins used as outputs by active module
instances have this parameter.

.TP
(bit r/w) invert_output
This parameter only has an effect if the
"is_output" parameter is true.  If this parameter is true, the output
value of the GPIO will be the inverse of the value on the "out" HAL pin.
Only full GPIO pins and IO pins used as outputs by active module instances
have this parameter.

.PP
When a physical I/O pin is used by a special function, the related
.BR is_output ", and " is_opendrain
HAL parameters are aliased to the special function.  For instance, if gpio 1
is taken over by pwmgen 0's first output, then aliases like
.B hm2_7i92.0.pwmgen.00.out0.invert_output
(referring to
.BR hm2_7i92.0.gpio.001.invert_output )
will be automatically created.  When more than one GPIO is connected to the
same special function, an extra .#. is inserted so that the settings for
each related GPIO can be set separately.  For example, for the firmware
SV12IM_2X7I48_72, the alias
.B hm2_5i20.0.pwmgen.00.0.enable.invert_output
(referring to 
.BR hm2_5i20.0.gpio.000.invert_output )
and
.B hm2_5i20.0.pwmgen.00.1.enable.invert_output
(referring to
.BR hm2_5i20.0.gpio.023.invert_output )
are both created.

.SH led

Creates HAL pins for the LEDs on the FPGA board.

Pins:

.TP
(bit in) CR<NN>
The pins are numbered from CR01 upwards with the name
corresponding to the PCB silkscreen. Setting the bit to "true" or 1 lights
the led.

.SH Solid State Relay

SSRs have names like
"hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.ssr.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 SSR
instance number.  There are 'num_ssrs' instances, starting
with 00.

Each instance has a rate control pin and between 1 and 32 output pins.

Pins:

.TP
(u32 in) rate
Set the internal frequency of the SSR instance, in Hz (approximate).
The valid range is 25 kHz to 25 MHz.  Values below the minimum will
use the minimum, and values above the max will use the max.  1 MHz is a
typical value, and appropriate for all Mesa cards, and is the default.
Set to 0 to disable this SSR instance.

.TP
(bit in) out-NN
The state of this SSR instance's NNth output.  Set to 0 to make
the output pins act like an open switch (no connection), set to 1 to
make them act like a closed switch.

.SH Watchdog

The HostMot2 firmware may include a watchdog Module; if it does, the
hostmot2 driver will use it.  The HAL representation of the watchdog is
named "hm2_\fB<BoardType>\fR.\fB<BoardNum>\fR.watchdog".

The watchdog starts out asleep and inactive.  Once you access the board
the first time by running the hm2 write() HAL function (see below), the
watchdog wakes up.  From them on it must be petted periodically or it will
bite.  Pet the watchdog by running the hm2 write() HAL function.

When the watchdog bites, all the board's I/O pins are disconnected from
their Module instances and become high-impedance inputs (pulled high),
and all communication with the board stops.  The state of the HostMot2
firwmare modules is not disturbed (except for the configuration of the
IO Pins).  Encoder instances keep counting quadrature pulses, and pwm-
and step-generators keep generating signals (which are *not* relayed to
the motors, because the IO Pins have become inputs).

Resetting the watchdog (by clearing the has_bit pin, see below) resumes
communication and resets the I/O pins to the configuration chosen at
load-time.

If the firmware includes a watchdog, the following HAL objects will
be exported:

Pins:

.TP
(bit in/out) has_bit
True if the watchdog has bit, False if the watchdog has
not bit.  If the watchdog has bit and the has_bit bit is True, the user
can reset it to False to resume operation.

Parameters:

.TP
(u32 read/write) timeout_ns
Watchdog timeout, in nanoseconds.  This is
initialized to 5,000,000 (5 milliseconds) at module load time.  If more
than this amount of time passes between calls to the hm2 write()
function, the watchdog will bite.
.SH Raw Mode

If the "enable_raw" config keyword is specified, some extra debugging
pins are made available in HAL.  The raw mode HAL pin names begin with
"hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.raw".

With Raw mode enabled, a user may peek and poke the firmware from HAL,
and may dump the internal state of the hostmot2 driver to the syslog.

Pins:

.TP
(u32 in) read_address
The bottom 16 bits of this is used as the address
to read from.

.TP
(u32 out) read_data
Each time the hm2_read() function is called, this
pin is updated with the value at .read_address.

.TP
(u32 in) write_address
The bottom 16 bits of this is used as the address
to write to.

.TP
(u32 in) write_data
This is the value to write to .write_address.

.TP
(bit in) write_strobe
Each time the hm2_write() function is called, this
pin is examined.  If it is True, then value in .write_data is written
to the address in .write_address, and .write_strobe is set back to False.

.TP
(bit in/out) dump_state
This pin is normally False.  If it gets set to
True the hostmot2 driver will write its representation of the board's
internal state to the syslog, and set the pin back to False.

.SH Setting up Smart Serial devices 

See man setsserial for the current way to set smart-serial eeprom parameters. 

.SH FUNCTIONS
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.read\-request\fR
On boards with long turn around time for reads (at the time of writing, this
applies only to ethernet boards), this function sends a read request.  When
multiple boards are used, this can reduce the servo thread execution time.  In
this case, the appropriate thread order would be
.EX
addf hm2_7i80.0.read\-request
addf hm2_7i80.1.read\-request
addf hm2_7i80.0.read
addf hm2_7i80.1.read
.EE
which causes the read request to be sent to board 1 before waiting for the
response to the read request to arrive from board 0.
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.read\fR
This reads the encoder counters, stepgen feedbacks, and GPIO input pins
from the FPGA.
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.write\fR
This updates the PWM duty cycles, stepgen rates, and GPIO outputs on
the FPGA.  Any changes to configuration pins such as stepgen timing,
GPIO inversions, etc, are also effected by this function.
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.read_gpio\fR
Read the GPIO input pins.  Note that the effect of this function is a
subset of the effect of the .read() function described above.  Normally
only .read() is used.  The only reason to call this function is if you
want to do GPIO things in a faster-than-servo thread.  (This function
is not available on the 7i43 due to limitations of the EPP bus.)
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.write_gpio\fR
Write the GPIO control registers and output pins.  Note that the effect of
this function is a subset of the effect of the .write() function described
above.  Normally only .write() is used.  The only reason to call this
function is if you want to do GPIO things in a faster-than-servo thread.
(This function is not available on the 7i43 due to limitations of the
EPP bus.)
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.trigger\-encoders\fR
This function will only appear if the firmware contains a BiSS, Fanuc or SSI 
encoder module and if the firmare does not contain a hm2dpll 
module (qv) or if the modparam contains num_dplls=0.
This function should be inserted first in the thread so that the encoder data is
ready when the main \fBhm2_XiXX.NN.read\fR function runs. An error message will
be printed if the encoder read is not finished in time. It may be possible to
avoid this by increasing the data rate. If the problem persists and if "stale"
data is acceptable then the function may be placed later in the thread, allowing
a full servo cycle for the data to be transferred from the devices. If available
it is better to use the synchronous hm2dpll triggering function. 

.SH SEE ALSO

hm2_7i43(9)
.br
hm2_pci(9)
.br
Mesa's documentation for the Anything I/O boards, at <http://www.mesanet.com>
.br
.SH LICENSE

GPL
.de TQ
.br
.ns
.TP \\$1
..

.TH KINS "9" "2014-12-22" "LinuxCNC Documentation" "Kinematics Modules"
.SH NAME
kins \- kinematics definitions for LinuxCNC
.SH SYNOPSIS
.B loadrt trivkins (use for most cartesian machines)
.PP
.B loadrt corexykins
.PP
.B loadrt genhexkins
.PP
.B loadrt genserkins
.PP
.B loadrt lineardeltakins (see separate manpage)
.PP
.B loadrt maxkins
.PP
.B loadrt pumakins
.PP
.B loadrt rosekins
.PP
.B loadrt rotarydeltakins
.PP
.B loadrt rotatekins
.PP
.B loadrt scarakins
.PP
.B loadrt tripodkins
.PP
.B loadrt xyzac\-trt\-kins
.PP
.B loadrt xyzbc\-trt\-kins
.PP
.B loadrt 5axiskins
.PP

.SH DESCRIPTION
Rather than exporting HAL pins and functions, these components provide the
forward and inverse kinematics definitions for LinuxCNC.

.SS trivkins \- generalized trivial kinematics
Joint numbers are assigned sequentialy according to the axis letters specified
with the \fBcoordinates=\fR parameter.

If the coordinates= parameter is omitted, joint numbers are assigned
\fBsequentially\fR to every known axis letter ("xyzabcuvw").

.TP
Example: loadrt \fBtrivkins\fR
.TP
Assigns all axis letters to joint numbers in sequence:
.PP
   x==joint0, y==joint1, z==joint2
   a==joint3, b==joint4, c==joint5
   u==joint6, v==joint7, w==joint8

.TQ
Example: loadrt \fBtrivkins coordinates=xyz\fR
.TQ
Assigns: x==joint0, y==joint1, z==joint2

.TQ
Example: loadrt \fBtrivkins coordinates=xz\fR
.TQ
Assigns: x==joint0, z==joint1

.TQ
Example: loadrt \fBtrivkins coordinates=xyzy\fR
.TQ
Assigns: x==joint0, y0==joint1, z==joint2, y1==joint3


.PP
The default kinematics type is \fBKINEMATICS_IDENTITY\fR.  Guis may provide
special features for configurations using this default kinematics type.  For
instance, the axis gui automatically handles joint and world mode operations so
that the distinctions between joints and axes are not visible to the operator.
This is feasible since there is an exact correspondence between a joint number
and its matching axis letter.

.TQ
The kinematics type can be set with the \fBkinstype=\fR parameter:

.TQ
  kinstype=\fB1\fR     for KINEMATICS_IDENTITY (default if kinstype= omitted)
.TQ
  kinstype=[\fBb\fR|\fBB\fR] for KINEMATICS_BOTH
.TQ
  kinstype=[\fBf\fR|\fBF\fR] for KINEMATICS_FORWARD_ONLY
.TQ
  kinstype=[\fBi\fR|\fBI\fR] for KINEMATICS_INVERSE_ONLY

.TP
Example: loadrt \fBtrivkins coordinates=xyz kinstype=b\fR

.PP
Use kinstype=\fBB\fR (KINEMATICS_BOTH) for configurations that need to move joints
independently (joint mode) or as coordinated (teleop) movements in world coordinates.

When using the axis gui with KINEMATICS_BOTH, the '\fB$\fR' key is
used to toggle between joint and teleop (world) modes.

.PP
An axis letter may be used more than once (\fBduplicated\fR) to assign
multiple joints to a single axis coordinate letter.

.TQ
Example: coordinates=\fBxyyzw\fR kinstype=\fBB\fR
.TQ
Assigns: x==joint0, y==joint1 \fBAND\fR joint2, z==joint3, w==joint4

.PP
The above example illustrates a gantry configuration that uses
\fBduplicated\fR coordinate letters to indicate that
two joints (joint1 and joint2) move a single axis (y).  Using
kinstype=\fBB\fR allows the configuration to be toggled between joint
and world modes of operation.  Homing configuration options are 
available to synchronize the final homing move for selected joints --
see the documentation for \fBHoming Configuration\fR.

\fBNOTES\fR for \fBduplicated\fR coordinates:

When \fBduplicated\fR coordinate letters are used, specifying
KINEMATICS_BOTH (kinstype=\fBB\fR) allows a gui to support
jogging of each individual joint in \fBjoint mode\fR.
\fBCaution\fR is required for machines where the movement
of a single joint (in a set specified by a \fBduplicated\fR coordinate letter)
can lead to gantry racking or other unwanted outcomes.
When the kinstype= parameter is omitted, operation defaults to
KINEMATICS_IDENTITY (kinstype=\fB1\fR) and a gui may allow jogging
based upon a selected axis coordinate letter
(or by a keyboard key) before homing is completed and the
machine is still in \fBjoint mode\fR.  The joint selected will depend upon
the gui implementation but typically only one of the multiple
joints in the set will jog.  Consequently, specifying KINEMATICS_BOTH
is recommended as it enables support for unambiguous, independent
jogging of each individual joint.  
Machines that implement homing for all joints (including the provisions
for synchronizing the final homing move for multiple joints) may be homed
at machine startup and automatically switch to \fBworld\fR mode where
per-coordinate jogging is available.

.SS corexykins \- CoreXY Kinematics
.TP
X = 0.5*(JOINT_0 + JOINT_1)
.TQ
Y = 0.5*(JOINT_0 \- JOINT_1)
.TQ
Z = JOINT_2
.TP
[KINS]JOINTS= must specify 3 or more joints (maximum 9)
.TP
If enabled by the number of [KINS]JOINTS= specified, JOINT_3,4,5,6,7,8 correspond to coordinates A,B,C,U,V,W respectively.


.SS genhexkins \- Hexapod Kinematics
Gives six degrees of freedom in position and orientation (XYZABC).  The
location of base and platform joints is defined by hal parameters.  The
forward kinematics iteration is controlled by hal pins.
.TP
.B genhexkins.base.\fIN\fB.x
.TQ
.B genhexkins.base.\fIN\fB.y
.TQ
.B genhexkins.base.\fIN\fB.z
.TQ
.B genhexkins.platform.\fIN\fB.x
.TQ
.B genhexkins.platform.\fIN\fB.y
.TQ
.B genhexkins.platform.\fIN\fB.z
Parameters describing the \fIN\fRth joint's coordinates.
.TQ
.B genhexkins.spindle\-offset
Added to all joints Z coordinates to change the machine origin.
Facilitates adjusting spindle position.
.TQ
.B genhexkins.base\-n.\fIN\fB.x
.TQ
.B genhexkins.base\-n.\fIN\fB.y
.TQ
.B genhexkins.base\-n.\fIN\fB.z
.TQ
.B genhexkins.platform\-n.\fIN\fB.x
.TQ
.B genhexkins.platform\-n.\fIN\fB.y
.TQ
.B genhexkins.platform\-n.\fIN\fB.z
Parameters describing unit vectors of \fIN\fRth joint's axis. Used to
calculate strut length correction for cardanic joints and non-captive
actuators.
.TQ
.B genhexkins.screw\-lead
Lead of strut actuator screw, positive for the right-handed thread.
Default is 0 (strut length correction disabled).
.TQ
.B genhexkins.correction.\fIN\fB
Current values of strut length correction for non-captive actuators with
cardanic joints.
.B genhexkins.convergence\-criterion
Minimum error value that ends iterations with converged solution.
.TQ
.B genhexkins.limit\-iterations
Limit of iterations, if exceeded iterations stop with no convergence.
.TQ
.B genhexkins.max\-error
Maximum error value, if exceeded iterations stop with no convergence.
.TQ
.B genhexkins.last\-iterations
Number of iterations spent for the last forward kinematics solution.
.TQ
.B genhexkins.max\-iterations
Maximum number of iterations spent for a converged solution during current
session.
.TQ
.B genhexkins.tool\-offset
TCP offset from platform origin along Z to implement RTCP function. To
avoid joints jump change tool offset only when the platform is not tilted.

.SS genserkins \- generalized serial kinematics
Kinematics that can model a general serial-link manipulator with up to 6
angular joints.

The kinematics use Denavit-Hartenberg definition for the joint and
links. The DH definitions are the ones used by John J Craig in
"Introduction to Robotics: Mechanics and Control" The parameters for the
manipulator are defined by hal pins.
Note that this uses a convention sometimes known as "Modified DH Paremeters"
and this must be borne in mind when setting up the system. 
https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters#Modified_DH_parameters
.TP
.B genserkins.A\-\fIN
.TQ
.B genserkins.ALPHA\-\fIN
.TQ
.B genserkins.D\-\fIN
Parameters describing the \fIN\fRth joint's geometry.

.SS maxkins \- 5-axis kinematics example
Kinematics for Chris Radek's tabletop 5 axis mill named 'max' with tilting
head (B axis) and horizintal rotary mounted to the table (C axis).  Provides
UVW motion in the rotated coordinate system.  The source file, maxkins.c,
may be a useful starting point for other 5-axis systems.


.SS pumakins \- kinematics for puma typed robots
Kinematics for a puma-style robot with 6 joints
.TP
.B pumakins.A2
.TQ
.B pumakins.A3
.TQ
.B pumakins.D3
.TQ
.B pumakins.D4
Describe the geometry of the robot

.SS rosekins \- kinematics for a rose engine using
a transverse, longitudinal, and rotary joint (3 joints)

.SS rotarydeltakins \- kinematics for a rotary delta machine
Rotary delta robot (3 Joints)

.SS rotatekins \- Rotated Kinematics
The X and Y axes are rotated 45 degrees compared to the joints 0 and 1.

.SS scarakins \- kinematics for SCARA-type robots
.TP
.B scarakins.D1
Vertical distance from the ground plane to the center of the inner arm.
.TP
.B scarakins.D2
Horizontal distance between joint[0] axis and joint[1] axis, ie.  the
length of the inner arm.
.TP
.B scarakins.D3
Vertical distance from the center of the inner arm to the center of the
outer arm.  May be positive or negative depending on the structure of
the robot.
.TP
.B scarakins.D4
Horizontal distance between joint[1] axis and joint[2] axis, ie.  the
length of the outer arm.
.TP
.B scarakins.D5
Vertical distance from the end effector to the tooltip.  Positive means
the tooltip is lower than the end effector, and is the normal case.
.TP
.B scarakins.D6
Horizontal distance from the centerline of the end effector (and the
joints 2 and 3 axis) and the tooltip.  Zero means the tooltip is on the
centerline.  Non-zero values should be positive, if negative they
introduce a 180 degree offset on the value of joint[3].

.SS tripodkins \- Tripod Kinematics
The joints represent the distance of the controlled point from three predefined
locations (the motors), giving three degrees of freedom in position (XYZ)
.TP
.B tripodkins.Bx
.TQ
.B tripodkins.Cx
.TQ
.B tripodkins.Cy
The location of the three motors is (0,0), (Bx,0), and (Cx,Cy)

.SS xyzac\-trt\-kins \- 5 Axis mill (Table Rotary/Tilting)
Tilting table (A) and horizontal rotary mounted tothe table (C)
(5 Joints)

.SS xyzbc\-trt\-kins \- 5 Axis mill (Table Rotary/Tilting)
Tilting table (B) and horizontal rotary mounted to table (C axis)
(5 Joints)

.SS 5axiskins \- 5 Axis bridge mill
XYZBC (5 Joints)

.SH SEE ALSO
\fIKinematics\fR section in the LinuxCNC documentation

.TH LCD "9" "2012-09-17" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
lcd \- Stream HAL data to an LCD screen
.SH SYNOPSIS
.HP
.B loadrt lcd fmt_strings=""Plain Text %4.4f\enAnd So on|Second Page, Next Inst""
.SH FUNCTIONS
.TP
\fBlcd\fR (requires a floating-point thread). All LCD instances are updated by the
same function. 

.SH PINS
'TP
.B lcd.\fINN\fB.out\fR (u32) out
The output byte stream is sent via this pin. One character is sent every thread
invocation. There in no handshaking provided.
.TP
.B lcd.\fINN\fB.page.\fIPP.\fBarg.\fINN\fR (float/s32/u32/bit) in
The input pins have types matched to the format string specifiers. 
.TP
.B lcd.\fINN\fB.page_num\fR (u32) in
Selects the page number. Multiple layouts may be defined, and this pin switches
between them.
.TP
.B lcd.\fINN\fB.contrast\fR (float) in
Attempts to set the contrast of the LCD screen using the byte sequence ESC C and
then a value from 0x20 to 0xBF. (matching the Mesa 7i73). The value should be
between 0 and 1. 

.SH PARAMETERS
.TP
.B lcd.\fINN\fB.decimal\-separator\fR (u32) rw
Sets the decimal separator used for floating point numbers. The default value is
46 (0x2E) which corresponds to ".". If a comma is required then set this
parameter to 44 (0x2C).
.SH DESCRIPTION

\fBlcd\fR takes format strings much like those used in C and many other languages
in the printf and scanf functions and their variants. 

The component was written specifically to support the Mesa 7i73 pendant
controller, however it may be of use streaming data to other character devices
and, as the output format mimics the ADM3 terminal format, it could be used
to stream data to a serial device. Perhaps even a genuine ADM3. 
The strings contain a mixture of text values (which are displayed directly), 
"escaped" formatting codes and numerical format descriptors. 
For a detailed description of formatting codes see: 
http://en.wikipedia.org/wiki/Printf

The component can be configured to display an unlimited number of 
differently-formatted pages, which may be selected with a HAL pin. 
.TP
 \fBEscaped codes\fR
 \en Inserts a clear-to-end, carriage return and line feed character. This will 
still linefeed and clear even if an automatic wrap has occurred (lcd has no 
knowledge of the width of the lcd display.) To print in the rightmost column it
is necessary to allow the format to wrap and omit the \en code.

 \et Inserts a tab (actually 4 spaces in the current version rather than a true
tab.)

 \eNN inserts the character defined by the hexadecimal code NN. 
 As the ',' character is used in the format string to separate LCD instances
 it must be represented by \e2C in the format string. (the decimal
 separator is handled differently)
 
 \e\e Inserts a literal \e.

.TP
 \fBNumerical formats\fR

\fBlcd\fR differs slightly from the standard printf conventions. One significant
difference is that width limits are strictly enforced to prevent the LCD display 
wrapping and spoiling the layout. The field width includes the sign character
so that negative numbers will often have a smaller valid range than positive. 
Numbers that do not fit in the specified width are displayed as a line of
asterisks (\fB********\fR).

Each format begins with a "%" symbol. (For a literal % use "%%").
Immediately after the % the following modifiers may be used:

" " (space) Pad the number to the specified width with spaces. This is the
default and is not strictly necessary. 

"0" Pad the number to the specified width with the numeral 0. 

"+" Force display of a + symbol before positive numbers. This (like the \- sign)
will appear immediately to the left of the digits for a space-padded number 
and in the extreme left position for a 0-padded number. 

"1234567890" A numerical entry (other than the leading 0 above)  defines the
total number of characters to display including the decimal separator and the
sign. Whilst this number can be as many digits as required the maximum field
width is 20 characters. The inherent precison of the "double" data type means
that more than 14 digits will tend to show errors in the least significant
digits. The integer data types will never fill more than 10 decimal digits. 

Following the width specifier should be the decimal specifier. This can only be
a full-stop character (.) as the comma (,) is used as the instance separator. 
Currently lcd does not access the locale information to determine the correct
separator but the \fBdecimal\-separator\fR HAL parameter can be used to
choose any desired separator.

Following the decimal separator should be a number that determines how many
places of decimals to display. This entry is ignored in the case of integer
formats. 

All the above modifiers are optional, but to specify a decimal precision the 
decimal point must precede the precision. For example %.3f. 
 The default decimal precision is 4.

The numerical formats supported are:

\fB%f %F\fR (for example, %+09.3f) These create a floating-point type HAL pin. The example
would be displayed in a 9-character field, with 3 places of decimals, . as a 
decimal separator, padded to the left with 0s and with a sign displayed for 
both positive and negative. Conversely a plain %f would be 6 digits of decimal,
variable format width, with a sign only shown for negative numbers. both %f and 
%F create exactly the same format. 

\fB%i %d\fR (For example %+ 4d) Creates a signed (s32) HAL pin. The example would 
display the value at a fixed 4 characters, space padded, width including the + 
giving a range of +999 to \-999. %i and %d create identical output. 

\fB%u\fR (for example %08u) Creates an unsigned (u32) HAL pin. The example would be a
fixed 8 characters wide, padded with zeros. 

\fB%x, %X\fR Creates an unsigned (u32) HAL pin and displays the value in Hexadecimal.
Both %x and %X display capital letters for digits ABCDEF. A width may be
specified, though the u32 HAL type is only 8 hex digits wide. 

\fB%o\fR Creates an unsigned (u32) pin and displays the value in Octal. 

\fB%c\fR Creates a u32 HAL pin and displays the character corresponding to the value
of the pin. Values less than 32 (space) are suppressed. A width specifier may
be used, for example %20c might be used to create a complete line of one 
character. 

\fB%b\fR This specifier has no equivalent in printf. It creates a bit (boolean) type
HAL pin. The b should be followed by two characters and the display will show
the first of these when the pin is true, and the second when false. Note that
the characters follow, not precede the "b", unlike the case with other formats.
The characters may be "escaped" Hex values. For example "%b\eFF " will display a
solid black block if true, and a space if false and "%b\e7F\e7E" would display
right-arrow for false and left-arrow for true. An unexpected value of 'E'
indicates a formatting error. 

\fBPages\fR
The page separator is the "|" (pipe) character. (if the actual character is 
needed then \e7C may be used). A "Page" in this context refers to a separate 
format which may be displayed on the same display. 

\fBInstances\fR
The instance separator is the comma. This creates a completely separate lcd
instance, for example to drive a second lcd display on the second 7i73. 
The use of comma to separate instances is built in to the modparam reading code
so not even escaped commas "\e," can be used. A comma may be displayed by using
the \e2C sequence. 



.SH AUTHOR
Andy Pugh
.SH LICENSE
GPL
.TH LINEARDELTAKINS "9" "2013-07-11" "LinuxCNC Documentation" "Kinematics Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

lineardeltakins \- Kinematics for a linear delta robot

.SH SYNOPSIS
.HP
.B loadrt lineardeltakins

.SH KINEMATICS
The kinematics model is appropriate for a rostock/kossel-style design
with three joints arranged in an equilateral triangle.  (0,0) is always
the center of the working volume.  Joint 0 is at (0,R) and subsequent
joints are 120 degrees clockwise (note that joint 0 is not at zero
radians).  The length of the arm is L.

Joints 0-2 are the linear carriages.  Axes ABC and UVW are passed
through unchanged in joints 3-8, so that e.g., A can still be used to
control an extruder.

.SH PINS
.TP 
.B lineardeltakins.R\fR float in
Effective diameter of the platform.

R is different than the distance from the center of the table to the
center of the belt/smooth rod/extrusion that the joints ride on.  In
RepRap delta parlance, R is DELTA_RADIUS which is computed as

DELTA_SMOOTH_ROD_OFFSET - DELTA_EFFECTOR_OFFSET - DELTA_CARRIAGE_OFFSET.

.TP
.B lineardeltakins.L\fR float in
Length of the rod connecting the carriage to the effector.  In RepRap
delta parlance, L is DELTA_DIAGONAL_ROD

.SH NOTES
The R and L values can be adjusted while LinuxCNC is running.  However,
doing so while in coordinated mode will lead to a step change in joint
position, which generally will trigger a following error if in joint
mode with machine on.

\# Author Andy Pugh
\# Issued under the terms of the GPL v2 License or any later version
.TH MATRIX_KB "9" "2013-03-24" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

matrix_kb \- Convert integers to HAL pins. Optionally scan a matrix of IO ports
to create those integers.  
.SH SYNOPSIS
.B loadrt matrix_kb config=\fIRxCs,RxCs\fB... names=\fIname1,name2\fB...
.P
Creates a component configured for R rows and N columns of matrix keyboard. 

If the \fBs\fR option is specified then a set of output rows will be cyclically
toggled, and a set of input columns will be scanned. 

The \fBnames\fR parameter is optional, but if used then the HAL pins and functions
will use the specified names rather than the default ones. This can be useful
for readbility and 2-pass HAL parsing. 

There must be no spaces in the parameter lists. 

.SH DESCRIPTION

This component was written to convert matrix keyboard scancodes into HAL pins. 
However, it might also find uses in converting integers from 0 to N into N HAL
pins. 

The component can work in two ways, and the HAL pins created vary according to
mode. 

In the default mode the component expects to be given a scan code from a
separate driver but could be any integer from any source. Most typically this
will be the keypad scancode from a Mesa 7i73. The default codes for keyup and
keydown are based on the Mesa 7i73 specification with 0x40 indicating a keydown
and 0x80 a keyup event. 
 If using the 7i73 it is important to match the keypad size
jumpers with the HAL component. Valid configs for the 7i73 are 4x8 and 8x8. 
Note that the component will only work properly with the version 12 (0xC) 7i73
firmware. The firmware version is visible on the component parameters in HAL.

In the optional scan-generation mode the \fBmatrix_kb.\fIN\fB.keycode\fR pin 
changes to an output pin and a set of output row pins and input column pins are
created. 
These need to be connected to physical inputs and outputs to scan the matrix and
return values to HAL. Note the \fBnegative\-logic\fR parameter described below,
this will need to be set on the most common forms of inputs which float high
when unconnected.  

In both modes a set of HAL output pins are created corresponding to each node of
the matrix.

.SH FUNCTIONS
.TP
.B matrix_kb.\fIN\fR
Perform all requested functions. Should be run in a slow thread for effective
debouncing. 
.SH PINS
.TP
.B matrix_kb.\fIN\fB.col\-\fICC\fB\-in\fR bit in
The input pin corresponding to column C.
.TP
.B matrix_kb.\fIN\fB.key.r\fIR\fBc\fIC\fR bit out
The pin corresponding to the key at row R column C of the matrix. 
.TP
.B matrix_kb.\fIN\fB.keycode\fR unsigned in or out depending on mode. 
This pin should be connected to the scancode generator if hardware such as a 
7i73 is being used. In this mode it is an input pin. In the internally-generated
scanning mode this pin is an output, but will not normally be connected. 
.B matrix_kb.\fIN\fB.row\-\fIRR\fB\-out bit out
The row scan drive pins.Should be connected to external hardware pins connected
to the keypad. 

.SH PARAMETERS
.TP
.B matrix_kb.\fIN\fB.key_rollover\fR unsigned r/w (default 2)
With most matrix keyboards the scancodes are only unambiguous with 1 or 2 keys
pressed. With more keys pressed phantom keystrokes can appear. Some keyboards
are optimised to reduce this problem, and some have internal diodes so that any
number of keys may be pressed simultaneously. Increase the value of this parameter
if such a keyboard is connected, or if phantom keystrokes are more acceptable
than only two keys being active at one time. 
.TP
.B matrix_kb.\fIN\fB.negative\-logic\fR bit r/w (default 1) only in scan mode
When no keys are pressed a typical digital input will float high. The input will
then be pulled low by the keypad when the corresponding poll line is low.
Set this parameter to 0 if the IO in use requires one row at a time to be high,
and a high input corresponds to a button press. 


.so man9/kins.9
.TH MOTION "9" "" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
motion \- accepts NML motion commands, interacts with HAL in realtime
.SH SYNOPSIS
\fBloadrt motmod [base_period_nsec=\fIperiod\fB] [base_thread_fp=\fI0 or 1\fB] [servo_period_nsec=\fIperiod\fB] [traj_period_nsec=\fIperiod\fB] [num_joints=\fI[1-16]\fB] [num_dio=\fI[1-64]\fB] [num_aio=\fI[1-64]\fB] [num_spindles=\fI[1-8]\fB]\fR  \fB[unlock_joints_mask=\fR\fIjointmask\fR\fB]\fR \fB[num_extrajoints=\fI[0-16]\fB]\fR

The limits for the following items are compile-time settings:
.TQ
\fBnum_joints\fR: Maximum number of joints is set by EMCMOT_MAX_JOINTS.
.TQ
\fBnum_dio\fR: Maximum number of digital inputs is set by EMCMOT_MAX_DIO.
.TQ
\fBnum_aio\fR: Maximum number of analog inputs is set by EMCMOT_MAX_AIO.
.TQ
\fBnum_spindles\fR: Maximum number of spindles is set by EMCMOT_MAX_SPINDLES

.P
Optionally the number of Digital I/O is set with num_dio. The number of Analog I/O is set with num_aio. The default is 4 each.

.P
Pin names starting with "\fBjoint\fR"  or "\fBaxis\fR" are are read and updated by the motion-controller function.

.SH DESCRIPTION
By default, the base thread does not support floating point.  Software stepping, software encoder counting, and software pwm do not use floating point.  \fBbase_thread_fp\fR can be used to enable floating point in the base thread (for example for brushless DC motor control).

.P
These pins and parameters are created by the realtime \fBmotmod\fR module. This module provides a HAL interface for LinuxCNC's motion planner. Basically \fBmotmod\fR takes in a list of waypoints and generates a nice blended and constraint-limited stream of joint positions to be fed to the motor drives.

.P
The optional \fBnum_extrajoints\fR parameter specifies a quantity of joints
that participate in homing but are not used by kinematics transformations.
After homing, control of an 'extra' joint is transferred to a posthome command
hal pin (joint.N.posthome-cmd) and the motor feedback value is ignored.  'Extra'
joints must be managed by independent motion planners/controllers (typically
using limit3 hal components).  Extra joints maybe unhomed only when motion is
disabled.

The maximum \fBnum_extrajoints\fR value is equal to the \fBnum_joints\fR value.
(Note that using the maximum value would allow no operation in world
coordinates).  The \fBnum_joints\fR value must be equal to the sum of the
number of joints used for kinematics calculations plus the number of 'extra'
joints.

The \fBnum_joints\fR parameter is conventionally set using the ini file
setting \fB[KINS]JOINTS=\fRvalue.  The \fBnum_extrajoints\fR is set by
the additional motmod parameter \fB[EMCMOT]motmod num_extrajoints=\fRvalue.
Hal pin numbering for all joints is zero based [\fB0 ... num_joints-1\fR].
When specified, 'extra' joints are assigned the last \fBnum_extrajoints\fR
in the numbering sequence.  For example, specifying [KINS]JOINTS=5 and
[EMCMOT]motmod num_extrajoints=2 for a 3 joint trivkins configuration
\fB[KINS] KINEMATICS=trivkins coordinates=xyz\fR uses joints 0,1,2 for
the kinematic joints and joints 3,4 for the 'extra' joints.

.SH  MOTION PINS

.TP
\fBmotion-command-handler.time\fR OUT S32
Time (in CPU clocks) for the motion module motion-command-handler

.TP
\fBmotion-controller.time\fR OUT S32
Time (in CPU clocks) for the motion module motion-controller

.TP
\fBmotion.adaptive\-feed\fR IN FLOAT
When adaptive feed is enabled with M52 P1, the commanded velocity is multiplied by this value. This effect is multiplicative with the NML-level feed override value and motion.feed\-hold.
Negative values are valid and will run the G\-code path in reverse.

.TP
\fBmotion.analog\-in\-\fINN\fR IN FLOAT
These pins are used by M66 Enn wait-for-input mode.

.TP
\fBmotion.analog\-out\-\fINN\fR OUT FLOAT
These pins are used by M67-68.

.TP
\fBmotion.coord\-error\fR OUT BIT
TRUE when motion has encountered an error, such as exceeding a soft limit

.TP
\fBmotion.coord\-mode\fR OUT BIT
TRUE when motion is in "coordinated mode", as opposed to "teleop mode"

.TP
\fBmotion.current\-vel\fR OUT FLOAT
Current cartesian velocity

.TP
\fBmotion.digital\-in\-\fINN\fR IN BIT
These pins are used by M66 Pnn wait-for-input mode.

.TP
\fBmotion.digital\-out\-\fINN\fR OUT BIT
These pins are controlled by the M62 through M65 words.

.TP
\fBmotion.distance\-to\-go\fR OUT FLOAT
Distance remaining in the current move

.TP
\fBmotion.enable\fR IN BIT
If this bit is driven FALSE, motion stops, the machine is placed in the "machine off" state, and a message is displayed for the operator. For normal motion, drive this bit TRUE.

.TQ
\fBmotion.eoffset-active\fR OUT BIT
Indicates external offsets are active (non-zero)

.TQ
\fBmotion.eoffset-limited\fR OUT BIT
Indicates motion with external offsets was limited by
a soft limit constraint ([AXIS_L]MIN_LIMIT,MAX_LIMIT).

.TP
\fBmotion.feed\-hold\fR IN BIT
When Feed Stop Control is enabled with M53 P1, and this bit is TRUE, the feed rate is set to 0.

.TP
\fBmotion.feed\-inhibit\fR IN BIT
When this pin is TRUE, machine motion is inhibited (this includes jogs,
programmed feeds, and programmed rapids, aka traverse moves).

If the machine is performing a spindle synchronized move when this
pin goes TRUE, the spindle synchronized motion will finish, and any
following moves will be inhibited (this is to prevent damage to the
machine, the tool, or the work piece).

If the machine is in the middle of a (non-spindle synchronized) move
when this pin goes TRUE, the machine will decelerate to a stop at the
maximum allowed acceleration rate.

Motion resumes when this pin goes FALSE.

.TP
\fBmotion.homing\-inhibit\fR IN BIT
If this bit is TRUE, initiation of any joint homing move (including "Home All")
is disallowed and an error is reported.  By default, homing is allowed in joint
mode whenever motion is enabled.

.TP
\fBmotion.in\-position\fR OUT BIT
TRUE if the machine is in position (ie, not currently moving towards
the commanded position).

.TP
\fBmotion.motion\-enabled\fR OUT BIT

.TP
\fBmotion.motion\-type\fR OUT S32
These values are from src/emc/nml_intf/motion_types.h
.RS
.RS
.TP
0: Idle (no motion)
.P
1: Traverse
.P
2: Linear feed
.P
3: Arc feed
.P
4: Tool change
.P
5: Probing
.P
6: Rotary unlock for traverse
.RE
.RE

.TP
\fBmotion.on\-soft\-limit\fR OUT BIT

.TP
\fBmotion.probe\-input\fR IN BIT
G38.n uses the value on this pin to determine when the probe has made contact. TRUE for probe contact closed (touching), FALSE for probe contact open.

.TP
\fBmotion.program\-line\fR OUT S32
The current program line while executing. Zero if not running or between
lines while single stepping.

.TP
\fBmotion.requested\-vel\fR OUT FLOAT
The current requested velocity in user units per second.  This value is
the F-word setting from the G-code file, possibly reduced to accomodate
machine velocity and acceleration limits. The value on this pin does
not reflect the feed override or any other adjustments.

.TP
\fBmotion.servo.last\-period\fR OUT U32
The number of CPU clocks between invocations of the servo thread. Typically, this number divided by the CPU speed gives the time in seconds, and can be used to determine whether the realtime motion controller is meeting its timing constraints

.TP
\fBmotion.teleop\-mode\fR OUT BIT
Motion mode is teleop (axis coordinate jogging available).

.TQ
\fBmotion.tooloffset.L\fR OUT FLOAT
Current tool offset for each axis where
(\fBL\fR is the axis letter, one of: \fBx y z a b c u v w\fR)

.SH  AXIS PINS
(\fBL\fR is the axis letter, one of: \fBx y z a b c u v w\fR)

.TP
\fBaxis.\fIL\fB.eoffset\fR OUT FLOAT
Current external offset.

.TP
\fBaxis.\fIL\fB.eoffset-clear\fR IN BIT
Clear external offset request

.TP
\fBaxis.\fIL\fB.eoffset-counts\fR IN S32
Counts input for external offset.
The eoffset-counts are transferred to an internal
register.  The applied external offset is the
product of the register counts and the eoffset-scale
value.  The register is \fBreset to zero at each machine
startup\fR.  If the machine is turned off with an external
offset active, the eoffset-counts pin should be set
to zero before restarting.

.TP
\fBaxis.\fIL\fB.eoffset-enable\fR IN BIT
Enable for external offset (also requires ini file
setting for [AXIS_L]OFFSET_AV_RATIO)

.TP
\fBaxis.\fIL\fB.eoffset-request\fR OUT FLOAT
Debug pin for requested external offset.

.TP
\fBaxis.\fIL\fB.eoffset-scale\fR IN FLOAT
Scale for external offset.

.TP
\fBaxis.\fIL\fB.jog\-accel\-fraction\fR IN FLOAT
Sets acceleration for wheel jogging to a fraction of the ini max_acceleration for
the axis. Values greater than 1 or less than zero are ignored.

.TP
\fBaxis.\fIL\fB.jog\-counts\fR IN S32
Connect to the "counts" pin of an external encoder to use a physical jog wheel.

.TP
\fBaxis.\fIL\fB.jog\-enable\fR IN BIT
When TRUE (and in manual mode), any change to "jog\-counts" will result in motion. When false, "jog\-counts" is ignored.

.TP
\fBaxis.\fIL\fB.jog\-scale\fR IN FLOAT
Sets the distance moved for each count on "jog\-counts", in machine units.

.TP
\fBaxis.\fIL\fB.jog\-vel\-mode\fR IN BIT
When FALSE (the default), the jogwheel operates in position mode. The axis will move exactly jog\-scale units for each count, regardless of how long that might take. When TRUE, the wheel operates in velocity mode - motion stops when the wheel stops, even if that means the commanded motion is not completed.

.TP
\fBaxis.\fIL\fB.kb\-jog\-active\fR OUT BIT
(free planner axis jogging active (keyboard or halui))

.TP
\fBaxis.\fIL\fB.pos\-cmd\fR OUT FLOAT
The axis commanded position. There may be several offsets between the axis and motor coordinates: backlash compensation, screw error compensation, and home offsets.  External offsets are reported separately (axis.\fBL\fR.eoffset).

.TP
\fBaxis.\fIL\fB.teleop\-pos\-cmd\fR OUT FLOAT

.TP
\fBaxis.\fIL\fB.teleop\-tp\-enable\fR OUT BIT
TRUE when the "teleop planner" is enabled for this axis

.TP
\fBaxis.\fIL\fB.teleop\-vel\-cmd\fR OUT FLOAT
The axis's commanded velocity

.TP
\fBaxis.\fIL\fB.teleop\-vel\-lim\fR OUT FLOAT
The velocity limit for the teleop planner

.TP
\fBaxis.\fIL\fB.wheel\-jog\-active\fR OUT BIT

.SH JOINT PINS
\fBN\fR is the joint number (\fB0\fR ... \fBnum_joints\-1\fR))
.TP
(\fBNote:\fR pins marked \fB(DEBUG)\fR serve as debugging aids
and are subject to change or removal at any time.)

.TP
\fBjoint.\fIN\fB.joint\-acc\-cmd\fR OUT FLOAT \fB(DEBUG)\fR
The joint's commanded acceleration

.TP
\fBjoint.\fIN\fB.active\fR OUT BIT \fB(DEBUG)\fR
TRUE when this joint is active

.TP
\fBjoint.\fIN\fB.amp\-enable\-out\fR OUT BIT
TRUE if the amplifier for this joint should be enabled

.TP
\fBjoint.\fIN\fB.amp\-fault\-in\fR IN BIT
Should be driven TRUE if an external fault is detected with the amplifier for this joint

.TP
\fBjoint.\fIN\fB.backlash\-corr\fR OUT FLOAT \fB(DEBUG)\fR
Backlash or screw compensation raw value

.TP
\fBjoint.\fIN\fB.backlash\-filt\fR OUT FLOAT \fB(DEBUG)\fR
Backlash or screw compensation filtered value (respecting motion limits)

.TP
\fBjoint.\fIN\fB.backlash\-vel\fR OUT FLOAT \fB(DEBUG)\fR
Backlash or screw compensation velocity

.TP
\fBjoint.\fIN\fB.coarse\-pos\-cmd\fR OUT FLOAT \fB(DEBUG)\fR

.TP
\fBjoint.\fIN\fB.error\fR OUT BIT \fB(DEBUG)\fR
TRUE when this joint has encountered an error, such as a limit switch closing

.TP
\fBjoint.\fIN\fB.f\-error\fR OUT FLOAT \fB(DEBUG)\fR
The actual following error

.TP
\fBjoint.\fIN\fB.f\-error\-lim\fR OUT FLOAT \fB(DEBUG)\fR
The following error limit

.TP
\fBjoint.\fIN\fB.f\-errored\fR OUT BIT \fB(DEBUG)\fR
TRUE when this joint has exceeded the following error limit

.TP
\fBjoint.\fIN\fB.faulted\fR OUT BIT \fB(DEBUG)\fR

.TP
\fBjoint.\fIN\fB.free\-pos\-cmd\fR OUT FLOAT \fB(DEBUG)\fR
The "free planner" commanded position for this joint.

.TP
\fBjoint.\fIN\fB.free\-tp\-enable\fR OUT BIT \fB(DEBUG)\fR
TRUE when the "free planner" is enabled for this joint

.TP
\fBjoint.\fIN\fB.free\-vel\-lim\fR OUT FLOAT \fB(DEBUG)\fR
The velocity limit for the free planner

.TP
\fBjoint.\fIN\fB.home\-state\fR OUT S32 \fB(DEBUG)\fR
homing state machine state

.TP
\fBjoint.\fIN\fB.home\-sw\-in\fR IN BIT
Should be driven TRUE if the home switch for this joint is closed

.TP
\fBjoint.\fIN\fB.homed\fR OUT BIT \fB(DEBUG)\fR
TRUE if the joint has been homed

.TP
\fBjoint.\fIN\fB.homing\fR OUT BIT
TRUE if the joint is currently homing

.TP
\fBjoint.\fIN\fB.in\-position\fR OUT BIT \fB(DEBUG)\fR
TRUE if the joint is using the "free planner" and has come to a stop

.TP
\fBjoint.\fIN\fB.index\-enable\fR IO BIT
Should be attached to the index\-enable pin of the joint's encoder to enable homing to index pulse

.TQ
\fBjoint.N.is\-unlocked\fR IN BIT
Indicates joint is unlocked (see JOINT UNLOCK PINS).

.TP
\fBjoint.\fIN\fB.jog\-accel\-fraction\fR IN FLOAT
Sets acceleration for wheel jogging to a fraction of the ini max_acceleration for
the joint.  Values greater than 1 or less than zero are ignored.

.TP
\fBjoint.\fIN\fB.jog\-counts\fR IN S32
Connect to the "counts" pin of an external encoder to use a physical jog wheel.

.TP
\fBjoint.\fIN\fB.jog\-enable\fR IN BIT
When TRUE (and in manual mode), any change to "jog\-counts" will result in motion. When false, "jog\-counts" is ignored.

.TP
\fBjoint.\fIN\fB.jog\-scale\fR IN FLOAT
Sets the distance moved for each count on "jog\-counts", in machine units.

.TP
\fBjoint.\fIN\fB.jog\-vel\-mode\fR IN BIT
When FALSE (the default), the jogwheel operates in position mode. The joint will move exactly jog\-scale units for each count, regardless of how long that might take. When TRUE, the wheel operates in velocity mode - motion stops when the wheel stops, even if that means the commanded motion is not completed.

.TP
\fBjoint.\fIN\fB.kb\-jog\-active\fR OUT BIT \fB(DEBUG)\fR
(free planner joint jogging active (keyboard or halui))

.TP
\fBjoint.\fIN\fB.motor\-offset\fR OUT FLOAT \fB(DEBUG)\fR
joint motor offset established when joint is homed.

.TP
\fBjoint.\fIN\fB.motor\-pos\-cmd\fR OUT FLOAT
The commanded position for this joint.

.TP
\fBjoint.\fIN\fB.motor\-pos\-fb\fR IN FLOAT
The actual position for this joint.

.TP
\fBjoint.\fIN\fB.neg\-hard\-limit\fR OUT BIT \fB(DEBUG)\fR
The negative hard limit for the joint

.TP
\fBjoint.\fIN\fB.neg\-lim\-sw\-in\fR IN BIT
Should be driven TRUE if the negative limit switch for this joint is tripped.

.TP
\fBjoint.\fIN\fB.pos\-cmd\fR OUT FLOAT
The joint (as opposed to motor) commanded position. There may be several offsets between the joint and motor coordinates: backlash compensation, screw error compensation, and home offsets.

.TP
\fBjoint.\fIN\fB.pos\-fb\fR OUT FLOAT
The joint feedback position. This value is computed from the actual motor position minus joint offsets. Useful for machine visualization.

.TP
\fBjoint.\fIN\fB.pos\-hard\-limit\fR OUT BIT \fB(DEBUG)\fR
The positive hard limit for the joint

.TP
\fBjoint.\fIN\fB.pos\-lim\-sw\-in\fR IN BIT
Should be driven TRUE if the positive limit switch for this joint is tripped.

.TP
\fBjoint.\fIN\fB.unlock\fR OUT BIT
TRUE if the axis is a locked joint (typically a rotary) and a move
is commanded (see JOINT UNLOCK PINS).

.TP
\fBjoint.\fIN\fB.joint\-vel\-cmd\fR OUT FLOAT \fB(DEBUG)\fR
The joint's commanded velocity

.TP
\fBjoint.\fIN\fB.wheel\-jog\-active\fR OUT BIT \fB(DEBUG)\fR

.SH JOINT posthome pins
Each joint designated as an 'extra' joint is provided with a hal pin
\fBjoint.N.posthome-cmd\fR.  The pin value is ignored prior to homing.
After homing, the pin value is augmented by the motor offset value
and routed to the \fBjoint.N.motor-pos-cmd\fR.

.SH JOINT unlock pins
The joint pins used for unlocking a joint
(\fBjoint.N.unlock\fR, \fBjoint.N.is-unlocked\fR),
are created according to the \fBunlock_joints_mask=\fRjointmask parameter for motmod.  These pins may be required for locking indexers (typically a rotary joint)

The jointmask bits are: (lsb)0:joint0, 1:joint1, 2:joint2, ...

.TQ
Example: loadrt motmod ... \fBunlock_joints_mask=\fR0x38 creates unlock pins for joints 3,4,5

.SH  SPINDLE PINS
(\fBM\fR is the spindle number (\fB0\fR ... \fBnum_spindles\-1\fR))

.TP
\fBspindle.M\fB.amp\-fault\-in\fR IN BIT
Should be driven TRUE if an external fault is detected with the amplifier for this spindle

.TP
\fBspindle.M.at\-speed\fR IN BIT
Motion will pause until this pin is TRUE, under the following conditions: before the
first feed move after each spindle start or speed change; before the start of every
chain of spindle\-synchronized moves; and if in CSS mode, at every rapid\->feed transition.

.TP
\fBspindle.M.brake\fR OUT BIT
TRUE when the spindle brake should be applied

.TP
\fBspindle.M.forward\fR OUT BIT
TRUE when the spindle should rotate forward

.TP
\fBspindle.M.index\-enable\fR I/O BIT
For correct operation of spindle synchronized moves, this signal must be hooked to the index\-enable pin of the spindle encoder.

.TP
\fBspindle.M.inhibit\fR IN BIT
When TRUE, the spindle speed is set and held to 0.

.TP
\fBspindle.M.is\-oriented\fR IN BIT
Acknowledge pin for spindle\-orient. Completes orient cycle. If spindle\-orient was true when spindle\-is\-oriented
was asserted, the spindle\-orient pin is cleared and the spindle\-locked pin is asserted. Also, the spindle\-brake pin is asserted.

.TP
\fBspindle.M.locked\fR OUT BIT
Spindle orient complete pin. Cleared by any of M3,M4,M5.

.TP
\fBspindle.M.on\fR OUT BIT
TRUE when spindle should rotate

.TP
\fBspindle.M.orient\fR OUT BIT
Indicates start of spindle orient cycle. Set by M19. Cleared by any of M3,M4,M5.

If spindle\-orient\-fault is not zero during spindle\-orient true, the M19 command fails with an error message.

.TP
\fBspindle.M.orient\-angle\fR OUT FLOAT
Desired spindle orientation for M19. Value of the M19 R word parameter plus the value of the [RS274NGC]ORIENT_OFFSET ini parameter.

.TP
\fBspindle.M.orient\-fault\fR IN S32
Fault code input for orient cycle. Any value other than zero will cause the orient cycle to abort.

.TP
\fBspindle.M.orient\-mode\fR OUT BIT
Desired spindle rotation mode. Reflects M19 P parameter word.

.TP
\fBspindle.M.reverse\fR OUT BIT
TRUE when the spindle should rotate backward

.TP
\fBspindle.M.revs\fR IN FLOAT
For correct operation of spindle synchronized moves, this signal must be hooked to the position pin of the spindle encoder.

.TP
\fBspindle.M.speed\-cmd\-rps\fR FLOAT OUT
Commanded spindle speed in units of revolutions per second

.TP
\fBspindle.M.speed\-in\fR IN FLOAT
Actual spindle speed feedback in revolutions per second; used for G96 (constant surface speed) and G95 (feed per revolution) modes.

.TP
\fBspindle.M.speed\-out\fR OUT FLOAT
Desired spindle speed in rotations per minute

.TP
\fBspindle.M.speed\-out\-abs\fR OUT FLOAT
Desired spindle speed in rotations per minute, always positive regardless of spindle direction.

.TP
\fBspindle.M.speed\-out\-rps\fR OUT FLOAT
Desired spindle speed in rotations per second

.TP
\fBspindle.M.speed\-out\-rps\-abs\fR OUT FLOAT
Desired spindle speed in rotations per second, always positive regardless of spindle direction.

.SH MOTION PARAMETERS

Many of the parameters serve as debugging aids, and are subject to change or removal at any time.

.TQ
\fBmotion\-command\-handler.tmax\fR RW S32
Show information about the execution time of these HAL functions in CPU clocks

.TQ
\fBmotion\-command\-handler.tmax\-increased\fR RO S32

.TQ
\fBmotion\-controller.tmax\fR RW S32
Show information about the execution time of these HAL functions in CPU clocks

.TQ
\fBmotion\-controller.tmax\-increased\fR RO BIT

.TP
\fBmotion.debug\-\fI*\fR
These values are used for debugging purposes.

.SH FUNCTIONS

Generally, these functions are both added to the servo-thread in the order shown.

.TP
\fBmotion\-command\-handler\fR
Processes motion commands coming from user space.
The pin named \fBmotion-command-handler.time\fR and parameters
\fBmotion-command-handler.tmax,tmax-increased\fRare created for
this function.

.TP
\fBmotion\-controller\fR
Runs the LinuxCNC motion controller
The pin named \fBmotion-controller.time\fR and parameters
\fBmotion-controller.tmax,tmax-increased\fR are created for
this function.

.SH BUGS
This manual page is incomplete.
.TQ
Identification of pins categorized with \fB(DEBUG)\fR is dubious.

.SH SEE ALSO
iocontrol(1), milltask(1)
\# Author Andy Pugh
\# Issued under the terms of the GPL v2 License or any later version
.TH MUX_GENERIC "9" "2013-05-27" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

mux_generic \- choose one from several input values
.SH SYNOPSIS
.HP
.B loadrt mux_generic config="bb8,fu12...."
.SH FUNCTIONS
.TP
\fBmux\-gen.\fINN\fB\fR Depending on the data types can run in either a floating
point or non-floating point thread.

.SH PINS
.TP
.B mux\-gen.\fINN\fB.suppress\-no\-input\fR bit in \fR
This suppresses changing the output if all select lines are false.
This stops unwanted jumps in output between transitions of input.
but makes in00 unavaliable.

.TP
.B mux\-gen.\fINN\fB.debounce\-us\fR unsigned in \fR
sets debouce time in microseconds.  eg. 100000 = a tenth of a second.
The selection inputs must be stable this long before the output changes. This
helps to ignore 'noisy' switches.

.TP
.B mux\-gen.\fINN\fB.sel\-bit\fIMM\fB\fR bit in  (M=0..N) \fR
.TP
.B mux\-gen.\fINN\fB.sel\-int\fI\fB\fR unsigned in \fR
Together, these determine which \fBin\fIN\fR value is copied to \fBoutput\fR.
The bit pins are interpreted as binary bits, and the result is simply added on
to the integer pin input. It is expected that either one or the other
would normally be used. Hower, the possibility exists to use a higher-order
bit to "shift" the values set by the integer pin. 
The sel\-bit pins are only created when the size of the mux_gen component is an
integer power of two. 
This component (unlike mux16) does not offer the option of decoding gray-code, 
however the same effect can be achieved by arranging the order of the input
values to suit. 

.TP
.B mux\-gen.\fINN\fB.out\-[bit/float/s32/u32]\fR variable-type out \fR
Follows the value of one of the \fBin\fIN\fR values according to the selection 
bits and/or the selection number. 
Values will be converted/truncated according to standard C rules. This means,
for example that a float input greater than 2147483647 will give an S32 output
of \-2147483648. 

.TP
.B mux\-gen.\fINN\fB.in\-[bit/float/s32/u32]\-\fIMM\fB\fR variable-type in\fR
The possible output values that are selected by the selection pins. 

.SH PARAMETERS
.TP
.B mux\-gen.\fIN\fB.elapsed\fR float r \fR
Current value of the internal debounce timer
for debugging.
.TP
.B mux\-gen.\fIN\fB.selected\fR s32 r \fR
Current value of the internal selection variable after conversion
for debugging. Possibly useful for setting up gray-code switches. 
 
.SH DESCRIPTION
This component is a more general version of the other multiplexing components.
It allows the creation of arbitrary-size multiplexers (up to 1024 entries) and
also supports differing data types on the input and output pins. 
The configuration string is a comma-separated list of code-letters and numbers,
such as "bb4,fu12" This would create a 4-element bit-to-bit mux and a 
12-element float-to-unsigned mux. The code letters are b = bit, f = float, s =
signed integer, u = unsigned integer. The first letter code is the input type,
the second is the output type. The codes are not case-sensitive. The order of
the letters is significant but the position in the string is not. Do not
insert any spaces in the config string. 
Any non-zero float value will be converted to a "true" output in bit form. Be
wary that float datatypes can be very, very, close to zero and not actually be
equal to zero. 

Each mux has its own HAL function and must be added to a thread separately. 
If neither input nor output is of type float then the function is base-thread
(non floating-point) safe. Any mux_generic with a floating point input or 
output can only be added to a floating-point thread. 

.SH LICENSE
GPL

.SH AUTHOR
Andy Pugh
.\"
.TH OPTO_AC5 "9" "2008-08-04" "LinuxCNC Documentation" "HAL Component" 
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
opto_ac5 \- Realtime driver for opto22 PCI-AC5 cards
.SH SYNOPSIS
\fBloadrt opto_ac5  [portconfig0=0x\fIN\fB] [portconfig1=0x\fIN\fB] 

.SH DESCRIPTION

These pins and parameters are created by the realtime \fBopto_ac5\fR module.
The portconfig0 and portconfig1 variables are used to configure the two ports of each card. The first 24 bits of a 32 bit number represent the 24 i/o points of each port. The lowest (rightmost) bit would be HAL pin 0 which is  header connector pin 47. Then next bit to the left would be HAL pin 1,  header connector pin 45 and so on, untill bit 24 would be HAL pin 23 ,  header connector pin 1.
"1" bits represent output points.
So channel 0..11 as inputs and 12..23 as outputs would be represented by (in binary) 111111111111000000000000 which is 0xfff000 in hexadecimal. 
That is the number you would use Eg. loadrt opto_ac5 portconfig0=0xfff000

If no portconfig variable is specified the default configuration is 12 inputs then 12 outputs.

Up to 4 boards are supported.  Boards are numbered starting at 0.

Portnumber can be 0 or 1. Port 0 is closes to the card bracket.

.SH PINS

.TP
\fBopto_ac5.[\fIBOARDNUMBER\fB\fR].\fBport[\fIPORTNUMBER\fB\fR].\fBin\-[\fIPINNUMBER\fB\fR] OUT bit 
.TQ
\fBopto_ac5.[\fIBOARDNUMBER\fB\fR].\fBport[\fIPORTNUMBER\fB\fR].\fBin\-[\fIPINNUMBER\fB\fR]\-not OUT bit 
Connect a hal bit signal to this pin to read an i/o point from the card.
The PINNUMBER represents the position in the relay rack. Eg. PINNUMBER 0 is position 0 in a opto22 relay rack and would be pin 47 on the 50 pin header connector. The \fB\-not\fR pin is
inverted so that LOW gives TRUE and HIGH gives FALSE.

.TP
\fBopto_ac5.[\fIBOARDNUMBER\fB\fR].\fBport[\fIPORTNUMBER\fB\fR].\fBout\-[\fIPINNUMBER\fB\fR] IN bit  
Connect a hal bit signal to this pin to write to an i/o point of the card.
The PINNUMBER represents the position in the relay rack.Eg. PINNUMBER 23 is position 23 in a opto22 relay rack and would be pin 1 on the 50 pin header connector.

.TP
\fBopto_ac5.[\fIBOARDNUMBER\fB\fR].\fBled[\fINUMBER\fB\fR] OUT bit 
Turns one of the on board LEDS on/off. LEDS are numbered 0 to 3.

.SH PARAMETERS
.TP
\fBopto_ac5.[\fIBOARDNUMBER\fB\fR].\fBport[\fIPORTNUMBER\fB\fR].\fBout\-[\fIPINNUMBER\fB\fR]\-invert W bit  
When TRUE, invert the meaning of the corresponding \fB\-out\fR pin so that TRUE
gives LOW and FALSE gives HIGH.

.SH FUNCTIONS

.TP
\fBopto_ac5.0.digital\-read
Add this to a thread to read all the input points.

.TP
\fBopto_ac5.0.digital\-write
Add this to a thread to write all the output points and LEDS.

.SH BUGS
All boards are loaded with the same port configurations  as the first board.

.SH SEE ALSO

http://wiki.linuxcnc.org/cgi\-bin/wiki.pl?OptoPciAc5
.TH PID "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
pid \- proportional/integral/derivative controller
.SH SYNOPSIS
\fBloadrt pid [num_chan=\fInum\fB | names=\fIname1\fB[,\fIname2...\fB]] [\fBdebug=\fIdbg\fR]

.SH DESCRIPTION
\fBpid\fR is a classic Proportional/Integral/Derivative controller,
used to control position or speed feedback loops for servo motors and
other closed-loop applications.
.P
\fBpid\fR supports a maximum of sixteen controllers.  The number that
are actually loaded is set by the \fBnum_chan\fR argument when
the module is loaded.  Alternatively, specify names= and unique names
separated by commas.
.P
The \fBnum_chan=\fR and \fBnames=\fR specifiers are mutually exclusive.
If neither \fBnum_chan=\fR nor \fBnames=\fR are specified, the default
value is three.  If \fBdebug\fR is set to 1 (the default is 0), some
additional HAL parameters will be exported, which might be useful
for tuning, but are otherwise unnecessary.

.SH NAMING
The names for pins, parameters, and functions are prefixed as:
  \fBpid.N.\fR for N=0,1,...,num\-1 when using \fBnum_chan=num\fR
  \fBnameN.\fR for nameN=name1,name2,... when using \fBnames=name1,name2,...\fR

The \fBpid.N.\fR format is shown in the following descriptions.

.SH FUNCTIONS

\fBpid.\fIN\fB.do\-pid\-calcs\fR (uses floating-point)
Does the PID calculations for control loop \fIN\fR.

.SH PINS

.TP
\fBpid.\fIN\fB.command\fR float in
The desired (commanded) value for the control loop.
.TP
\fBpid.\fIN\fB.Pgain\fR float in
Proportional gain.  Results in a contribution to the output that is the error
multiplied by \fBPgain\fR.
.TP
\fBpid.\fIN\fB.Igain\fR float in
Integral gain.  Results in a contribution to the output that is the integral
of the error multiplied by \fBIgain\fR.  For example an error of 0.02 that
lasted 10 seconds would result in an integrated error (\fBerrorI\fR) of 0.2,
and if \fBIgain\fR is 20, the integral term would add 4.0 to the output.
.TP
\fBpid.\fIN\fB.Dgain\fR float in
Derivative gain.  Results in a contribution to the output that is the rate of
change (derivative) of the error multiplied by \fBDgain\fR.  For example an
error that changed from 0.02 to 0.03 over 0.2 seconds would result in an error
derivative (\fBerrorD\fR) of of 0.05, and if \fBDgain\fR is 5, the derivative
term would add 0.25 to the output.
.TP
\fBpid.\fIN\fB.feedback\fR float in
The actual (feedback) value, from some sensor such as an encoder.
.TP
\fBpid.\fIN\fB.output\fR float out
The output of the PID loop, which goes to some actuator such as a motor.
.TP
\fBpid.\fIN\fB.command\-deriv\fR float in
The derivative of the desired (commanded) value for the control loop.  If no
signal is connected then the derivative will be estimated numerically.
.TP
\fBpid.\fIN\fB.feedback\-deriv\fR float in
The derivative of the actual (feedback) value for the control loop.  If no
signal is connected then the derivative will be estimated numerically.  When
the feedback is from a quantized position source (e.g., encoder feedback
position), behavior of the D term can be improved by using a better velocity
estimate here, such as the velocity output of encoder(9) or hostmot2(9).
.TP
\fBpid.\fIN\fB.error\-previous\-target\fR bit in
Use previous invocation's target vs. current position for error calculation,
like the motion controller expects.  This may make torque-mode position loops
and loops requiring a large I gain easier to tune, by eliminating
velocity\-dependent following error.
.TP
\fBpid.\fIN\fB.error\fR float out
The difference between command and feedback.
.TP
\fBpid.\fIN\fB.enable\fR bit in
When true, enables the PID calculations.  When false, \fBoutput\fR is zero,
and all internal integrators, etc, are reset.
.TP
\fBpid.\fIN\fB.index\-enable\fR bit in
On the falling edge of \fBindex\-enable\fR, pid does not update the
internal command derivative estimate.  On systems which use the encoder
index pulse, this pin should be connected to the index\-enable signal.
When this is not done, and FF1 is nonzero, a step change in the input
command causes a single-cycle spike in the PID output.  On systems which use
exactly one of the \fB\-deriv\fR inputs, this affects the D term as well.
.TP
\fBpid.\fIN\fB.bias\fR float in
\fBbias\fR is a constant amount that is added to the output.  In most cases
it should be left at zero.  However, it can sometimes be useful to compensate
for offsets in servo amplifiers, or to balance the weight of an object that
moves vertically. \fBbias\fR is turned off when the PID loop is disabled,
just like all other components of the output.  If a non-zero output is needed
even when the PID loop is disabled, it should be added with an external HAL
sum2 block.
.TP
\fBpid.\fIN\fB.FF0\fR float in
Zero order feed-forward term.  Produces a contribution to the output that is
\fBFF0\fR multiplied by the commanded value.  For position loops, it should
usually be left at zero.  For velocity loops, \fBFF0\fR can compensate for
friction or motor counter-EMF and may permit better tuning if used properly.
.TP
\fBpid.\fIN\fB.FF1\fR float in
First order feed-forward term.  Produces a contribution to the output that
\fBFF1\fR multiplied by the derivative of the commanded value.  For
position loops, the contribution is proportional to speed, and can be used
to compensate for friction or motor CEMF.  For velocity loops, it is
proportional to acceleration and can compensate for inertia.  In both
cases, it can result in better tuning if used properly.
.TP
\fBpid.\fIN\fB.FF2\fR float in
Second order feed-forward term.  Produces a contribution to the output that is
\fBFF2\fR multiplied by the second derivative of the commanded value.  For
position loops, the contribution is proportional to acceleration, and can be
used to compensate for inertia.  For velocity loops, the contribution is
proportional to jerk, and should usually be left at zero.
.TP
\fBpid.\fIN\fB.FF3\fR float in
Third order feed-forward term.  Produces a contribution to the output that is
\fBFF3\fR multiplied by the third derivative of the commanded value.  For
position loops, the contribution is proportional to jerk, and can be
used to compensate for residual errors during acceleration.  For velocity
loops, the contribution is proportional to snap(jounce), and should usually
be left at zero.
.TP
\fBpid.\fIN\fB.deadband\fR float in
Defines a range of "acceptable" error.  If the absolute value of \fBerror\fR
is less than \fBdeadband\fR, it will be treated as if the error is zero.
When using feedback devices such as encoders that are inherently quantized,
the deadband should be set slightly more than one-half count, to prevent
the control loop from hunting back and forth if the command is between two
adjacent encoder values.  When the absolute value of the error is greater
than the deadband, the deadband value is subtracted from the error before
performing the loop calculations, to prevent a step in the transfer function
at the edge of the deadband.  (See \fBBUGS\fR.)
.TP
\fBpid.\fIN\fB.maxoutput\fR float in
Output limit.  The absolute value of the output will not be permitted
to exceed \fBmaxoutput\fR, unless \fBmaxoutput\fR is zero.  When the output
is limited, the error integrator will hold instead of integrating, to prevent
windup and overshoot.
.TP
\fBpid.\fIN\fB.maxerror\fR float in
Limit on the internal error variable used for P, I, and D.  Can be used to
prevent high \fBPgain\fR values from generating large outputs under conditions
when the error is large (for example, when the command makes a step change).
Not normally needed, but can be useful when tuning non-linear systems.
.TP
\fBpid.\fIN\fB.maxerrorD\fR float in
Limit on the error derivative.  The rate of change of error used by the
\fBDgain\fR term will be limited to this value, unless the value is
zero.  Can be used to limit the effect of \fBDgain\fR and prevent large
output spikes due to steps on the command and/or feedback.  Not normally
needed.
.TP
\fBpid.\fIN\fB.maxerrorI\fR float in
Limit on error integrator.  The error integrator used by the \fBIgain\fR
term will be limited to this value, unless it is zero.  Can be used to prevent
integrator windup and the resulting overshoot during/after sustained errors.
Not normally needed.
.TP
\fBpid.\fIN\fB.maxcmdD\fR float in
Limit on command derivative.  The command derivative used by \fBFF1\fR will
be limited to this value, unless the value is zero.  Can be used to prevent
\fBFF1\fR from producing large output spikes if there is a step change on the
command.  Not normally needed.
.TP
\fBpid.\fIN\fB.maxcmdDD\fR float in
Limit on command second derivative.  The command second derivative used by
\fBFF2\fR will be limited to this value, unless the value is zero.  Can be
used to prevent \fBFF2\fR from producing large output spikes if there is a
step change on the command.  Not normally needed.
.TP
\fBpid.\fIN\fB.maxcmdDDD\fR float in
Limit on command third derivative.  The command third derivative used by
\fBFF3\fR will be limited to this value, unless the value is zero.  Can be
used to prevent \fBFF3\fR from producing large output spikes if there is a
step change on the command.  Not normally needed.
.TP
\fBpid.\fIN\fB.saturated\fR bit out
When true, the current PID output is saturated.  That is,
.RS 12
\fBoutput\fR = \(+- \fBmaxoutput\fR.
.RE
.TP
\fBpid.\fIN\fB.saturated\-s\fR float out
.TQ
\fBpid.\fIN\fB.saturated\-count\fR s32 out
When true, the output of PID was continually saturated for this many seconds
(\fBsaturated\-s\fR) or periods (\fBsaturated\-count\fR).
.SH PARAMETERS
.TP
\fBpid.\fIN\fB.errorI\fR float ro (only if debug=1)
Integral of error.  This is the value that is multiplied by \fBIgain\fR to produce the Integral term of the output.
.TP
\fBpid.\fIN\fB.errorD\fR float ro (only if debug=1)
Derivative of error.  This is the value that is multiplied by \fBDgain\fR to produce the Derivative term of the output.
.TP
\fBpid.\fIN\fB.commandD\fR float ro (only if debug=1)
Derivative of command.  This is the value that is multiplied by \fBFF1\fR to produce the first order feed-forward term of the output.
.TP
\fBpid.\fIN\fB.commandDD\fR float ro (only if debug=1)
Second derivative of command.  This is the value that is multiplied by
\fBFF2\fR to produce the second order feed-forward term of the output.
.TP
\fBpid.\fIN\fB.commandDDD\fR float ro (only if debug=1)
Third derivative of command.  This is the value that is multiplied by
\fBFF3\fR to produce the third order feed-forward term of the output.

.SH BUGS
Some people would argue that deadband should be implemented such that error is
treated as zero if it is within the deadband, and be unmodified if it is outside
the deadband.  This was not done because it would cause a step in the transfer
function equal to the size of the deadband.  People who prefer that behavior are
welcome to add a parameter that will change the behavior, or to write their own
version of \fBpid\fR. However, the default behavior should not be changed.

Negative gains may lead to unwanted behavior.  It is possible in some
situations that negative FF gains make sense, but in general all gains
should be positive.  If some output is in the wrong direction, negating
gains to fix it is a mistake; set the scaling correctly elsewhere
instead.
.so man9/kins.9
.TH PWMGEN "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
pwmgen \- software PWM/PDM generation
.SH SYNOPSIS
\fBloadrt pwmgen output_type=\fItype0\fR[,\fItype1\fR...]

.SH DESCRIPTION
\fBpwmgen\fR is used to generate PWM (pulse width modulation) or
PDM (pulse density modulation) signals.  The maximum PWM frequency
and the resolution is quite limited compared to hardware-based 
approaches, but in many cases software PWM can be very useful.
If better performance is needed, a hardware PWM generator is a
better choice.
.P
\fBpwmgen\fR supports a maximum of eight channels.  The number of
channels actually loaded depends on the number of \fItype\fR values
given.  The value of each \fItype\fR determines the outputs for that
channel.
.P
.TP
type 0: single output
A single output pin, \fBpwm\fR, whose duty cycle is determined by the
input value for positive inputs, and which is off (or at \fBmin\-dc\fR)
for negative inputs.  Suitable for single ended circuits.
.TP
type 1: pwm/direction
Two output pins, \fBpwm\fR and \fBdir\fR.  The duty cycle on \fBpwm\fR
varies as a function of the input value.  \fBdir\fR is low for positive
inputs and high for negative inputs.
.TP
type 2: up/down
Two output pins, \fBup\fR and \fBdown\fR.  For positive inputs, the
PWM/PDM waveform appears on \fBup\fR, while \fBdown\fR is low.  For
negative inputs, the waveform appears on \fBdown\fR, while \fBup\fR
is low.  Suitable for driving the two sides of an H-bridge to generate
a bipolar output.

.SH FUNCTIONS
.TP 
\fBpwmgen.make\-pulses \fR(no floating-point)
Generates the actual PWM waveforms, using information computed by
\fBupdate\fR.  Must be called as frequently as possible, to maximize
the attainable PWM frequency and resolution, and minimize jitter.
Operates on all channels at once.
.TP
\fBpwmgen.update \fR(uses floating point)
Accepts an input value, performs scaling and limit checks, and converts
it into a form usable by \fBmake\-pulses\fR for PWM/PDM generation.  Can
(and should) be called less frequently than \fBmake\-pulses\fR.  Operates
on all channels at once.

.SH PINS
.TP
\fBpwmgen.\fIN\fB.enable\fR bit in
Enables PWM generator \fIN\fR - when false, all \fBpwmgen.\fIN\fR output
pins are low.
.TP
\fBpwmgen.\fIN\fB.value\fR float in
Commanded value.  When \fBvalue\fR = 0.0, duty cycle is 0%, and when
\fBvalue\fR = \(+-\fBscale\fR, duty cycle is \(+- 100%. (Subject to
\fBmin\-dc\fR and \fBmax\-dc\fR limitations.)
.TP
\fBpwmgen.\fIN\fB.pwm\fR bit out (output types 0 and 1 only)
PWM/PDM waveform.
.TP
\fBpwmgen.\fIN\fB.dir\fR bit out (output type 1 only)
Direction output: low for forward, high for reverse.
.TP
\fBpwmgen.\fIN\fB.up\fR bit out (output type 2 only)
PWM/PDM waveform for positive input values, low for negative inputs.
.TP
\fBpwmgen.\fIN\fB.down\fR bit out (output type 2 only)
PWM/PDM waveform for negative input values, low for positive inputs.
.TP
\fBpwmgen.\fIN\fB.curr\-dc\fR float out
The current duty cycle, after all scaling and limits have been applied.
Range is from \-1.0 to +1.0.
.TP
\fBpwmgen.\fIN\fB.max\-dc\fR float in/out
The maximum duty cycle.  A value of 1.0 corresponds to 100%.  This can
be useful when using transistor drivers with bootstrapped power supplies,
since the supply requires some low time to recharge.
.TP
\fBpwmgen.\fIN\fB.min\-dc\fR float in/out
The minimum duty cycle.  A value of 1.0 corresponds to 100%.  Note that
when the pwm generator is disabled, the outputs are constantly low,
regardless of the setting of \fBmin\-dc\fR.
.TP
\fBpwmgen.\fIN\fB.scale\fR float in/out
.TQ
\fBpwmgen.\fIN\fB.offset\fR float in/out
These parameters provide a scale and offset from the \fBvalue\fR pin to the
actual duty cycle.  The duty cycle is calculated according to \fIdc =
(value/scale) + offset\fR, with 1.0 meaning 100%.
.TP
\fBpwmgen.\fIN\fB.pwm\-freq\fR float in/out
PWM frequency in Hz.  The upper limit is half of the frequency at which
\fBmake\-pulses\fR is invoked, and values above that limit will be changed
to the limit.  If \fBdither\-pwm\fR is false, the value will be changed to
the nearest integer submultiple of the \fBmake\-pulses\fR frequency.  A
value of zero produces Pulse Density Modulation instead of Pulse Width
Modulation.
.TP
\fBpwmgen.\fIN\fB.dither\-pwm\fR bit in/out
Because software-generated PWM uses a fairly slow timebase (several to many
microseconds), it has limited resolution.  For example, if \fBmake\-pulses\fR
is called at a 20KHz rate, and \fBpwm\-freq\fR is 2KHz, there are only 10
possible duty cycles.  If \fBdither\-pwm\fR is false, the commanded duty cycle
will be rounded to the nearest of those values.  Assuming \fBvalue\fR remains
constant, the same output will repeat every PWM cycle.  If \fBdither\-pwm\fR is
true, the output duty cycle will be dithered between the two closest values,
so that the long-term average is closer to the desired level.  \fBdither\-pwm\fR
has no effect if \fBpwm\-freq\fR is zero (PDM mode), since PDM is an inherently
dithered process.
.TH Rose Engine Kinematics "9" "LinuxCNC Documentation" "Kinematics Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

rosekins \- Kinematics for a rose engine

.SH SYNOPSIS
.HP
.B loadrt rosekins

.SH KINEMATICS
   joint_0 linear, transverse   (perpendicular to spindle)
   joint_1 linear, longitudinal (parallel to spindle identity to z)
   joint_2 rotary, spindle      (workholding, not tool holding, e.g.
                                 not a highspeed spindle)

.SH PINS
.TP
.B rosekins.revolutions\fR float out
Count of crossings of the negative X axis.  Clockwise crossings
increment revolutions by 1, Counterclockwise crossings decrement by 1

.TP
.B rosekins.theta_degrees\fR float out
Principal value for arctan(Y/X)

.TP
.B rosekins.bigtheta_degrees\fR float out
Accumulated angle (theta + revolutions * 360)

.SH NOTES

Theta is the principal value of arctan(Y/X).  Joint_2 angle values are
not limited to principal values of arctan(Y/X) but accumulate
continuously as the spindle is rotated.  Hal pins are provided for
the principal value and a count of the number of revolutions.

The transverse motion is exactly perpendicular to the spindle.  In a
traditional rose engine, the transverse motion is created by \'rocking\'
the headstock about a pivot.  A typical pivot length combined with the
limited amount of X travel in a real machine make the perpendicular
approximation a reasonable model.
.so man9/kins.9
.\" Copyright (c) 2006 John Kasunich
.\"                (jmkasunich AT users DOT sourceforge DOT net)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
.\" USA.
.\"
.\"
.\"
.TH SAMPLER "9"  "2006-11-18" "LinuxCNC Documentation" "HAL User's Manual"
.SH NAME
sampler \- sample data from HAL in real time
.SH SYNOPSIS
.B loadrt sampler
.BI depth= depth1[,depth2...]
.BI cfg= string1[,string2...]

.SH DESCRIPTION
.B sampler
and
.BR halsampler (1)
are used together to sample HAL data in real time and store it in a file.
.B sampler
is a realtime HAL component that exports HAL pins and creates a FIFO in shared memory.  It then begins sampling data from the HAL and storing it to the FIFO.
.B halsampler
is a user space program that copies data from the FIFO to stdout, where it can
be redirected to a file or piped to some other program.

.SH OPTIONS
.TP
.BI depth= depth1[,depth2...]
sets the depth of the realtime->user FIFO that
.B sampler
creates to buffer the realtime data.  Multiple values of
.I depth
(separated by commas) can be specified if you need more than one FIFO
(for example if you want to sample data from two different realtime threads).
.TP
.BI cfg= string1[,string2...]
defines the set of HAL pins that
.B sampler
exports and later samples data from.  One 
.I string
must be supplied for each FIFO, separated by commas.
.B sampler
exports one pin for each character in
.I string.
Legal characters are:
.IP "" 7
.B F, f
(float pin)
.IP "" 7
.B B, b
(bit pin)
.IP "" 7
.B S, s
(s32 pin)
.IP "" 7
.B U, u
(u32 pin)

.SH FUNCTIONS
.TP
.BI sampler. N
One function is created per FIFO, numbered from zero.

.SH PINS
.TP
\fBsampler.\fIN\fB.pin.\fIM\fR input
Pin for the data that will wind up in column
.I M
of FIFO
.I N
(and in column
.I M
of the output file).  The pin type depends on the config string.
.TP
\fBsampler.\fIN\fB.curr\-depth\fR s32 output
Current number of samples in the FIFO.  When this reaches
.I depth
new data will begin overwriting old data, and some samples
will be lost.
.TP
\fBsampler.\fIN\fB.full\fR bit output
TRUE when the FIFO
.I N
is full, FALSE when there is room for another sample.
.TP
\fBsampler.\fIN\fB.enable\fR bit input
When TRUE, samples are captured and placed in FIFO \fIN\fR,
when FALSE, no samples are acquired.  Defaults to TRUE.

.SH PARAMETERS
.TP
\fBsampler.\fIN\fB.overruns\fR s32 read/write
The number of times that
.B sampler
has tried to write data to the HAL pins but found no room in the FIFO.  It increments whenever
.B full
is true, and can be reset by the
.B setp
command.

.TP
\fBsampler.\fIN\fB.sample\-num\fR s32 read/write
A number that identifies the sample.  It is automatically incremented for each
sample, and can be reset using the
.B setp
command.  The sample number can optionally be printed in the first column of the output from
.BR halsampler ,
using the
.I \-t
option. (see
.BR "man 1 halsampler" )

.SH "SEE ALSO"
.BR halsampler (1)
.BR streamer (9)
.BR halstreamer (1)

.SH HISTORY

.SH BUGS

.SH AUTHOR
Original version by John Kasunich, as part of the LinuxCNC
project.  Improvements by several other members of
the LinuxCNC development team.
.SH REPORTING BUGS
Report bugs to jmkasunich AT users DOT sourceforge DOT net
.SH COPYRIGHT
Copyright \(co 2006 John Kasunich.
.br
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.so man9/kins.9
\# Author Andy Pugh
\# Issued under the terms of the GPL v2 License or any later version
.TH SETSERIAL "9" "2012-10-28" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
setsserial - a utility for setting Smart Serial NVRAM parameters. 

.B NOTE: This rather clunky utility is no longer needed except for
flashing new smart-serial remote firmware. Smart-serial remote
parameters can now be set in the HAL file in the normal way.

.SH SYNOPSIS
.HP
.B loadrt setsserial cmd="set hm2_8i20.001f.nvmaxcurrent 750"
.SH FUNCTIONS
.TP
None
.SH PINS
.TP
None
.SH USAGE

loadrt setsserial cmd="{command} {parameter/device} {value/filename}"

Commands available are \fBset\fR and \fBflash\fR.

This utility should be used under halcmd, without LinuxCNC running or any
realtime threads running. 

A typical command sequence would be:

 halrun
 loadrt hostmot2 use_serial_numbers=1
 loadrt hm2_pci config="firmware=hm2/5i23/svss8_8.bit"
 show param
 loadrt setsserial cmd="set hm2_8i20.001f.nvmaxcurrent 750"
 exit
 
This example uses the option to have the hal pins and parameters labelled by 
the serial number of the remote. This is not necessary but can reduce the scope
for confusion. (The serial number is normally on a sticker on the device.) 

The next line loads the hm2_pci driver in the normal way. The hm2_7i43 driver
should work equally well, as should any future 7i80 driver. 
If the card has already been strted up and a firmware has been loaded, then 
the config string may be omitted. 

"show param" is optional, but provides a handy list of all the devices and 
parameters. It also shows the current values of the parameters which can be 
useful for determining scaling. u32 pin values are always shown in hex, but new
values can be entered in decimal or hex. Use the Ox123ABC format to enter a hex
value. 

The next line invokes setsserial. This is run in a slightly strange way in order
to have kernel-level access to a live Hostmot2 config. It is basically a 
HAL module that always fails to load. This may lead to error messages being
printed to the halcmd prompt. These can often be ignored. 
All the real feedback is via the dmesg command. It is suggested to have a second
terminal window open to run dmesg after each command. 

On exiting there will typically be a further error message related to the driver
failing to unload setsserial. This can be ignored.

The parameter changes will not show up until the drivers are reloaded.
//TODO// Add a "get" command to avoid this problem. 

.B Flashing Firmware
To flash new firmware to an FPGA card such as the 5i25 or 5i20 the "mesaflash" 
utility should be used. Setsserial is only useful for changing/updating the
firmare on smart-serial remote such as the 8i20. 
The firmware should be placed somewhere in the /lib/firmware/hm2 tree, where the
Linux firmware loading macros can find it. 

The flashing routine operates in a realtime thread, and can only send prompts
to the user through the kernel log (dmesg). It is most convenient to open two
terminal windows, one for command entry and one to monitor progress. 

In the first terminal enter

tail \-f /var/log/kern.log

This terminal will now display status information.

The second window will be used to enter the commands. It is important that
LinuxCNC and/or HAL are not already loaded when the process is started.  
To flash new firmware it is necessary to move a jumper on the smart-serial
remote drive and to switch smart-serial communication to a slower baudrate.  

A typical command sequence is then
 halrun
 loadrt hostmot2 sserial_baudrate=115200
 loadrt hm2_pci config="firmware=hm2/5i23/svss8_8.bit"
 loadrt setsserial cmd="flash hm2_5i23.0.8i20.0.1 hm2/8i20/8i20T.BIN"
 exit
 
It is not necessary (or useful) to specify a config string in a system using the
5i25 or 6i25 cards. 

Note that it is necessary to exit halrun and unload the realtime environment
before flashing the next card (exit)

The correct sserial channel name to use can be seen in the dmesg output in the
feedback terminal after the loadrt hm2_pci step of the sequence. 

.SH LICENSE

GPL
.TH SIGGEN "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
siggen \- signal generator
.SH SYNOPSIS
\fBloadrt siggen [num_chan=\fInum\fB | names=\fIname1\fB[,\fIname2...\fB]]



.SH DESCRIPTION
\fBsiggen\fR is a signal generator that can be used for testing and
other applications that need simple waveforms.  It produces sine,
cosine, triangle, sawtooth, and square waves of variable frequency,
amplitude, and offset, which can be used as inputs to other HAL
components.

.P
\fBsiggen\fR supports a maximum of sixteen channels.  The number of
channels actually loaded is set by the \fBnum_chan\fR argument when
the module is loaded.  Alternatively, specify \fBnames=\fR and unique names
separated by commas.
.P
The \fBnum_chan=\fR and \fBnames=\fR specifiers are mutually exclusive.
If neither \fBnum_chan=\fR nor \fBnames=\fR are specified, the default
value is one.

.SH NAMING
The names for pins, parameters, and functions are prefixed as:
  \fBsiggen.N.\fR for N=0,1,...,num\-1 when using \fBnum_chan=num\fR
  \fBnameN.\fR for nameN=name1,name2,... when using \fBnames=name1,name2,...\fR

The \fBsiggen.N.\fR format is shown in the following descriptions.


.SH FUNCTIONS
.TP 
\fBsiggen.\fIN\fB.update\fR (uses floating-point)
Updates output pins for signal generator \fIN\fR.  Each time it is
called it calculates a new sample.  It should be called many times
faster than the desired signal frequency, to avoid distortion and
aliasing.

.SH PINS

.TP
\fBsiggen.\fIN\fB.frequency\fR float in
The output frequency for signal generator \fIN\fR, in Hertz.  The default
value is 1.0 Hertz.
.TP
\fBsiggen.\fIN\fB.amplitude\fR float in
The output amplitude for signal generator \fIN\fR.  If \fBoffset\fR is
zero, the outputs will swing from \-\fBamplitude\fR to +\fBamplitude\fR.
The default value is 1.00.
.TP
\fBsiggen.\fIN\fB.offset\fR float in
The output offset for signal generator \fIN\fR.  This value is added
directly to the output signal.  The default value is zero.
.TP
\fBsiggen.\fIN\fB.reset\fR bit in
Resets output pins to pretermined states:
  sine      0
  sawtooth  0
  square   -1 * amplitude
  cosine   -1 * amplitude
  triangle -1 * amplitude
.TP
\fBsiggen.\fIN\fB.clock\fR bit out
The clock output.  Bit type clock signal output at the commanded
frequency.
.TP
\fBsiggen.\fIN\fB.square\fR float out
The square wave output.  Positive while \fBtriangle\fR and \fBcosine\fR
are ramping upwards, and while \fBsine\fR is negative.
.TP
\fBsiggen.\fIN\fB.sine\fR float out
The sine output.  Lags \fBcosine\fR by 90 degrees.
.TP
\fBsiggen.\fIN\fB.cosine\fR float out
The cosine output.  Leads \fBsine\fR by 90 degrees.
.TP
\fBsiggen.\fIN\fB.triangle\fR float out
The triangle wave output.  Ramps up while \fBsquare\fR is positive, and
down while \fBsquare\fR is negative.  Reaches its positive and negative
peaks at the same time as \fBcosine\fR.
.TP
\fBsiggen.\fIN\fB.sawtooth\fR float out
The sawtooth output.  Ramps upwards to its positive peak, then instantly
drops to its negative peak and starts ramping again.  The drop occurs
when \fBtriangle\fR and \fBcosine\fR are at their positive peaks, and
coincides with the falling edge of \fBsquare\fR.

.SH PARAMETERS
.P
None

.TH SIM_ENCODER "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
sim_encoder \- simulated quadrature encoder
.SH SYNOPSIS
\fBloadrt sim_encoder [num_chan=\fInum\fB | names=\fIname1\fB[,\fIname2...\fB]]



.SH DESCRIPTION
\fBsim_encoder\fR can generate quadrature signals as if from an encoder.
It also generates an index pulse once per revolution.  It is mostly used
for testing and simulation, to replace hardware that may not be available.
It has a limited maximum frequency, as do all software based pulse
generators.

.P
\fBsim_encoder\fR supports a maximum of eight channels.  The number of
channels actually loaded is set by the \fBnum_chan=\fR argument when
the module is loaded.  Alternatively, specify \fBnames=\fR and unique names
separated by commas.

.P
The \fBnum_chan=\fR and \fBnames=\fR specifiers are mutually exclusive.
If neither \fBnum_chan=\fR nor \fBnames=\fR are specified, the default
value is one.

.SH FUNCTIONS
.TP 
\fBsim\-encoder.make\-pulses\fR (no floating-point)
Generates the actual quadrature and index pulses.  Must be called as
frequently as possible, to maximize the count rate and minimize jitter.
Operates on all channels at once.
.TP 
\fBsim\-encoder.update\-speed\fR (uses floating-point)
Reads the \fBspeed\fR command and other parameters and converts the
data into a form that can be used by \fBmake\-pulses\fR.  Changes take
effect only when \fBupdate\-speed\fR runs.  Can (and should) be called
less frequently than \fBmake\-pulses\fR.  Operates on all channels at
once.

.SH NAMING
The names for pins and parameters are prefixed as:
  \fBsim\-encoder.N.\fR for N=0,1,...,num\-1 when using \fBnum_chan=num\fR
  \fBnameN.\fR for nameN=name1,name2,... when using \fBnames=name1,name2,...\fR

The \fBsim\-encoder.N.\fR format is shown in the following descriptions.


.SH PINS

.TP
\fBsim\-encoder.\fIN\fB.phase\-A\fR bit out
One of the quadrature outputs.
.TP
\fBsim\-encoder.\fIN\fB.phase\-B\fR bit out
The other quadrature output.
.TP
\fBsim\-encoder.\fIN\fB.phase\-Z\fR bit out
The index pulse.
.TP
\fBsim\-encoder.\fIN\fB.speed\fR float in
The desired speed of the encoder, in user units per per second.  This
is divided by \fBscale\fR, and the result is used as the encoder speed
in revolutions per second.

.SH PARAMETERS
.TP
\fBsim\-encoder.\fIN\fB.ppr\fR u32 rw
The pulses per revolution of the simulated encoder.  Note that this
is pulses, not counts, per revolution.  Each pulse or cycle from the
encoder results in four counts, because every edge is counted.
Default value is 100 ppr, or 400 counts per revolution.
.TP
\fBsim\-encoder.\fIN\fB.scale\fR float rw
Scale factor for the \fBspeed\fR input.  The \fBspeed\fR value is divided
by \fBscale\fR to get the actual encoder speed in revolutions per second.
For example, if \fBscale\fR is set to 60, then \fBspeed\fR is in revolutions
per minute (RPM) instead of revolutions per second.  The default value
is 1.00.

\# Author Andy Pugh
\# Issued under the terms of the GPL v2 License or any later version
.TH SSERIAL "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..
.SH NAME

hostmot2 - Smart Serial LinuxCNC HAL driver for the Mesa Electronics HostMot2 
Smart-Serial remote cards
.SH SYNOPSIS
The Mesa Smart-Serial interface is a 2.5Mbs proprietary interface between the
Mesa Anything-IO cards and a range of subsidiary devices termed "smart-serial 
remotes".
The remote cards perform a variety of functions, but typically they combine 
various classes of IO. 
The remot cards are self-configuring, in that they tell the main LinuxCNC 
Hostmot2 driver what their pin functions are and what they should be named. 

Many sserial remotes offer different pinouts depending on the mode they are 
started up in. This is set using the sserial_port_N= option in the 
hm2_pci modparam. See the hostmot2 manpage for further details. 

It is likely that this documentation will be permanently out of date. 

Each Anything-IO board can attach up to 8 sserial remotes to each header 
(either the 5-pin headers on the 5i20/5i22/5i23/7i43 or the 25-pin connectors on
the 5i25, 6i25 and 7i80). The remotes are grouped into "ports" of up to 8
"channels". Typically each header will be a single 8 channel port, but this is
not necessarily always the case. 

.SH PORTS
In addition to the per-channel/device pins detailed below there are three
per-port pins and three parameters.

Pins:

(bit, in) .sserial.port\-N.run: Enables the specific Smart Serial module.
Setting this pin low will disable all boards on the port and puts the port in a
pass-through mode where device parameter setting is possible. It is necessary
to toggle the state of this pin if there is a requirement to alter a
remote parameter on a live system.
This pin defaults to TRUE and can be left unconnected. However, toggling the pin
low-to-high will re-enable a faulted drive so the pin could usefully be
connected to the iocontrol.0.user\-enable\-out pin.

(u32, ro) .run_state: Shows the state of the sserial communications state-machine.
This pin will generally show a value of 0x03 in normal operation, 0x07 in
setup mode and 0x00 when the "run" pin is false.

(u32, ro) .error\-count: Indicates the state of the Smart Serial error handler,
see the parameters sections for more details. 

Parameters:

(u32 r/w) .fault\-inc: Any over-run or handshaking error in the SmartSerial
communications will increment the .fault\-count pin by the amount specified by
this parameter. Default = 10.

(u32 r/w) .fault\-dec: Every successful read/write cycle decrements the fault
counter by this amount. Default = 1.

(u32 r/w) .fault\-lim: When the fault counter reaches this threshold the Smart
Serial interface on the corresponding port will be stopped and an error printed 
in dmesg. Together these three pins allow for control over the degree of fault-
tolerance allowed in the interface. The default values mean that if more than
one transaction in ten fails, more than 20 times, then a hard error will be
raised. If the increment were to be set to zero then no error would ever be
raised, and the system would carry on regardless. Conversely setting decrement to 
zero, threshold to 1 and limit to 1 means that absolutely no errors will be
tolerated. (This structure is copied directly from vehicle ECU practice)

Any other parameters than the ones above are created by the card istelf from
data in the remote firmware. They may be set in the HAL file using "setp" in
the usual way.

NOTE: Because a Smart-Serial remote can only communicate non-process data
to the host card in setup mode it is necessary to stop and re-start the
smart-serial port associated with the card to alter the value of a parameter.

HALSO NOTE: in the case of parameters beginning with "nv" (which are stored
in non-volatile memory) the effect will not be seen until after the next
power cycle of the drive.

Unchanged values will not be re-written so it is safe to leave the
"setp" commands in the HAL file or delete them as you see fit.

.SH DEVICES
The other pins and parameters created in HAL depend on the devices detected.
The following list of Smart Serial devices is by no means exhaustive. 

.TP
.SH 8i20
The 8i20 is a 2.2kW three-phase drive for brushless DC motors and AC servo
motors.
8i20 pins and parameters have names like
"hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.8i20.\fI<PortNum>\fR.\fI<ChanNum>\fR.\fI<Pin>\fR", for example
"hm2_5i23.0.8i20.1.3.current" would set the phase current for the drive
connected to the fourth channel of the second sserial port of the first 5i23
board. Note that the sserial ports do not necessarily correlate in layout or
number to the physical ports on the card.

Pins:

.TP
(float in) angle
The rotor angle of the motor in fractions of a full
\fBphase\fR revolution. An angle of 0.5 indicates that the motor is half a turn
/ 180 degrees / \[*p] radians from the zero position. The zero position is taken to
be the position that the motor adopts under no load with a poitive voltage
applied to the A (or U) phase and both B and C (or V and W) connected to \-V or
0V. A 6 pole motor will have 3 zero positions per physical rotation. Note that
the 8i20 drive automatically adds the phase lead/lag angle, and that this pin
should see the raw rotor angle. There is a HAL module (bldc) which handles the
complexity of differing motor and drive types.

.TP
(float, in) current
The phase current command to the drive. This is scaled
from \-1 to +1 for forwards and reverse maximum currents. The absolute value of
the current is set by the max_current parameter.

.TP
(float, ro) bus-voltage
The drive bus voltage in V. This will tend to show 25.6V
when the drive is unpowered and the drive will not operate below about 50V.

.TP
(float, ro) temp
The temperature of the driver in degrees C.

.TP
(u32, ro) comms
The communication status of the drive. See the manual for
more details.

.TP 
(bit, ro) status and fault. 
The following fault/status bits are exported. For further details see the
8i20 manual. 
fault.U\-current / fault.U\-current\-not
fault.V\-current / fault.V\-current\-not
fault.W\-current / fault.W\-current\-not
fault.bus\-high /  fault.bus\-high\-not
fault.bus\-overv / fault.bus\-overv\-not
fault.bus\-underv / fault.bus\-underv\-not
fault.framingr / fault.framingr\-not
fault.module / fault.module\-not
fault.no\-enable / fault.no\-enable\-not
fault.overcurrent / fault.overcurrent\-not
fault.overrun / fault.overrun\-not
fault.overtemp / fault.overtemp\-not
fault.watchdog / fault.watchdog\-not

status.brake\-old / status.brake\-old\-not
status.brake\-on / status.brake\-on\-not
status.bus\-underv / status.bus\-underv\-not
status.current\-lim / status.current\-lim\-no
status.ext\-reset / status.ext\-reset\-not
status.no\-enable / status.no\-enable\-not
status.pid\-on / status.pid\-on\-not
status.sw\-reset / status.sw\-reset\-not
status.wd\-reset / status.wd\-reset\-not

.TP
Parameters:
The following parameters are exported. See the pdf documentation downloadable
from Mesa for further details

 hm2_5i25.0.8i20.0.1.angle\-maxlim
 hm2_5i25.0.8i20.0.1.angle\-minlim
 hm2_5i25.0.8i20.0.1.angle\-scalemax
 hm2_5i25.0.8i20.0.1.current\-maxlim
 hm2_5i25.0.8i20.0.1.current\-minlim
 hm2_5i25.0.8i20.0.1.current\-scalemax
 hm2_5i25.0.8i20.0.1.nvbrakeoffv
 hm2_5i25.0.8i20.0.1.nvbrakeonv
 hm2_5i25.0.8i20.0.1.nvbusoverv
 hm2_5i25.0.8i20.0.1.nvbusundervmax
 hm2_5i25.0.8i20.0.1.nvbusundervmin
 hm2_5i25.0.8i20.0.1.nvkdihi
 hm2_5i25.0.8i20.0.1.nvkdil
 hm2_5i25.0.8i20.0.1.nvkdilo
 hm2_5i25.0.8i20.0.1.nvkdp
 hm2_5i25.0.8i20.0.1.nvkqihi
 hm2_5i25.0.8i20.0.1.nvkqil
 hm2_5i25.0.8i20.0.1.nvkqilo
 hm2_5i25.0.8i20.0.1.nvkqp
 hm2_5i25.0.8i20.0.1.nvmaxcurrent
 hm2_5i25.0.8i20.0.1.nvrembaudrate
 hm2_5i25.0.8i20.0.1.swrevision
 hm2_5i25.0.8i20.0.1.unitnumber

.TP
(float, rw) max_current
Sets the maximum drive current in Amps. The default
value is the maximum current programmed into the drive EEPROM. The value must be
positive, and an error will be raised if a current in excess of the drive
maximum is requested.

.TP
(u32, ro) serial_number
The serial number of the connected drive. This is
also shown on the label on the drive.
.TP
.SH 7i64
The 7i64 is a 24-input 24-output IO card.
7i64 pins and parameters have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.7i64.
<PortNum>.<ChanNum>.<Pin>", for example hm2_5i23.0.7i64.1.3.output\-01

Pins:
(bit, in) 7i64.0.0.output\-NN: Writing a 1 or TRUE to this pin will enable output
driver NN. Note that the outputs are drivers (switches) rather than voltage
outputs. The LED adjacent to the connector on the board shows the status.
The output can be inverted by setting a parameter.

(bit, out) 7i64.0.0.input\-NN: The value of input NN. Note that the inputs are
isolated and both pins of each input must be connected (typically to signal and
the ground of the signal. This need not be the ground of the board.)

(bit, out)  7i64.0.0.input\-NN\-not: An inverted copy of the corresponding input.

(float, out) 7i64.0.0.analog0 & 7i64.0.0.analog1: The two analogue inputs 
(0 to 3.3V) on the board.

Parameters:
(bit, rw) 7i64.0.0.output\-NN\-invert: Setting this parameter to 1 / TRUE will invert
the output value, such that writing 0 to .gpio.NN.out will enable the output
and vice-versa.

.TP
.SH 7i76
The 7i76 is not only a smart-serial device. It also serves as a breakout for a
number of other Hostmot2 functions. There are connections for 5 step generators
(for which see the main hostmot2 manpage). The stepgen pins are associated with 
the 5i25 (hm2_5i25.0.stepgen.00....) whereas the smart-serial pins are 
associated with the 7i76 (hm2_5i25.0.7i76.0.0.output\-00).

Pins:

(float out) .7i76.0.0.analogN (modes 1 and 2 only) Analogue input values. 

(float out) .7i76.0.0.fieldvoltage (mode 2 only) Field voltage monitoring pin. 

(bit in) .7i76.0.0.spindir: This pin provides a means to drive the spindle VFD
direction terminals on the 7i76 board. 

(bit in) .7i76.0.0.spinena: This pin drives the spindle-enable terminals on the 
7i76 board.

(float in) .7i76.0.0.spinout: This controls the analogue output of the 7i76. 
This is intended as a speed control signal for a VFD. 

(bit out) .7i76.0.0.output\-NN: (NN = 0 to 15). 16 digital outputs. The sense of
the signal can be set via a parameter

(bit out) .7i76.0.0.input\-NN: (NN = 0 to 31) 32 digital inputs.

(bit in) .7i76.0.0.input\-NN\-not: (NN = 0 to 31) An inverted copy of the inputs
provided for convenience. The two complementary pins may be connected to 
different signal nets. 

Parameters:

(u32 ro) .7i76.0.0.nvbaudrate: Indicates the vbaud rate. This probably should 
not be altered.

(u32 ro) .7i76.0.0.nvunitnumber: Indicates the serial number of the device and
should match a sticker on the card. This can be useful for working out which
card is which.

(u32 ro) .7i76.0.0.nvwatchdogtimeout: The sserial remote watchdog timeout. This
is separate from the Anything-IO card timeout. This is unlikley to need to be 
changed. 

(bit rw) .7i76.0.0.output\-NN\-invert: Invert the sense of the corresponding
output pin. 

(bit rw) .7i76.0.0.spindir\-invert: Invert the senseof the spindle direction pin.

(bit rw) .7i76.0.0.spinena\-invert: Invert the sense of the spindle\-enable pin.

(float rw) .7i76.0.0.spinout\-maxlim: The maximum speed request allowable

(float rw) .7i76.0.0.spinout\-minlim: The minimum speed request.

(float rw) .7i76.0.0.spinout\-scalemax: The spindle speed scaling. This is the
speed request which would correspond to full-scale output from the spindle 
control pin. For example with a 10V drive voltage and a 10000rpm scalemax a
value of 10,000 rpm on the spinout pin would produce 10V output. However, if 
spinout\-maxlim were set to 5,000 rpm then no voltage above 5V would be output.

(u32 ro) .7i76.0.0.swrevision: The onboard firmware revision number. 
Utilities (man setsserial for details) exist to update and change this firmware.

.TP
.SH 7i77
The 7i77 is an 6-axis servo control card. The analogue outputs are smart-serial
devices but the encoders are conventional hostmot2 encoders and further details 
of them may be found in the hostmot2 manpage. 

Pins:
(bit out) .7i77.0.0.input\-NN: (NN = 0 to 31) 32 digital inputs.

(bit in) .7i77.0.0.input\-NN\-not: (NN = 0 to 31) An inverted copy of the inputs
provided for convenience. The two complementary pins may be connected to
different signal nets.

(bit out) .7i77.0.0.output\-NN: (NN = 0 to 15). 16 digital outputs. The sense of
the signal can be set via a parameter

(bit in) .7i77.0.0.spindir: This pin provides a means to drive the spindle VFD
direction terminals on the 7i76 board.

(bit in) .7i77.0.0.spinena: This pin drives the spindle-enable terminals on the 
7i76 board.

(float in) .7i77.0.0.spinout: This controls the analog output of the 7i77.
This is intended as a speed control signal for a VFD. 

(bit in) .7i77.0.1.analogena: This pin drives the analog enable terminals on the
7i77 board.

(float in) .7i77.0.1.analogoutN: (N = 0 to 5) This controls the analog output
of the 7i77.

Parameters:
(bit rw) .7i77.0.0.output\-NN\-invert: Invert the sense of the corresponding
output pin.

(bit rw) .7i77.0.0.spindir\-invert: Invert the sense of the spindle direction pin.

(bit rw) .7i77.0.0.spinena\-invert: Invert the sense of the spindle\-enable pin.

(float rw) .7i77.0.0.spinout\-maxlim: The maximum speed request allowable

(float rw) .7i77.0.0.spinout\-minlim: The minimum speed request.

(float rw) .7i77.0.0.spinout\-scalemax: The spindle speed scaling. This is the
speed request which would correspond to full-scale output from the spindle
control pin. For example with a 10V drive voltage and a 10000rpm scalemax a
value of 10,000 rpm on the spinout pin would produce 10V output. However, if
spinout\-maxlim were set to 5,000 rpm then no voltage above 5V would be output.

(float rw) .7i77.0.0.analogoutN\-maxlim: (N = 0 to 5) The maximum speed request
allowable

(float rw) .7i77.0.0.analogoutN\-minlim: (N = 0 to 5) The minimum speed request.

(float rw) .7i77.0.0.analogoutN\-scalemax: (N = 0 to 5) The analog speed scaling.
This is the speed request which would correspond to full-scale output from the
spindle control pin. For example with a 10V drive voltage and a 10000rpm scalemax a
value of 10,000 rpm on the spinout pin would produce 10V output. However, if
spinout\-maxlim were set to 5,000 rpm then no voltage above 5V would be output.


.TP
.SH 7i69
The 7i69 is a 48 channel digital IO card. It can be configured in four
different modes:
Mode 0 B 48 pins bidirectional (all outputs can be set high then driven low to 
work as inputs)
 Mode 1 48 pins, input only 
 Mode 2 48 pins, all outputs
 Mode 3 24 inputs and 24 outputs. 

Pins: 
(bit in) .7i69.0.0.output\-NN: Digital output. Sense can be inverted with
the corresponding Parameter

(bit out) .7i69.0.0.input\-NN: Digital input

(bit out) .7i69.0.0.input\-NN\-not: Digital input, inverted.

Parameters:

(u32 ro) .7i69.0.0.nvbaudrate: Indicates the vbaud rate. This probably should 
not be altered.

(u32 ro) .7i69.0.0.nvunitnumber: Indicates the serial number of the device and
should match a sticker on the card. This can be useful for working out which
card is which.

(u32 ro) .7i69.0.0.nvwatchdogtimeout: The sserial remote watchdog timeout. This
is separate from the Anything-IO card timeout. This is unlikley to need to be 
changed. 

(bit rw) .7i69.0.0.output\-NN\-invert: Invert the sense of the corresponding
output pin. 

(u32 ro) .7i69.0.0.swrevision: The onboard firmware revision number. 
Utilities exist to update and change this firmware.

.TP
.SH 7i70

The 7I70 is a remote isolated 48 input card. The 7I70 inputs sense positive 
inputs relative to a common field ground. Input impedance is 10K Ohms and input 
voltage can range from 5VDC to 32VDC. All inputs have LED status indicators. 
The input common field ground is galvanically isolated from the communications 
link.

The 7I70 has three software selectable modes. These different modes select 
different sets of 7I70 data to be transferred between the host and the 7I70 
during real time process data exchanges. For high speed applications, 
choosing the correct mode can reduced the data transfer sizes, resulting in 
higher maximum update rates.

 MODE 0 Input mode (48 bits input data only
 MODE 1 Input plus analog mode (48 bits input data plus 6 channels of analog data)
 MODE 2 Input plus field voltage
 
Pins: 

(float out) .7i70.0.0.analogN (modes 1 and 2 only) Analogue input values. 

(float out) .7i70.0.0.fieldvoltage (mode 2 only) Field voltage monitoring pin. 

(bit out) .7i70.0.0.input\-NN: (NN = 0 to 47) 48 digital inputs.

(bit in) .7i70.0.0.input\-NN\-not: (NN = 0 to 47) An inverted copy of the inputs
provided for convenience. The two complementary pins may be connected to 
different signal nets. 
 
Parameters:

(u32 ro) .7i70.0.0.nvbaudrate: Indicates the vbaud rate. This probably should 
not be altered.

(u32 ro) .7i70.0.0.nvunitnumber: Indicates the serial number of the device and
should match a sticker on the card. This can be useful for working out which
card is which.

(u32 ro) .7i70.0.0.nvwatchdogtimeout: The sserial remote watchdog timeout. This
is separate from the Anything-IO card timeout. This is unlikley to need to be 
changed. 

(u32 ro) .7i69.0.0.swrevision: The onboard firmware revision number. 
Utilities exist to update and change this firmware.

.TP
.SH 7i71

The 7I71 is a remote isolated 48 output card. The 48 outputs are 8VDC to 28VDC 
sourcing drivers (common + field power) with 300 mA maximum current capability. 
All outputs have LED status indicators.

The 7I71 has two software selectable modes. For high speed applications, 
choosing the correct mode can reduced the data transfer sizes, resulting in 
higher maximum update rates

 MODE 0 Output only mode (48 bits output data only) 
 MODE 1 Outputs plus read back field voltage


Pins: 

(float out) .7i71.0.0.fieldvoltage (mode 2 only) Field voltage monitoring pin. 

(bit out) .7i71.0.0.output\-NN: (NN = 0 to 47) 48 digital outputs. The sense may
be inverted by the invert parameter. 
 
Parameters:

(bit rw) .7i71.0.0.output\-NN\-invert: Invert the sense of the corresponding
output pin. 

(u32 ro) .7i71.0.0.nvbaudrate: Indicates the vbaud rate. This probably should 
not be altered.

(u32 ro) .7i71.0.0.nvunitnumber: Indicates the serial number of the device and
should match a sticker on the card. This can be useful for determining which
card is which.

(u32 ro) .7i71.0.0.nvwatchdogtimeout: The sserial remote watchdog timeout. This
is separate from the Anything-IO card timeout. This is unlikley to need to be 
changed. 

(u32 ro) .7i69.0.0.swrevision: The onboard firmware revision number. 
Utilities exist to update and change this firmware.

.TP
.SH 7i73
The 7I73 is a remote real time pendant or control panel interface. 

The 7I73 supports up to four 50KHz encoder inputs for MPGs, 8 digital inputs 
and 6 digital outputs and up to a 64 Key keypad. If a smaller keypad is used, 
more digital inputs and outputs become available. Up to eight 0.0V to 3.3V 
analog inputs are also provided.
The 7I73 can drive a 4 line 20 character LCD for local DRO applications.

The 7I73 has 3 software selectable process data modes. These different modes 
select different sets of 7I73 data to be transferred between the host and the 7
I73 during real time process data exchanges. For high speed applications, 
choosing the correct mode can reduced the data transfer sizes, resulting in 
higher maximum update rates
 MODE 0 I/O + ENCODER
 MODE 1 I/O + ENCODER +ANALOG IN
 MODE 2 I/O + ENCODER +ANALOG IN FAST DISPLAY

Pins:

(float out) .7i73.0.0.analoginN: Analogue inputs. Up to 8 channels may be 
available dependant on software and hardware configuration modes. 
(see the pdf manual downlaodable from www.mesanet.com)

(u32 in) .7i73.0.1.display (modes 1 and 2). Data for LCD display. This pin may
be conveniently driven by the HAL "lcd" component which allows the formatted
display of the values any number of HAL pins and textual content.


(u32 in) .7i73.0.1.display32 (mode 2 only). 4 bytes of data for LCD display. 
This mode is not supported by the HAL "lcd" component.

(s32 out) .7i73.0.1.encN: The position of the MPG encoder counters.

(bit out) .7i73.0.1.input\-NN: Up to 24 digital inputs (dependent on config)

(bit out) .7i73.0.1.input\-NN\-not: Inverted copy of the digital inputs

(bit in) .7i73.0.1.output\-NN: Up to 22 digital outputs (dependent on config)

Parameters: 

 (u32 ro) .7i73.0.1.nvanalogfilter:
 (u32 ro) .7i73.0.1.nvbaudrate
 (u32 ro) .7i73.0.1.nvcontrast
 (u32 ro) .7i73.0.1.nvdispmode
 (u32 ro) .7i73.0.1.nvencmode0
 (u32 ro) .7i73.0.1.nvencmode1
 (u32 ro) .7i73.0.1.nvencmode2
 (u32 ro) .7i73.0.1.nvencmode3
 (u32 ro) .7i73.0.1.nvkeytimer
 (u32 ro) .7i73.0.1.nvunitnumber
 (u32 ro) .7i73.0.1.nvwatchdogtimeout
 (u32 ro) .7i73.0.1.output\-00\-invert
 
 For further details of the use of the above see the Mesa manual.

(bit rw) .7i73.0.1.output\-01\-invert: Invert the corresponding output bit.

(s32 ro) .7i73.0.1.swrevision: The version of firmware installed.

TODO: Add 7i77, 7i66, 7i72, 7i83, 7i84, 7i87. 


.TH STEPGEN "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
stepgen \- software step pulse generation
.SH SYNOPSIS
\fBloadrt stepgen step_type=\fItype0\fR[,\fItype1\fR...] [\fBctrl_type=\fItype0\fR[,\fItype1\fR...]] [\fBuser_step_type=#,#\fR...]

.SH DESCRIPTION
\fBstepgen\fR is used to control stepper motors.  The maximum
step rate depends on the CPU and other factors, and is usually in the range
of 5KHz to 25KHz.  If higher rates are needed, a hardware step generator
is a better choice.
.P
\fBstepgen\fR has two control modes, which can be selected on a channel
by channel basis using \fBctrl_type\fR.  Possible values are "\fBp\fR"
for position control, and "\fBv\fR" for velocity control. The default
is position control, which drives the motor to a commanded position,
subject to acceleration and velocity limits.  Velocity control drives
the motor at a commanded speed, again subject to accel and velocity
limits.  Usually, position mode is used for machine axes.  Velocity mode
is reserved for unusual applications where continuous movement at some
speed is desired, instead of movement to a specific position.  (Note that
velocity mode replaces the former component \fBfreqgen\fR.)
.P
\fBstepgen\fR can control a maximum of 16 motors.  The number of
motors/channels actually loaded depends on the number of \fItype\fR values
given.  The value of each \fItype\fR determines the outputs for that channel.
Position or velocity mode can be individually selected for each channel.
Both control modes support the same 16 possible step types.
.P
By far the most common step type is '0', standard step and direction.  Others
include up/down, quadrature, and a wide variety of three, four, and five phase
patterns that can be used to directly control some types of motor windings.
(When used with appropriate buffers of course.)
.P
Some of the stepping types are described below, but for more details (including
timing diagrams) see the \fBstepgen\fR section of the HAL reference manual.
.TP
type 0: step/dir
Two pins, one for step and one for direction.  \fBmake\-pulses\fR must run at least twice for each step (once to set the step pin true, once to clear it).  This limits the maximum step rate to half (or less) of the rate that can be reached by types 2-14.  The parameters \fBsteplen\fR and \fBstepspace\fR can further lower the maximum step rate.  Parameters \fBdirsetup\fR and \fBdirhold\fR also apply to this step type.
.TP
type 1: up/down
Two pins, one for 'step up' and one for 'step down'.  Like type 0, \fBmake\-pulses\fR must run twice per step, which limits the maximum speed.
.TP
type 2: quadrature
Two pins, phase\-A and phase\-B.  For forward motion, A leads B.  Can advance by one step every time \fBmake\-pulses\fR runs.
.TP
type 3: three phase, full step
Three pins, phase\-A, phase\-B, and phase\-C.  Three steps per full cycle, then repeats.  Only one phase is high at a time - for forward motion the pattern is A, then B, then C, then A again.
.TP
type 4: three phase, half step
Three pins, phases A through C.  Six steps per full cycle.  First A is high alone, then A and B together, then B alone, then B and C together, etc.
.TP
types 5 through 8: four phase, full step
Four pins, phases A through D.  Four steps per full cycle.  Types 5 and 6 are suitable for use with unipolar steppers, where power is applied to the center tap of each winding, and four open-collector transistors drive the ends.  Types 7 and 8 are suitable for bipolar steppers, driven by two H-bridges.
.TP
types 9 and 10: four phase, half step
Four pins, phases A through D.  Eight steps per full cycle.  Type 9 is suitable for unipolar drive, and type 10 for bipolar drive.
.TP
types 11 and 12: five phase, full step
Five pins, phases A through E.  Five steps per full cycle.  See HAL reference manual for the patterns.
.TP
types 13 and 14: five phase, half step
Five pins, phases A through E.  Ten steps per full cycle.  See HAL reference manual for the patterns.
.TP
type 15: user-specified
This uses the waveform specified by the \fBuser_step_type\fR module parameter,
which may have up to 10 steps and 5 phases.
.SH FUNCTIONS
.TP 
\fBstepgen.make\-pulses \fR(no floating-point)
Generates the step pulses, using information computed by \fBupdate\-freq\fR.  Must be called as frequently as possible, to maximize the attainable step rate and minimize jitter.  Operates on all channels at once.
.TP
\fBstepgen.capture\-position \fR(uses floating point)
Captures position feedback value from the high speed code and makes it available on a pin for use elsewhere in the system.  Operates on all channels at once.
.TP
\fBstepgen.update\-freq \fR(uses floating point)
Accepts a velocity or position command and converts it into a form usable by \fBmake\-pulses\fR for step generation.  Operates on all
channels at once.

.SH PINS
.TP
\fBstepgen.\fIN\fB.counts\fR s32 out
The current position, in counts, for channel \fIN\fR.  Updated by
\fBcapture\-position\fR.
.TP
\fBstepgen.\fIN\fB.position\-fb\fR float out
The current position, in length units (see parameter \fBposition\-scale\fR).  Updated by \fBcapture\-position\fR. The resolution of \fBposition\-fb\fR is much finer than a single step.  If you need to see individual steps, use \fBcounts\fR.
.TP
\fBstepgen.\fIN\fB.enable\fR bit in
Enables output steps - when false, no steps are generated.
.TP
\fBstepgen.\fIN\fB.velocity\-cmd\fR float in (velocity mode only)
Commanded velocity, in length units per second (see parameter \fBposition\-scale\fR).
.TP
\fBstepgen.\fIN\fB.position\-cmd\fR float in (position mode only)
Commanded position, in length units (see parameter \fBposition\-scale\fB).
.TP
\fBstepgen.\fIN\fB.step\fR bit out (step type 0 only)
Step pulse output.
.TP
\fBstepgen.\fIN\fB.dir\fR bit out (step type 0 only)
Direction output: low for forward, high for reverse.
.TP
\fBstepgen.\fIN\fB.up\fR bit out (step type 1 only)
Count up output, pulses for forward steps.
.TP
\fBstepgen.\fIN\fB.down\fR bit out (step type 1 only)
Count down output, pulses for reverse steps.
.TP
\fBstepgen.\fIN\fB.phase\-A\fR thru \fBphase\-E\fR bit out (step types 2-14 only)
Output bits.  \fBphase\-A\fR and \fBphase\-B\fR are present for step types 2-14, \fBphase\-C\fR for types 3-14, \fBphase\-D\fR for types 5-14, and \fBphase\-E\fR for types 11-14.  Behavior depends on selected stepping type.

.SH PARAMETERS
.TP
\fBstepgen.\fIN\fB.frequency\fR float ro
The current step rate, in steps per second, for channel \fIN\fR.
.TP
\fBstepgen.\fIN\fB.maxaccel\fR float rw
The acceleration/deceleration limit, in length units per second squared.
.TP
\fBstepgen.\fIN\fB.maxvel\fR float rw
The maximum allowable velocity, in length units per second.  If the requested maximum velocity cannot be reached with the current combination of scaling and \fBmake\-pulses\fR thread period, it will be reset to the highest attainable value.
.TP
\fBstepgen.\fIN\fB.position\-scale\fR float rw
The scaling for position feedback, position command, and velocity command, in steps per length unit.
.TP
\fBstepgen.\fIN\fB.rawcounts\fR s32 ro
The position in counts, as updated by \fBmake\-pulses\fR.  (Note: this is updated more frequently than the \fBcounts\fR pin.)
.TP
\fBstepgen.\fIN\fB.steplen\fR u32 rw
The length of the step pulses, in nanoseconds.  Measured from rising edge to falling edge.
.TP
\fBstepgen.\fIN\fB.stepspace\fR u32 rw (step types 0 and 1 only) The minimum
space between step pulses, in nanoseconds.  Measured from falling edge to
rising edge.  The actual time depends on the step rate and can be much longer.
If \fBstepspace\fR is 0, then \fBstep\fR can be asserted every period.    This
can be used in conjunction with \fBhal_parport\fR's auto-resetting pins to
output one step pulse per period.  In this mode, \fBsteplen\fR must be set for
one period or less.
.TP
\fBstepgen.\fIN\fB.dirsetup\fR u32 rw (step type 0 only)
The minimum setup time from direction to step, in nanoseconds periods.  Measured from change of direction to rising edge of step.
.TP
\fBstepgen.\fIN\fB.dirhold\fR u32 rw (step type 0 only)
The minimum hold time of direction after step, in nanoseconds.  Measured from falling edge of step to change of direction.
.TP
\fBstepgen.\fIN\fB.dirdelay\fR u32 rw (step types 1 and higher only)
The minimum time between a forward step and a reverse step, in nanoseconds.
.SH TIMING
.P
There are five timing parameters which control the output waveform.  No step type
uses all five, and only those which will be used are exported to HAL.  The values
of these parameters are in nano-seconds, so no recalculation is needed when
changing thread periods.  In the timing diagrams that follow, they are identfied
by the following numbers:
.P
(1) \fBstepgen.n.steplen\fR
.P
(2) \fBstepgen.n.stepspace\fR
.P
(3) \fBstepgen.n.dirhold\fR
.P
(4) \fBstepgen.n.dirsetup\fR
.P
(5) \fBstepgen.n.dirdelay\fR
.P
For step type 0, timing parameters 1 thru 4 are used.  The following timing diagram
shows the output waveforms, and what each parameter adjusts.
.P
.ie '\*[.T]'html' .HTML <PRE> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _____ &nbsp; &nbsp; &nbsp; &nbsp; _____ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _____<BR> &nbsp; &nbsp;STEP &nbsp;____/ &nbsp; &nbsp; &#92;_______/ &nbsp; &nbsp; &#92;_____________/ &nbsp; &nbsp; &#92;______<BR> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; |<BR> &nbsp; &nbsp;Time &nbsp; &nbsp; &nbsp;|-(1)-|--(2)--|-(1)-|--(3)--|-(4)-|-(1)-|<BR> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|__________________<BR> &nbsp; &nbsp;DIR &nbsp; ________________________________/<BR></PRE>
.el \{\
.PD 0
.ft CR
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _____\ \ \ \ \ \ \ \ \ _____\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _____
.P
.ft CR
\ \ \ \ STEP\ \ ____/\ \ \ \ \ \\_______/\ \ \ \ \ \\_____________/\ \ \ \ \ \\______
.P
.ft CR
\ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ |
.P
.ft CR
\ \ \ \ Time\ \ \ \ \ \ |-(1)-|--(2)--|-(1)-|--(3)--|-(4)-|-(1)-|
.P
.ft CR
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |__________________
.P
.ft CR
\ \ \ \ DIR\ \ \ ________________________________/
.ft R
\}
.PD
.P
For step type 1, timing parameters 1, 2, and 5 are used.  The following timing diagram
shows the output waveforms, and what each parameter adjusts.
.P
.ie '\*[.T]'html' .HTML <PRE> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _____ &nbsp; &nbsp; &nbsp; _____<BR> &nbsp; &nbsp;UP &nbsp; &nbsp;__/ &nbsp; &nbsp; &#92;_____/ &nbsp; &nbsp; &#92;________________________________<BR> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; | &nbsp; &nbsp; | &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; |<BR> &nbsp; &nbsp;Time &nbsp; &nbsp;|-(1)-|-(2)-|-(1)-|---(5)---|-(1)-|-(2)-|-(1)-|<BR> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|_____| &nbsp; &nbsp; |_____|<BR> &nbsp; &nbsp;DOWN &nbsp;______________________________/ &nbsp; &nbsp; &#92;_____/ &nbsp; &nbsp; &#92;____<BR></PRE>
.el \{\
.PD 0
.ft CR
\ \ \ \ \ \ \ \ \ \ \ \ \ _____\ \ \ \ \ \ \ _____
.P
.ft CR
\ \ \ \ UP\ \ \ \ __/\ \ \ \ \ \\_____/\ \ \ \ \ \\________________________________
.P
.ft CR
\ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ \ \ \ \ |
.P
.ft CR
\ \ \ \ Time\ \ \ \ |-(1)-|-(2)-|-(1)-|---(5)---|-(1)-|-(2)-|-(1)-|
.P
.ft CR
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |_____|\ \ \ \ \ |_____|
.P
.ft CR
\ \ \ \ DOWN\ \ ______________________________/\ \ \ \ \ \\_____/\ \ \ \ \ \\____
.ft R
\}
.PD
.P
For step types 2 and higher, the exact pattern of the outputs depends on the step
type (see the HAL manual for a full listing).  The outputs change from one state to
another at a minimum interval of \fBsteplen\fR.  When a direction change occurs, the
minimum time between the last step in one direction and the first in the other
direction is the sum of \fBsteplen\fR and \fBdirdelay\fR.
.SH SEE ALSO
The HAL User Manual.

.TH SUPPLY "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
supply \- set output pins with values from parameters (obsolete)
.SH SYNOPSIS
\fBloadrt supply num_chan=\fInum\fR

.SH DESCRIPTION
\fBsupply\fR was used to allow the inputs of other HAL components
to be manipulated for testing purposes.  When it was written, the
only way to set the value of an input pin was to connect it to a 
signal and connect that signal to an output pin of some other
component, and then let that component write the pin value.
\fBsupply\fR was written to be that "other component".  It reads
values from parameters (set with the HAL command \fBsetp\fR) and
writes them to output pins.

Since \fBsupply\fR was written, the \fBsetp\fR command has been
modified to allow it to set unconnected pins as well as parameters.
In addition, the \fBsets\fR command was added, which can directly
set HAL signals, as long as there are no output pins connected to
them.  Therefore, \fBsupply\fR is obsolete.
.P
\fBsupply\fR supports a maximum of eight channels.  The number of
channels actually loaded is set by the \fBnum_chan\fR argument when
the module is loaded.  If \fBnumchan\fR is not specified, the default
value is one.

.SH FUNCTIONS
.TP 
\fBsupply.\fIN\fB.update\fR (uses floating-point)
Updates output pins for channel \fIN\fR.

.SH PINS
.TP
\fBsupply.\fIN\fB.q\fR bit out
Output bit, copied from parameter \fBsupply.\fIN\fB.d\fR.
.TP
\fBsupply.\fIN\fB._q\fR bit out
Output bit, inverted copy of parameter \fBsupply.\fIN\fB.\fBd\fR.
.TP
\fBsupply.\fIN\fB.variable\fR float out
Analog output, copied from parameter \fBsupply.\fIN\fB.value\fR.
.TP
\fBsupply.\fIN\fB._variable\fR float out
Analog output, equal to \-1.0 times parameter \fBsupply.\fIN\fB.value\fR.
.TP
\fBsupply.\fIN\fB.d\fR bit rw
Data source for \fBq\fR and \fB_q\fR output pins.
.TP
\fBsupply.\fIN\fB.value\fR bit rw
Data source for \fBvariable\fR and \fB_variable\fR output pins.

.TH THREADS "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME
threads \- creates hard realtime HAL threads
.SH SYNOPSIS
\fBloadrt threads name1=\fIname\fB period1=\fIperiod\fR [\fBfp1=\fR<\fB0\fR|\fB1\fR>] [<thread-2-info>] [<thread-3-info>]

.SH DESCRIPTION
\fBthreads\fR is used to create hard realtime threads which can execute
HAL functions at specific intervals.  It is not a true HAL component, in
that it does not export any functions, pins, or parameters of its own.
Once it has created one or more threads, the threads stand alone, and
the \fBthreads\fR component can be unloaded without affecting them.  In
fact, it can be unloaded and then reloaded to create additional threads,
as many times as needed.

.P
\fBthreads\fR can create up to three realtime threads.  Threads must be
created in order, from fastest to slowest.  Each thread is specified by
three arguments.  \fBname1\fR is used to specify the name of the first
thread (thread 1).  \fBperiod1\fR is used to specify the period of thread
1 in nanoseconds.  Both \fIname\fR and \fIperiod\fR are required.  The 
third argument, \fBfp1\fR is optional, and is used to specify if thread
1 will be used to execute floating  point code.  If not specified, it
defaults to \fB1\fR, which means that the thread will support floating
point.  Specify \fB0\fR to disable floating point support, which saves
a small amount of execution time by not saving the FPU context.  For
additional threads, \fBname2\fR, \fBperiod2\fR, \fBfp2\fR, \fBname3\fR,
\fBperiod3\fR, and \fBfp3\fR work exactly the same.  If more than three
threads are needed, unload threads, then reload it to create more threads.

.SH FUNCTIONS
.P
None

.SH PINS
.P
None

.SH PARAMETERS
.P
None

.SH BUGS
.P
The existence of \fBthreads\fR might be considered a bug.  Ideally, creation
and deletion of threads would be done directly with \fBhalcmd\fR commands,
such as "\fBnewthread \fIname period\fR", "\fBdelthread \fIname\fR", or similar.
However, limitations in the current HAL implementation require thread creation
to take place in kernel space, and loading a component is the most straightforward
way to do that.

.so man9/kins.9
.so man9/kins.9
.TH WATCHDOG "9" "2010-06-22" "LinuxCNC Documentation" "HAL Component"
.de TQ
.br
.ns
.TP \\$1
..

.SH NAME

watchdog \- monitor multiple inputs for a "heartbeat"
.SH SYNOPSIS
.HP
.B loadrt watchdog num_inputs=\fIN\fR
.P
You must specify the number of inputs, from 1 to 32.  Each input has a 
separate timeout value.
.SH FUNCTIONS
.TP
\fBprocess\fR
Check all input pins for transitions, clear the \fBok\-out\fR pin if any
input has no transition within its timeout period.  This function does not
use floating point, and should be added to a fast thread.
.TP
\fBset\-timeouts\fR
Check for timeout changes, and convert the float timeout inputs to int
values that can be used in \fBprocess\fR.  This function also monitors
\fBenable\-in\fR for false to true transitions, and re-enables monitoring
when such a transition is detected.  This function does use floating point, 
and it is appropriate to add it to the servo thread.
.SH PINS
.TP
.B watchdog.input\-n\fR bit in\fR
Input number n.  The inputs are numbered from 0 to \fBnum_inputs\fR\-1.
.TP
.B watchdog.enable\-in\fR bit in \fR(default: \fIFALSE\fR)
If TRUE, forces out\-ok to be false.  Additionally, if a timeout occurs on
any input, this pin must be set FALSE and TRUE again to re-start the
monitoring of input pins.
.TP
.B watchdog.ok\-out\fR bit out \fR(default: \fIFALSE\fR)
OK output.  This pin is true only if enable\-in is TRUE and no timeout has
been detected.  This output can be connected to the enable input of a 
\fBcharge_pump\fR or \fBstepgen\fR (in v mode), to provide a heartbeat signal
to external monitoring hardware.
.SH PARAMETERS
.TP
.B
.B watchdog.timeout\-n\fR float in\fR
Timeout value for input number n.  The inputs are numbered from 0 to 
\fBnum_inputs\fR\-1.  The timeout is in seconds, and may not be below zero.
Note that a timeout of 0.0 will likely prevent \fBok\-out\fR from ever becoming
true.  Also note that excessively long timeouts are relatively useless for
monitoring purposes.
.SH LICENSE

GPL
.TH WEIGHTED_SUM "9" "2007-01-16" "LinuxCNC Documentation" "HAL Component"
.SH NAME
weighted_sum \- convert a group of bits to an integer
.SH SYNOPSIS
.B loadrt weighted_sum wsum_sizes=\fIsize[,size,...]\fR
.P
Creates weighted sum groups each with the given number of input bits
(\fIsize\fR).
.SH DESCRIPTION
This component is a "weighted summer": Its output is the offset plus the sum of
the weight of each TRUE input bit.  The default value for each weight is 2^n
where n is the bit number.  This results in a binary to unsigned conversion.

There is a limit of 8 weighted summers and each may have up to 16 input bits.
.SH FUNCTIONS
.TP
.B process_wsums (requires a floating point thread)
Read all input values and update all output values.
.SH PINS
.TP
.B wsum.\fIN\fB.bit.\fIM\fB.in\fR bit in 
The \fIm\fR'th input of weighted summer \fIn\fR.
.TP
.B wsum.\fIN\fB.hold\fR bit in
When TRUE, the \fIsum\fR output does not change.  When FALSE, the \fIsum\fR
output tracks the \fIbit\fR inputs according to the weights and offset.
.TP
.B wsum.\fIN\fB.sum\fR signed out
The output of the weighted summer
.TP
.B wsum.\fIN\fB.bit.\fIM\fB.weight\fR signed rw
The weight of the \fIm\fR'th input of weighted summer \fIn\fR.  The default
value is 2^\fIm\fR.
.TP
.B wsum.\fIN\fB.offset\fR signed rw
The offset is added to the weights corresponding to all TRUE inputs to give the
final sum.
