.TH AT_PID "9" "2007-05-12" "Documentacion de LinuxCNC" "Componentes HAL"
.de TQ
.br
.ns
.TP \\$1
..

.SH NOMBRE
at_pid \- controlador proporcional/integral/derivativo con ajuste automatico
.SH SINOPSIS
\fBloadrt at_pid [num_chan=\fInum\fB | nombres=\fIname1\fB[,\fIname2 ...\fB]]



.SH DESCRIPCION
\fBat_pid\fR es un controlador proporcional/integral/derivativo clasico.
Se utiliza para controlar los bucles de realimentacion de posicion o velocidad para servomotores y
otras aplicaciones de lazo cerrado.
.P
\fBat_pid\fR admite un maximo de dieciseis controladores. El numero que
en realidad se cargan se establece mediante el argumento \fBnum_chan\fR cuando
se carga el modulo. Alternativamente, especifique \fBnombres=\fR y nombres unicos
separados por comas.
.P
Los especificadores \fBnum_chan=\fR y \fBnombres=\fR se excluyen mutuamente.
Si no se especifica \fBnum_chan=\fR ni \fBnombres=\fR, el valor predeterminado es tres.
.P
Si \fBdebug\fR se establece en 1 (el valor predeterminado es 0), 
se exportaran algunos parametros HAL adicionales, lo que podria ser util
para la puesta a punto, pero por lo demas son innecesarios.
.P
\fBat_pid\fR tiene incorporado un modo de sintonizacion automatica. Funciona estableciendo un
ciclo limite para caracterizar el proceso. A partir de esto, \fBPgain/Igain/Dgain\fR o
\fBPgain/Igain/FF1\fR se pueden determinar usando Ziegler-Nichols. Cuando se usa
\fBFF1\fR, la escala debe establecerse de modo que \fBoutput\fR este en unidades de usuario por segundo.
.P
Durante el ajuste automatico, la entrada \fBcommand\fR no debe cambiar.
El ciclo limite se configura alrededor de la posicion ordenada. No hay valores iniciales de ajuste
requeridos para iniciar la sintonizacion automatica. Solo \fBtune\-cycles\fR, \fBtune\-effort\fR
y \fBtune\-mode\fR debe configurarse antes de iniciar la sintonizacion automatica. Cuando la sintonizacion automatica
se completa, se estableceran los parametros de ajuste. Si se ejecuta desde LinuxCNC, el
ajuste de FERROR para el eje que se esta afinando puede necesitar ser mas permisivo, ya que debe
ser mas grande que el limite de amplitud del ciclo para evitar un error de seguimiento.
.P
Para realizar la sintonizacion automatica, siga los siguientes pasos:
.P 
\- Mueva el eje a afinar a un lugar cercano al centro de su carrera.
.P
\- Establecer \fBtune\-cycles\fR (el valor predeterminado deberia estar bien en la mayoria de los casos) y \fBtune\-mode\fR.
.P
\- Establezca \fBtune\-effort\fR a un valor peque\[~n]o.
.P
\- Establezca \fBenable\fR en VERDADERO.
.P
\- Establezca \fBtune\-mode\fR en VERDADERO. 
.P
\- Establezca \fBtune\-start\fR en VERDADERO.
.P
\- Si no hay oscilacion, o si la oscilacion es muy peque\[~n]a, aumente lentamente \fBtune\-effort\fR.
.P
\- La sintonizacion automatica puede abortarse en cualquier momento configurando \fBenable\fR o \fBtune\-mode\fR a FALSO.

.SH DANDO NOMBRES
Los nombres de los pines, parametros y funciones tienen como prefijo:
  \fBpid.N.\fR para N=0,1, ..., num\-1 cuando se usa \fBnum_chan=num\fR
  \fBnombreN.\fR para nombreN=nombre1, nombre2, ... cuando se usa \fBnombres=nombre1, nombre2, ...\fR

El formato de \fBpid.N.\fR se muestra en las siguientes descripciones.


.SH FUNCIONES
.TP
\fBpid.\fIN\fB.do\-pid\-calcs\fR (usa punto flotante)
Hace los calculos PID para el bucle de control \fIN\fR.

.SH PINES

.TP
\fBpid.\fIN\fB.command\fR float in
El valor deseado (ordenado) para el bucle de control.
.TP
\fBpid.\fIN\fB.feedback\fR float in
El valor real (realimentacion), de algun sensor como un encoder.
.TP
\fBpid.\fIN\fB.error\fR float in
La diferencia entre el comando y la retroalimentacion.
.TP
\fBpid.\fIN\fB.output\fR float out
La salida del bucle PID, que va a algun actuador como un motor.
.TP
\fBpid.\fIN\fB.enable\fR bit in
Cuando es VERDADERO, habilita los calculos PID. Cuando es FALSO, \fBoutput\fR es cero,
y todos los integradores internos, etc, se reinician.
.TP
\fBpid.\fIN\fB.tune\-mode\fR bit in
Cuando es VERDADERO, habilita el modo de sintonizacion automatica. Cuando es FALSO, se realizan los calculos PID normales.
.TP
\fBpid.\fIN\fB.tune\-start\fR bit io
Cuando se establece en VERDADERO, comienza la sintonizacion automatica. Se borra cuando se completa la sintonizacion automatica.

.SH PARAMETROS
.TP
\fBpid.\fIN\fB.Pgain\fR float rw
Ganancia proporcional. Es la contribucion a la salida, que es el error
multiplicado por \fBPgain\fR.
.TP
\fBpid.\fIN\fB.Igain\fR float rw
Ganancia integral. Es la contribucion a la salida que es la integral
del error multiplicado por \fBIgain\fR. Por ejemplo un error de 0.02 con
una duracion de 10 segundos, daria como resultado un error integrado (\fBerrorI\fR) de 0.2,
y si \fBIgain\fR es 20, el termino integral agregaria 4.0 a la salida.
.TP
\fBpid.\fIN\fB.Dgain\fR float rw
Ganancia derivada. Es la contribucion a la salida que es la tasa de
cambio (derivada) del error multiplicado por \fBDgain\fR. Por ejemplo un
error que cambio de 0,02 a 0,03 en 0,2 segundos resultaria en un error
derivado (\fBerrorD\fR) de ((0,03-0,02)/0,2) = 0,05, y si \fBDgain\fR es 5, 
el termino derivado agregaria 0,25 a la salida.
.TP
\fBpid.\fIN\fB.bias\fR float rw
\fBbias\fR es una cantidad constante que se agrega a la salida. En la mayoria de los casos
se debe dejar a cero. Sin embargo, a veces puede ser util
para compensar offsets en servoamplificadores, o para equilibrar el peso de un objeto que
se mueve verticalmente. \fBbias\fR se desactiva cuando el bucle PID esta deshabilitado,
al igual que todos los demas componentes de la salida. Si se necesita una salida que no sea cero
incluso cuando el bucle PID esta deshabilitado, debe agregarse con una HAL externa sum2.
.TP
\fBpid.\fIN\fB.FF0\fR float rw
Termino de avance de orden cero. Produce una contribucion a la salida que es
\fBFF0\fR multiplicado por el valor ordenado. Para los bucles de posicion,
generalmente se deja en cero. Para los bucles de velocidad, \fBFF0\fR puede compensar
friccion o fuerza contraelectromotriz (FCEM) del motor y puede permitir una mejor sintonizacion si se usa correctamente.
.TP
\fBpid.\fIN\fB.FF1\fR float rw
Termino de avance de primer orden. Produce una contribucion a la salida que es
\fBFF1\fR multiplicado por la derivada del valor ordenado. Para
lazos de posicion, la contribucion es proporcional a la velocidad, y se puede utilizar
Para compensar la friccion o la FCEM del motor. Para los bucles de velocidad, es
proporcional a la aceleracion y puede compensar la inercia. En ambos
casos, puede resultar en un mejor ajuste si se usa correctamente.
.TP
\fBpid.\fIN\fB.FF2\fR float rw
Termino de avance de segundo orden. Produce una contribucion a la salida que es
\fBFF2\fR multiplicado por la segunda derivada del valor ordenado. Para
lazos de posicion, la contribucion es proporcional a la aceleracion, y puede ser
utilizada para compensar la inercia. Para los bucles de velocidad, normalmente deberia ser
proxima a cero.
.TP
\fBpid.\fIN\fB.deadband\fR float rw
Define un rango de error "aceptable". Si el valor absoluto de \fBerror\fR
es menor que \fBdeadband\fR, se tratara como si el error fuera cero.
Cuando se utilizan dispositivos de retroalimentacion tales como encoders, que inherentemente estan "cuantificados" (sin valores intermedios entre dos cuentas), la banda muerta debe configurarse un poco mas de la mitad de una cuenta, para evitar
que el bucle de control entre en una busqueda de ida y vuelta si el comando esta entre dos
valores del codificador. Cuando el valor absoluto del error es mayor
que la banda muerta, el valor de la banda muerta se resta del error anterior
antes de realizar los calculos de bucle, para evitar un paso en la funcion de transferencia
en el borde de la banda muerta. (Vea \fBBUGS\fR.)
.TP
\fBpid.\fIN\fB.maxoutput\fR float rw
Limite de salida. No se permitira superar, en valor absoluto de la salida, \fBmaxoutput\fR, a menos que \fBmaxoutput\fR sea cero.
Cuando la salida esta limitada, el integrador de errores mantendra en lugar de integrar, para evitar los efecto de 
windup y overshoot.

(N.T. Los actuadores (motores) tienen unos limites (fisicos o impuestos), llegados a los cuales se dice que se entra en "saturacion".
Si una variable de control llega a ese limite, el bucle permanece alli, sin importar el valor de la salida. Para el termino integral, esto significa que el error se volvera a integrar y su valor sera cada vez mas grande. Este efecto indeseable es llamado "windup".
Como efecto colateral, se produce una respuesta excesiva, sobredisparo u "overshoot")

.TP
\fBpid.\fIN\fB.maxerror\fR float rw
Limite de la variable de error interno utilizada para P, I y D. Se puede usar para
evitar que valores altos de \fBPgain\fR generen valores excesivos
cuando el error es grande (por ejemplo, cuando el comando realiza un cambio de paso).
Normalmente no es necesario, pero puede ser util para ajustar sistemas no lineales.
.TP
\fBpid.\fIN\fB.maxerrorD\fR float rw
Limite del error derivado. La tasa de cambio de error utilizada por el
termino \fBDgain\fR se limitara a este valor, a menos que el valor sea
cero. Puede usarse para limitar el efecto de \fBDgain\fR y evitar grandes
picos de salida debido a pasos en el comando y/o retroalimentacion. No es normalmente
necesario.
.TP
\fBpid.\fIN\fB.maxerrorI\ fR float rw
Limite en el integrador de errores. El integrador de errores utilizado por el termino \fBIgain\fR
se limitara a este valor, a menos que sea cero. Puede ser utilizado para prevenir
el windup del integrador y el rebasamiento resultante durante/despues de errores sostenidos.
Normalmente no es necesario.
.TP
\fBpid.\fIN\fB.maxcmdD\fR float rw
Limite en el comando derivado. El comando derivado utilizado por \fBFF1\fR sera
limitado a este valor, a menos que el valor sea cero. Puede ser utilizado para prevenir
que \fBFF1\fR produzca picos de salida grandes si hay un cambio de paso en el
comando. Normalmente no es necesario.
.TP
\fBpid.\fIN\fB.maxcmdDD\fR float rw
Limite de la segunda derivada del comando. La segunda derivada del comando, utilizada por
\fBFF2\fR estara limitada a este valor, a menos que el valor sea cero. Puede ser
utilizado para evitar que \fBFF2\fR produzca picos de salida grandes si hay un
cambio de paso en el comando. Normalmente no es necesario.
.TP
\fBpid.\fIN\fB.tune\-type\fR u32 rw
Cuando se establece a 0, se calculan \fBPgain / Igain / Dgain\fR. Cuando se establece en 1, se calculan
\fBPgain / Igain / FF1 \fR .
.TP
\fBpid.\fIN\fB.tune\-cycles\fR u32 rw
Determina el numero de ciclos a ejecutar para caracterizar el proceso.
\fBtune\-cycles\fR en realidad establece el numero de semiciclos. Mas ciclos resulta
en una caracterizacion mas precisa, ya que se utiliza el promedio de todos los ciclos.
.TP
\fBpid.\fIN\fB.tune\-effort\fR float rw
Determina el esfuerzo utilizado en la configuracion del ciclo limite en el proceso.
\fBtune\-effort\fR se debe establecer en un valor positivo menor que \fBmaxoutput\fR.
Comience con algo peque\[~n]o hasta llegar a un valor que resulte en una buena
parte de la corriente maxima del motor que se esta utilizando. Cuanto menor sea el valor,
menor es la amplitud del ciclo limite.
.TP
\fBpid.\fIN\fB.errorI\fR float ro (solo si debug = 1)
Integral de error. Este es el valor que se multiplica por \fBIgain\fR para producir el termino integral de la salida.
.TP
\fBpid.\fIN\fB.errorD\fR float ro (solo si debug = 1)
Derivada del error. Este es el valor que se multiplica por \fBDgain\fR para producir el termino derivado de la salida.
.TP
\fBpid.\fIN\fB.commandD\fR float ro (solo si debug = 1)
Derivada del comando. Este es el valor que se multiplica por \fBFF1\fR para producir el termino de avance de primer orden de la salida.
.TP
\fBpid.\fIN\fB.commandDD\fR float ro (solo si debug = 1)
Segunda derivada del comando. Este es el valor que se multiplica por
\fBFF2\fR para producir el segundo termino de alimentacion de la salida.
.TP
\fBpid.\fIN\fB.ultimate\-gain\fR float ro (solo si debug = 1)
Determinado a partir de la caracterizacion del proceso. \fBultimate\-gain\fR es la relacion de
\fBtune\-effort\fR a la amplitud del ciclo limite multiplicada por 4.0 dividida por Pi.
\fBpid.\fIN\fB.ultimate\-period\fR float ro (solo si debug = 1)
Determinado a partir de la caracterizacion del proceso. \fBultimate\-period\fR es el periodo
del ciclo limite.

.SH ERRORES
Algunas personas argumentarian que la banda muerta deberia implementarse de tal manera que el error sea
tratado como cero si esta dentro de la banda muerta, y no se modifica si esta fuera de
la banda muerta. Esto no se hizo porque causaria un paso en la funcion de transferencia
igual al tama\[~n]o de la banda muerta. Las personas que prefieren ese comportamiento estan
invitadas a agregar un parametro que cambiara el comportamiento, o a escribir su propia
version de \fBat_pid\fR. Sin embargo, el comportamiento predeterminado no debe ser cambiado.
