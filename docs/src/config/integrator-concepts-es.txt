[[cha: integrador-conceptos]]

= Conceptos integradores

== Ubicaciones de archivos

LinuxCNC busca la configuración y los archivos de código G en un lugar específico. los
la ubicación depende de cómo ejecute LinuxCNC.

=== instalado

Si está ejecutando LinuxCNC desde el LiveCD o si lo instaló a través de un deb y usa el
El selector de configuración 'LinuxCNC' del menú LinuxCNC se ve a continuación
directorios:

* El directorio LinuxCNC se encuentra en '/ home / user-name / linuxcnc'.
* Los directorios de configuración se encuentran en '/ home / user-name / linuxcnc / configs'.
** Los archivos de configuración se encuentran en '/ home / user-name / linuxcnc / configs / name-of-config'.
* Los archivos de código G se encuentran en / home / user-name / linuxcnc / nc_files '.

Por ejemplo, para una configuración llamada Mill y un nombre de usuario Fred, el directorio
y la estructura del archivo se vería así.

* '/ home / fred / linuxcnc'
* '/ home / fred / linuxcnc / nc_files'
* '/ home / fred / linuxcnc / configs / mill'
** '/home/fred/linuxcnc/configs/mill/mill.ini'
** '/home/fred/linuxcnc/configs/mill/mill.hal'
** '/home/fred/linuxcnc/configs/mill/mill.var'
** '/home/fred/linuxcnc/configs/mill/tool.tbl'

=== Línea de comando

Si ejecuta LinuxCNC desde la línea de comandos y especifica el nombre y la ubicación de
el archivo INI las ubicaciones de los archivos pueden estar en un lugar diferente. Para ver el
Las opciones para ejecutar LinuxCNC desde la línea de comandos ejecutan 'linuxcnc -h'.

[NOTA]
Las ubicaciones opcionales para algunos archivos se pueden configurar en el archivo INI. Ver el
<< sec: sección de visualización, PANTALLA >> sección y << sec: sección rs274ngc, RS274NGC >>
sección.


== archivos

Cada directorio de configuración requiere al menos los siguientes archivos:

* Un archivo INI .ini
* Un archivo HAL .hal o un archivo HALTCL .tcl especificado en
  << sec: hal-section, HAL >> sección del archivo INI.

[NOTA] Otros archivos pueden ser necesarios para algunas GUI.

Opcionalmente también puede tener:

* Un archivo de Variables .var
** Si omite un archivo .var en un directorio pero incluye
   [<< sec: rs274ngc-section, RS274NGC >>] PARAMETER_FILE = somefilename.var, el archivo
   se creará para usted cuando se inicie LinuxCNC.
** Si omite un archivo .var y omite el elemento [RS274NGC] PARAMETER_FILE, un var
   el archivo llamado rs274ngc.var se creará cuando se inicie LinuxCNC. Puede haber
   algunos mensajes confusos si se omite [RS274NGC] PARAMETER_FILE.
* Un archivo de tabla de herramientas .tbl si [<< sec: emcmot-section, EMCMOT >>] TOOL_TABLE ha sido
  especificado en el archivo INI. Algunas configuraciones no necesitan una tabla de herramientas.

== Sistemas paso a paso

=== Período base

BASE_PERIOD es el 'latido' de su computadora LinuxCNC. Nota al pie: [Esto
La sección se refiere al uso de * stepgen *, LinuxCNC incorporado
generador de pasos Algunos dispositivos de hardware tienen su propio paso
generador y no use uno incorporado de LinuxCNC. En ese caso, consulte
su manual de hardware.] Cada período, el
El generador de pasos de software decide si es hora de otro pulso de paso.
Un período más corto le permitirá generar más pulsos por segundo,
dentro de los limites. Pero si te quedas muy corto, tu computadora gastará mucho
mucho tiempo generando pulsos de paso que todo lo demás disminuirá a un
gatear, o tal vez incluso encerrar. Requisitos de latencia y accionamiento paso a paso
afectará el período más corto que pueda usar.

Las latencias en el peor de los casos solo pueden ocurrir unas pocas veces por minuto, y el
probabilidades de que ocurra una mala latencia justo cuando el motor está cambiando de dirección
estan bajos. Por lo tanto, puede obtener errores muy raros que arruinan una parte cada vez
un tiempo y son imposibles de solucionar.

La forma más sencilla de evitar este problema es elegir un BASE_PERIOD que
es la suma del requisito de tiempo más largo de su unidad, y el
peor caso de latencia de su computadora. Esta no siempre es la mejor opción.
Por ejemplo, si está ejecutando una unidad con un tiempo de retención de señal de dirección de 20 us
requisito, y su prueba de latencia dice que tiene una latencia máxima de
11 us, entonces si configura BASE_PERIOD en 20 + 11 = 31 us obtendrá un
no tan agradable 32,258 pasos por segundo en un modo y 16,129 pasos por
segundo en otro modo.

El problema es con el requisito de tiempo de espera de 20 us. Eso más los 11 nosotros
la latencia es lo que nos obliga a usar un período lento de 31 us. Pero el LinuxCNC
El generador de pasos de software tiene algunos parámetros que le permiten aumentar el
varias veces de un período a varios. Por ejemplo, si la nota al pie 'steplen': [steplen
se refiere a un parámetro que ajusta el rendimiento del generador de pasos incorporado de LinuxCNC,
'stepgen', que es un componente HAL. Este parámetro ajusta la longitud de la
paso pulso en sí mismo. Sigue leyendo, todo se explicará eventualmente.] Es
cambiado de 1 a 2, entonces habrá dos períodos entre el
principio y final del pulso de paso. Del mismo modo, si la nota al pie 'dirhold': [dirhold
se refiere a un parámetro que ajusta la duración del tiempo de retención de la dirección.] es
cambiado de 1 a 3, habrá al menos tres períodos entre el paso
pulso y un cambio del pin de dirección.

Si podemos usar 'dirhold' para cumplir con el requisito de tiempo de espera de 20 us, entonces el
El siguiente tiempo más largo es el tiempo alto de 4.5 us. Agregue la latencia de 11 estados
4.5 us a tiempo, y obtienes un período mínimo de 15.5 us. Cuando intentas
15.5 us, encuentra que la computadora es lenta, por lo que se conforma con 16 us.
Si dejamos 'dirhold' en 1 (el valor predeterminado), entonces el tiempo mínimo entre
paso y dirección es el período de 16 us menos la latencia de 11 us = 5 us,
lo cual no es suficiente Necesitamos otros 15 nosotros. Como el período es de 16 nosotros, nosotros
Necesito un período más. Entonces cambiamos 'dirhold' de 1 a 2. Ahora el mínimo
el tiempo desde el final del pulso escalonado hasta el pin de dirección cambiante es
5 + 16 = 21 us, y no tenemos que preocuparnos de que la unidad pise el
dirección incorrecta debido a la latencia.

Para obtener más información sobre stepgen, consulte << sec: stepgen, sección stepgen >>.

=== Tiempo de paso

Step Timing y Step Space en algunas unidades son diferentes. En este caso
El punto de paso se vuelve importante. Si el disco pisa la caída
borde, entonces el pin de salida debe invertirse.

== Servosistemas

=== Operación básica

Los servosistemas tienen mayor velocidad y precisión que los equivalentes.
sistemas paso a paso, pero son más costosos y complejos.
A diferencia de los sistemas paso a paso, los servosistemas requieren algún tipo de posición
dispositivo de retroalimentación, y debe ajustarse o 'ajustarse', ya que no
funciona directamente como un sistema paso a paso. Estas diferencias
existen porque los servos son un sistema de 'circuito cerrado',
a diferencia de los motores paso a paso que generalmente funcionan con 'circuito abierto'. Que hace
'circuito cerrado' significa? Veamos un diagrama simplificado de cómo un servomotor
El sistema está conectado.

.Servo Loop
image :: images / servo-feedback.png [alt = "diagrama simplificado de cómo se conecta un sistema servomotor"]

Este diagrama muestra que la señal de entrada (y la señal de retroalimentación) conducen
el amplificador sumador, el amplificador sumador acciona el amplificador de potencia,
el amplificador de potencia impulsa el motor, el motor impulsa la carga
(y el dispositivo de retroalimentación) y el dispositivo de retroalimentación (y la señal de entrada)
conducir el motor Esto se parece mucho a un círculo (un circuito cerrado) donde
A controla B, B controla C, C controla D y D controla A.

Si no ha trabajado antes con servosistemas, sin duda esto parecerá un
idea muy extraña al principio, especialmente en comparación con la electrónica más normal
circuitos, donde las entradas proceden suavemente a las salidas, y nunca van
back.footnote: [Si ayuda, el equivalente más cercano a esto en el formato digital
mundo son 'máquinas de estado', 'máquinas secuenciales' y demás, donde
las salidas están haciendo 'ahora' depende de lo que las entradas (y las salidas)
estaban haciendo 'antes'. Si no ayuda, no importa.] Si 'todo'
controla 'todo lo demás', cómo puede funcionar eso, quién está en
¿cargar? La respuesta es que LinuxCNC 'puede' controlar este sistema,
pero tiene que hacerlo eligiendo uno de varios métodos de control.
El método de control que utiliza LinuxCNC, uno de los más simples y mejores,
se llama PID.

PID significa Proporcional, Integral y Derivado. El proporcional
El valor determina la reacción al error actual, el valor integral
determina la reacción en función de la suma de los errores recientes, y el
El valor derivado determina la reacción en función de la velocidad a la que
El error ha estado cambiando. Son tres técnicas matemáticas comunes.
que se aplican a la tarea de lograr que un proceso de trabajo siga un
punto fijo. En el caso de LinuxCNC, el proceso que queremos controlar es real
posición del eje y el punto de ajuste es la posición del eje ordenada.

.PID Loop
image :: images / pid-feedback.png [alt = "PID Loop, PID significa Proporcional, Integral y Derivado"]

Al 'ajustar' las tres constantes en el algoritmo del controlador PID, el
el controlador puede proporcionar acciones de control diseñadas para procesos específicos
requisitos La respuesta del controlador puede describirse en términos
de la capacidad de respuesta del controlador a un error, el grado de
que el controlador supera el punto de ajuste y el grado de sistema
oscilación.

=== Término proporcional

El término proporcional (a veces llamado ganancia) hace un cambio en el
salida que es proporcional al valor de error actual. Un alto
resultados de ganancia proporcional en un gran cambio en la salida de un determinado
cambio en el error Si la ganancia proporcional es demasiado alta, el sistema
puede volverse inestable En contraste, una pequeña ganancia resulta en una pequeña
respuesta de salida a un gran error de entrada. Si la ganancia proporcional es demasiado
bajo, la acción de control puede ser demasiado pequeña al responder al sistema
disturbios

En ausencia de perturbaciones, el control proporcional puro no
establecerse en su valor objetivo, pero retendrá un error de estado estable que
es una función de la ganancia proporcional y la ganancia del proceso. A pesar de
el desplazamiento en estado estacionario, tanto la teoría de ajuste como la práctica industrial
indicar que es el término proporcional que debe contribuir el
mayor parte del cambio de salida.

=== Término integral

La contribución del término integral (a veces llamado reinicio) es
proporcional tanto a la magnitud del error como a la duración del
error. Sumando el error instantáneo en el tiempo (integrando el
error) proporciona el desplazamiento acumulado que debería haberse corregido
previamente. El error acumulado se multiplica por la integral
ganancia y agregado a la salida del controlador.

El término integral (cuando se agrega al término proporcional) acelera
el movimiento del proceso hacia el punto de ajuste y elimina el
error residual de estado estacionario que ocurre solo con una proporción
controlador. Sin embargo, dado que el término integral responde a
errores acumulados del pasado, puede causar que el valor presente
sobrepasar el valor del punto de ajuste (cruzar sobre el punto de ajuste y luego crear
una desviación en la otra dirección).

=== Término derivado

La tasa de cambio del error de proceso se calcula determinando
la pendiente del error en el tiempo (es decir, su primera derivada con
respecto al tiempo) y multiplicando esta tasa de cambio por la derivada
ganancia.

El término derivado reduce la velocidad de cambio de la salida del controlador
y este efecto es más notable cerca del punto de ajuste del controlador.
Por lo tanto, el control derivativo se utiliza para reducir la magnitud de la
sobreimpulso producido por el componente integral y mejorar la combinación
estabilidad del proceso del controlador.

=== Ajuste de bucle

Si los parámetros del controlador PID (las ganancias de la proporcional,
términos integrales y derivados) se eligen incorrectamente, los controlados
La entrada del proceso puede ser inestable, es decir, su salida diverge, con o
sin oscilación, y está limitado solo por saturación o mecánica
rotura. Sintonizar un bucle de control es el ajuste de su control
parámetros (ganancia / banda proporcional, ganancia integral / reinicio, derivada
ganancia / velocidad) a los valores óptimos para la respuesta de control deseada.

=== Sintonización manual

Un método de ajuste simple es establecer primero los valores I y D en cero.
Aumente la P hasta que la salida del bucle oscile, luego la P
debe establecerse en aproximadamente la mitad de ese valor durante un 'cuarto
respuesta de tipo "decadencia de amplitud". Luego aumente I hasta que cualquier compensación sea
corregir en tiempo suficiente para el proceso. Sin embargo, demasiado lo haré
causar inestabilidad Finalmente, aumente D, si es necesario, hasta que el ciclo esté
aceptablemente rápido para alcanzar su referencia después de una perturbación de carga.
Sin embargo, demasiada D causará una respuesta excesiva y un sobreimpulso. Un ayuno
La sintonización del bucle PID generalmente se sobrepasa ligeramente para alcanzar el punto de ajuste más
con rapidez; sin embargo, algunos sistemas no pueden aceptar el sobreimpulso, en cuyo caso
Se requiere un sistema de circuito cerrado 'sobre-amortiguado', que requerirá una P
establecer significativamente menos de la mitad de la configuración de P que causa
oscilación.

== RTAI

La interfaz de aplicación en tiempo real (RTAI) se utiliza para proporcionar lo mejor
Rendimiento en tiempo real (RT). El kernel parcheado RTAI te permite escribir
aplicaciones con estrictas restricciones de tiempo. RTAI te da la habilidad
tener cosas como la generación de pasos de software que requieren precisión
sincronización.

=== ACPI

La Interfaz avanzada de configuración y energía (ACPI) tiene muchas
diferentes funciones, la mayoría de las cuales interfieren con el rendimiento de RT (para
ejemplo: administración de energía, apagado de CPU, escala de frecuencia de CPU, etc.
El núcleo LinuxCNC (y probablemente todos los núcleos parcheados con RTAI) tiene ACPI
discapacitado. ACPI también se encarga de apagar el sistema después de un
se ha iniciado el apagado, y por eso es posible que deba presionar el botón de encendido
botón para apagar completamente su computadora. El grupo RTAI ha sido
mejorar esto en versiones recientes, por lo que su sistema LinuxCNC puede apagarse
en sí mismo después de todo.


