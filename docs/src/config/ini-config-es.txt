[[cha: configuración inicial]]

= Configuración INI

== Los componentes del archivo INI

Un archivo INI típico sigue un diseño bastante simple que incluye;

* comentarios
* secciones
* variables

Cada uno de estos elementos está separado en líneas simples. Cada final de línea
o el carácter de nueva línea crea un nuevo elemento.

(((Archivo INI, Comentarios)))

=== Comentarios

Una línea de comentario se inicia con un; o una marca #. Cuando el lector ini
ve cualquiera de estas marcas al comienzo de una línea, el resto de la línea es
ignorado por el software. Los comentarios se pueden usar para describir qué es un INI
elemento hará.

----
; Este es mi archivo de configuración del molino.
# Lo configuré el 12 de enero de 2012
----

Los comentarios también se pueden usar para 'desactivar' una variable. Esto lo hace más fácil.
para elegir entre diferentes variables.

----
PANTALLA = eje
# DISPLAY = touchy
----

En esta lista, la variable DISPLAY se establecerá en axis porque el
El otro está comentado. Si alguien edita descuidadamente una lista como
esto y deja dos de las líneas sin comentar, la primera encontrada
se utilizará.

Tenga en cuenta que dentro de una variable, "#" y ";" los caracteres no denotan
comentarios:

----
INCORRECTO = valor # y un comentario

# Comentario correcto
CORRECTO = valor
----

=== Secciones

Las partes relacionadas de un archivo ini se separan en secciones.
El nombre de una sección se encierra entre paréntesis como este '[THIS_SECTION]'
El orden de las secciones no es importante. Las secciones comienzan en la sección.
nombre y finalice en el siguiente nombre de sección.

Las siguientes secciones son utilizadas por LinuxCNC:

* '[<< sec: emc-section, EMC >>]' información general
* Configuraciones '[<< sec: display-section, DISPLAY >>]' relacionadas con la interfaz gráfica de usuario
* '[<< sec: sección de filtro, FILTRO >>]' configura los programas de filtro de entrada
* '[<< sec: rs274ngc-section, RS274NGC >>]' configuración utilizada por el intérprete de código g
* '[<< sec: emcmot-section, EMCMOT >>]' configuraciones utilizadas por el controlador de movimiento en tiempo real
* Configuraciones '[<< sec: task-section, TASK >>]' utilizadas por el controlador de tareas
* '[<< sec: hal-section, HAL >>]' especifica archivos .hal
* '[<< sec: halui-section, HALUI >>]' Comandos MDI utilizados por HALUI
* '[<< sec: sección de aplicaciones, APLICACIONES >>]' Otras aplicaciones que LinuxCNC iniciará
* '[<< sec: traj-section, TRAJ >>]' configuraciones adicionales utilizadas por el controlador de movimiento en tiempo real
* '[<< sec: joint-section, JOINT_n >>]' variables conjuntas individuales
* '[<< sec: axis-section, AXIS_n >>]' variables de eje individuales
* '[<< sec: kins-section, KINS >>]' variables cinemáticas

* '[<< sec: emcio-section, EMCIO >>]' configuración utilizada por el controlador de E / S

=== Variables

Una línea variable se compone de un nombre variable, un signo igual (=) y
un valor. Todo, desde el primer carácter de espacio no blanco después del
= hasta el final de la línea se pasa como el valor, por lo que puede incrustar
espacios en símbolos de cadena si lo desea o lo necesita. Un nombre de variable es
a menudo llamado palabra clave

Ejemplo Variable
----
MÁQUINA = Mi máquina
----

Una línea variable puede extenderse a varias líneas con una barra diagonal inversa (\)
personaje. Se permite un máximo de MAX_EXTEND_LINES (== 20). No debe haber
espacios en blanco que siguen al carácter de barra invertida final.

Los identificadores de sección no pueden extenderse a varias líneas.

. Variable con la línea se extiende Ejemplo
----
APP = sim_pin \
ini.0.max_acceleration \
ini.1.max_acceleration \
ini.2.max_acceleration \
ini.0.max_velocity \
ini.1.max_velocity \
ini.2.max_velocity
----

Las siguientes secciones detallan cada sección del archivo de configuración,
utilizando valores de muestra para las líneas de configuración.

Las variables que utiliza LinuxCNC siempre deben usar la sección
nombres y nombres de variables como se muestra. En el siguiente ejemplo, la variable
A 'MÁQUINA' se le asigna el valor 'Mi máquina'.

[[sub: variables personalizadas]]

=== Secciones personalizadas y variables

La mayoría de las configuraciones de muestra utilizan secciones y variables personalizadas para poner todas las
configuraciones en una ubicación para mayor comodidad.

Para agregar una variable personalizada a una sección LinuxCNC existente, simplemente incluya
la variable en esa sección.

Ejemplo de variable personalizada
----
[JUNTA_0]
TIPO = LINEAL
...
ESCALA = 16000
----

Para introducir una sección personalizada con sus propias variables, agregue la sección
y variables al archivo INI.

Ejemplo de sección personalizada
----
[INVESTIGACION]
Z_FEEDRATE = 50
Z_OFFSET = 12
Z_SAFE_DISTANCE = -10
----

Para usar las variables personalizadas en su archivo HAL, coloque la sección y
nombre de la variable en lugar del valor.

.HAL Ejemplo
----
setp offset.1.offset [SONDA] Z_OFFSET
setp stepgen.0.position-scale [JOINT_0] SCALE
----

[NOTA]
El valor almacenado en la variable debe coincidir con el tipo especificado por
pin componente

Para usar las variables personalizadas en el código G, use la sintaxis de la variable global
`# <_ ini [sección] variable>`. El siguiente ejemplo muestra un simple
Rutina de derivación del eje Z para una fresadora o fresadora que utiliza una placa de sonda.

Ejemplo de código G.
[fuente, {ngc}]
-------------------------------------------------- -------------------
G91
G38.2 Z # <_ ini [sonda] z_safe_distance> F # <_ ini [sonda] z_feedrate>
G90
G1 Z # 5063
G10 L20 P0 Z # <_ ini [sonda] z_offset>
-------------------------------------------------- -------------------


=== Incluir archivos

Un archivo INI puede incluir el contenido de otro archivo usando un #INCLUDE
directiva.

. # INCLUYE Formato
----
#INCLUDE filename
----

El nombre del archivo se puede especificar como:

 * un archivo en el mismo directorio que el archivo INI
 * un archivo ubicado en relación con el directorio de trabajo
 * un nombre de archivo absoluto (comienza con un /)
 * un nombre de archivo relativo al hogar del usuario (comienza con un ~)

Se admiten varias directivas #INCLUDE.

. # INCLUIR Ejemplos
----
#INCLUDE joint_0.inc
#INCLUDE ../parallel/joint_1.inc
#INCLUDE a continuación / joint_2.inc
#INCLUDE /home/myusername/myincludes/display.inc
#INCLUDE ~ / linuxcnc / myincludes / rs274ngc.inc
----

Las directivas #INCLUDE son compatibles solo para un nivel de expansión: un
el archivo incluido no puede incluir archivos adicionales. La extensión de archivo recomendada
es .inc. No utilice una extensión de archivo de .ini para los archivos incluidos.


== Secciones de archivo INI

[[sec: emc-section]] (((Archivo INI, Sección EMC)))

=== Sección [EMC]

* 'VERSION = 1.1': el número de versión para la configuración. Cualquier valor otro
    que 1.1 hará que se ejecute el verificador de configuración e intente actualizar el
    configuración al nuevo estilo de ejes de unión tipo de configuración.

* 'MACHINE = My Controller': este es el nombre del controlador, que es
    impreso en la parte superior de la mayoría de las interfaces gráficas. Puedes poner lo que sea
    quieres aquí siempre que lo hagas en una sola línea.

* 'DEBUG = 0': el nivel de depuración 0 significa que no se imprimirán mensajes cuando LinuxCNC esté
  ejecutar desde un << faq: terminal, terminal >>. Las marcas de depuración generalmente solo son útiles para
  desarrolladores Vea src / emc / nml_intf / debugflags.h para otras configuraciones.

[[sec: display-section]] (((Archivo INI, Sección DISPLAY)))

=== Sección [DISPLAY]

Los diferentes programas de interfaz de usuario utilizan diferentes opciones, y no todos
La opción es compatible con todas las interfaces de usuario. Hay varias interfaces
como Axis, Gmoccapy, Touchy, qtvcp's QtDragon y Gscreen.
Axis es una interfaz para usar con normal
computadora y monitor, Touchy es para usar con pantallas táctiles. Gmoccapy
se puede usar en ambos sentidos y también ofrece muchas conexiones para controles de hardware.
Las descripciones de las interfaces se encuentran en la sección Interfaces de
Manual de usuario.

* 'DISPLAY = axis' - El nombre de la interfaz de usuario a usar. Opciones válidas
   puede incluir: 'axis', 'touchy', 'gmoccapy', 'gscreen', 'tklinuxcnc', 'qtvcp'

* 'POSITION_OFFSET = RELATIVE': el sistema de coordenadas (RELATIVE o MACHINE)
  para mostrar en el DRO cuando se inicia la interfaz de usuario. La coordenada RELATIVA
  El sistema refleja los desplazamientos de coordenadas G92 y G5x actualmente vigentes.

* 'POSITION_FEEDBACK = COMMANDED': el valor de coordenadas (COMMANDED o ACTUAL)
  para mostrar en el DRO cuando se inicia la interfaz de usuario. En Axis esto se puede cambiar
  desde el menú Ver. La posición MANDADA es la posición solicitada por
  LinuxCNC. La posición REAL es la posición de retroalimentación de los motores si
  tener comentarios como la mayoría de los servosistemas. Por lo general, se utiliza el valor COMANDO.

* 'DRO_FORMAT_MM =% + 08.6f': anula el formato DRO predeterminado en métrica
  modo. (normalmente 3 lugares decimales, rellenados con espacios de 6 dígitos a la izquierda)
  el ejemplo anterior rellenará con ceros, mostrará 6 dígitos decimales y fuerza
  visualización de un signo + para números positivos. El formateo sigue la práctica de Python.
  https://docs.python.org/2/library/string.html#format-specification-mini-language
  se generará un error si el formato no puede aceptar un valor de punto flotante.

* 'DRO_FORMAT_IN =% 4.1f': anula el formato DRO predeterminado en imperial
  modo. (normalmente 4 lugares decimales, rellenados con espacios de 6 dígitos a la izquierda)
  El ejemplo anterior mostrará solo un dígito decimal. El formato sigue
  Práctica de pitón.
  https://docs.python.org/2/library/string.html#format-specification-mini-language
  Se generará un error si el formato no puede aceptar un valor de punto flotante.

* 'CONE_BASESIZE = .25': anula el tamaño predeterminado de base de cono / herramienta de .5 en
  la pantalla de gráficos

* 'MAX_FEED_OVERRIDE = 1.2': la anulación de alimentación máxima que el usuario puede seleccionar.
  1.2 significa 120% de la velocidad de alimentación programada.

* 'MIN_SPINDLE_OVERRIDE = 0.5' - La mínima anulación del husillo que el usuario puede
  Seleccione. 0.5 significa el 50% de la velocidad programada del husillo. (Esto se usa para
  establecer la velocidad mínima del husillo).

* 'MIN_SPINDLE_0_OVERRIDE = 0.5'- La anulación mínima del husillo que el usuario puede
  Seleccione. 0.5 significa el 50% de la velocidad programada del husillo. (Esto se usa para
  establecer la velocidad mínima del husillo). En la máquina de múltiples husillos habrá entradas para cada número de husillo. Solo Qtvcp

* 'MAX_SPINDLE_OVERRIDE = 1.0': la anulación máxima del husillo que el usuario puede
  Seleccione. 1.0 significa el 100% de la velocidad programada del husillo.

* 'MAX_SPINDLE_0_OVERRIDE = 1.0': la anulación de alimentación máxima que el usuario puede seleccionar.
  1.2 significa 120% de la velocidad de alimentación programada.
En la máquina de múltiples husillos habrá entradas para cada número de husillo. Solo Qtvcp

* 'DEFAULT_SPINDLE_SPEED = 100' - Las RPM predeterminadas del cabezal cuando el cabezal
  se inicia en modo manual. si esta configuración no está presente, esto
  el valor predeterminado es 1 RPM para AXIS y 300 RPM para gmoccapy.

* 'DEFAULT_SPINDLE_0_SPEED = 100' - Las RPM predeterminadas del husillo cuando el husillo
  se inicia en modo manual. En la máquina de múltiples husillos habrá entradas para cada número de husillo. Solo Qtvcp

* 'SPINDLE_INCREMENT = 200': el incremento utilizado al hacer clic en los botones de aumento / disminución Qtvcp solamente

* 'MIN_SPINDLE_0_SPEED = 1000': las RPM mínimas que se pueden seleccionar manualmente.
En la máquina de múltiples husillos habrá entradas para cada número de husillo. Solo Qtvcp

* 'MAX_SPINDLE_0_SPEED = 20000': las RPM máximas que se pueden seleccionar manualmente.
En la máquina de múltiples husillos habrá entradas para cada número de husillo. Solo Qtvcp

* 'PROGRAM_PREFIX = ~ / linuxcnc / nc_files' - La ubicación predeterminada para el código g
  archivos y la ubicación de los códigos M definidos por el usuario. Esta ubicación es buscada
  para el nombre del archivo antes de la ruta de subrutina y la ruta de usuario M si se especifica
  en la sección [RS274NGC].

* 'INTRO_GRAPHIC = emc2.gif': la imagen que se muestra en la pantalla de inicio.

* 'INTRO_TIME = 5': el tiempo máximo para mostrar la pantalla de inicio, en segundos.

* 'CYCLE_TIME = 0.05' - Tiempo de ciclo en segundos que la pantalla se suspenderá entre
   centro.

[NOTA]
GladeVCP utiliza los siguientes elementos [DISPLAY], consulte el
<< gladevcp: incrustando-pestaña, incrustando una pestaña >> sección del Capítulo GladeVCP.

* 'EMBED_TAB_NAME = Demo de GladeVCP'

* 'EMBED_TAB_COMMAND = halcmd loadusr -Wn gladevcp gladevcp -c gladevcp -x {XID} -u ./gladevcp/hitcounter.py ./gladevcp/manual-example.ui'


[NOTA]
Los diferentes programas de interfaz de usuario utilizan diferentes opciones, y no todos
La opción es compatible con todas las interfaces de usuario.
Consulte el documento << cha: axis-gui, AXIS GUI >> para obtener detalles sobre AXIS.
Consulte el documento << cha: gmoccapy, gmoccapy >> para obtener detalles sobre Gmoccapy.

* 'DEFAULT_LINEAR_VELOCITY = .25' - La velocidad predeterminada para los movimientos lineales, en,
   << sec: traj-section, unidades de máquina >> por segundo.

* 'MIN_VELOCITY = .01': el valor más bajo aproximado del control deslizante de desplazamiento.

* 'MAX_LINEAR_VELOCITY = 1.0' - La velocidad máxima para trotar lineales, en unidades de máquina por segundo.

* 'MIN_LINEAR_VELOCITY = .01': el valor más bajo aproximado del control deslizante de desplazamiento.

* 'DEFAULT_ANGULAR_VELOCITY = .25' - La velocidad predeterminada para trotar angular, en unidades de máquina por segundo.

* 'MIN_ANGULAR_VELOCITY = .01': el valor más bajo aproximado del control deslizante de desplazamiento angular.

* 'MAX_ANGULAR_VELOCITY = 1.0' - La velocidad máxima para trotar angular, en unidades de máquina por segundo.

* 'INCREMENTS = 1 mm, .5 in, ...' - Define los incrementos disponibles para jogs incrementales.
    Los INCREMENTOS se pueden usar para anular el valor predeterminado.
    Los valores pueden ser números decimales (por ejemplo, 0.1000) o números fraccionarios (por ejemplo, 1/16),
    opcionalmente seguido por una unidad (cm, mm, um, pulgadas, pulgadas o milésimas de pulgada).
    Si no se especifica una unidad, se supone la unidad de la máquina.
    Las distancias métricas e imperiales se pueden mezclar:
    INCREMENTOS = 1 pulgada, 1 mil, 1 cm, 1 mm, 1 um es una entrada válida.

* 'GRIDS = 10 mm, 1 in, ...' - Define los valores preestablecidos para las líneas de cuadrícula.
    El valor se interpreta de la misma manera que 'INCREMENTOS'.

* 'OPEN_FILE = /full/path/to/file.ngc': el archivo que se mostrará en la gráfica de vista previa cuando se inicie AXIS. Utilizar
   una cadena en blanco "" y no se cargará ningún archivo al inicio. gmoccapy no usará esta configuración, ya que
   ofrece una entrada correspondiente en su página de configuración.

* 'EDITOR = gedit': el editor que se usará al seleccionar Archivo> Editar para editar el código G
    desde el menú de AXIS. Esto debe configurarse para este elemento de menú para
    trabajo. Otra entrada válida es gnome-terminal -e vim. Esta entrada no se aplica a gmoccapy, ya que gmoccapy
    Tiene un editor integrado.

* 'TOOL_EDITOR = tooledit': el editor que se utilizará al editar la tabla de herramientas (por ejemplo, por
    seleccionando "Archivo> Editar tabla de herramientas ..." en Eje). Otro valido
    las entradas son "gedit", "gnome-terminal -e vim" y "gvim". Esta entrada no se aplica a gmoccapy, ya que gmoccapy
    Tiene un editor integrado.

* 'PYVCP = /filename.xml': el archivo de descripción del panel PyVCP. Ver el
    << cha: pyvcp, Capítulo PyVCP >> para más información.

* 'PYVCP_POSITION = BOTTOM': la ubicación del panel PyVCP en la interfaz de usuario de AXIS.
    Si se omite esta variable, el panel pasará por defecto al lado derecho. El unico valido
    La alternativa es ABAJO. Vea el << cha: pyvcp, Capítulo PyVCP >> para más información.

* 'LATHE = 1': cualquier valor no vacío (incluido "0") hace que el eje utilice el "modo de torno" con una vista superior y con Radio y Diámetro en el DRO.

* 'BACK_TOOL_LATHE = 1': cualquier valor no vacío (incluido "0") hace que el eje utilice el "modo de torno de herramienta inversa" con el eje X invertido.

* 'FOAM = 1': cualquier valor no vacío (incluido "0") hace que el eje cambie la visualización para el modo de cortador de espuma.

* 'GEOMETRY = XYZABCUVW': controla la vista previa y la trama posterior del movimiento giratorio. Este artículo consiste
    de una secuencia de letras de eje, opcionalmente precedidas por un signo "-".
    Esta secuencia especifica el orden en que el efecto
    de cada eje se aplica, con un "-" que invierte el sentido de la
    rotación.
     La cadena de GEOMETRÍA adecuada depende de la configuración de la máquina y
    la cinemática solía controlarlo. La cadena de ejemplo GEOMETRY = XYZBCUVW
    es para una máquina de 5 ejes donde la cinemática hace que UVW se mueva en el
    sistema de coordenadas de la herramienta y XYZ para moverse en el sistema de coordenadas
    del material. El orden de las letras es importante, porque
    expresa el orden en que se aplican las diferentes transformaciones.
    Por ejemplo, girar alrededor de C y luego B es diferente de girar alrededor
    B entonces C. La geometría no tiene efecto sin un eje rotativo.
     Las máquinas de corte de espuma (FOAM = 1) deben especificar "XY; UV" o dejar el valor
    en blanco aunque este valor se ignore actualmente en el modo de cortador de espuma. UNA
    la versión futura puede definir qué ";" significa, pero si lo hace "XY; UV" significará
    lo mismo que la espuma actual por defecto.

* 'ARCDIVISION = 64' - Establece la calidad de la vista previa de los arcos. Los arcos se previsualizan dividiendo
    ellos en una serie de líneas rectas; un semicírculo se divide en
    * ARCDIVISIÓN * partes. Los valores más grandes dan una vista previa más precisa, pero
    tomar más tiempo para
    cargar y dar como resultado una pantalla más lenta. Los valores más pequeños dan menos
    vista previa precisa, pero tarda menos tiempo en cargar y puede resultar en una velocidad más rápida
    monitor. El valor predeterminado de 64 significa que un círculo de hasta 3 pulgadas
    se mostrará dentro de 1 mil (.03%).

* 'MDI_HISTORY_FILE =' - El nombre de un archivo de historial MDI local. Si esto no se especifica Eje
    guardará el historial de MDI en * .axis_mdi_history * en el hogar del usuario
    directorio. Esto es útil si tiene múltiples configuraciones en una
    computadora.

* 'JOG_AXES =': el orden en que se asignan las teclas de desplazamiento a las letras del eje. Las flechas izquierda y derecha se asignan a la letra del primer eje, arriba y abajo a la segunda, página arriba / página abajo a la tercera, y corchetes izquierdo y derecho a la cuarta. Si no se especifica, el valor predeterminado se determina a partir de los valores de COORDINADOS [TRAJ], [DISPLAY] LATHE y [DISPLAY] FOAM.

* 'JOG_INVERT =': para cada letra de eje, se invierte la dirección de desplazamiento. El valor predeterminado es "X" para tornos y en blanco de lo contrario.

[NOTA]
La configuración de 'JOG_AXES' y 'JOG_INVERT' se aplica al modo de trote mundial por letra de coordenadas del eje
y están vigentes mientras se encuentra en modo mundial después de un recorrido de referencia exitoso. Cuando se opera en conjunto
modo anterior al inicio, las teclas de desplazamiento del teclado se asignan en una secuencia fija: izquierda / derecha: conjunto0,
arriba / abajo: junta1, página arriba / página abajo: junta2, soporte izquierdo / derecho: junta3


* 'USER_COMMAND_FILE = mycommands.py' - El nombre de un opcional, específico de configuración
  archivo de Python originado por la GUI del eje en lugar del archivo específico del usuario `~ / .axisrc`.

[NOTA]
El siguiente elemento [DISPLAY] es utilizado únicamente por la interfaz TKLinuxCNC.

* 'HELP_FILE = tklinucnc.txt' - Ruta al archivo de ayuda.

[[sec: sección de filtro]] (((Archivo INI, Sección FILTER)))

=== Sección [FILTRO]

AXIS y gmoccapy tienen la capacidad de enviar archivos cargados a través de un programa de filtro.
Este filtro puede hacer cualquier tarea deseada: algo tan simple como asegurarse
el archivo termina con M2, o algo tan complicado como detectar si
la entrada es una imagen de profundidad y genera código g para fresar la forma
define. La sección [FILTRO] del archivo ini controla cómo los filtros
trabajo. Primero, para cada tipo de archivo, escriba una línea PROGRAM_EXTENSION.
Luego, especifique el programa a ejecutar para cada tipo de archivo. Esta
el programa recibe el nombre del archivo de entrada como primer argumento, y
debe escribir el código RS274NGC en la salida estándar. Esta salida es lo que
se mostrará en el área de texto, se previsualizará en el área de visualización y
ejecutado por LinuxCNC cuando se ejecuta.

* 'PROGRAM_EXTENSION = .extension Descripción'

Si su postprocesador genera archivos en mayúsculas, es posible que desee agregar
la siguiente linea:

* 'PROGRAM_EXTENSION = .NGC XYZ Post Processor'

Las siguientes líneas agregan soporte para el convertidor de código de imagen a G
incluido con LinuxCNC.

* 'PROGRAM_EXTENSION = .png, .gif, .jpg Imagen de profundidad de escala de grises'
** 'png = imagen a gcode'
** 'gif = imagen a gcode'
** 'jpg = imagen a gcode'

Un ejemplo de un convertidor de código G personalizado ubicado en el directorio linuxcnc.

* 'PROGRAM_EXTENSION = .gcode Impresora 3D
** 'gcode = /home/mill/linuxcnc/convert.py'

NOTA: El archivo de programa asociado con una extensión debe tener el archivo completo
ruta al programa o estar ubicado en un directorio que se encuentra en la ruta del sistema.

También es posible especificar un intérprete:

* 'PROGRAM_EXTENSION = .py Python Script'
** 'py = python'

De esta manera, cualquier script de Python se puede abrir y su salida es
tratado como código g. Un script de ejemplo de este tipo está disponible en
nc_files / holecircle.py. Este script crea código g para perforar un
serie de agujeros a lo largo de la circunferencia de un círculo. Muchos más códigos g
los generadores están en el sitio Wiki LinuxCNC
http://wiki.linuxcnc.org/[http://wiki.linuxcnc.org/].

Si se establece la variable de entorno AXIS_PROGRESS_BAR, entonces las líneas
escrito a stderr de la forma

* 'FILTER_PROGRESS =% d'

establece la barra de progreso de AXIS en el porcentaje dado. Esta característica
debe ser utilizado por cualquier filtro que se ejecute durante mucho tiempo.

Los filtros de Python deben usar la función de impresión para enviar el resultado a Axis.

Este programa de ejemplo filtra un archivo y agrega un eje W para que coincida con el eje Z.
Depende de que haya un espacio entre cada palabra del eje para trabajar.

----
#! / usr / bin / env python

sistema de importación

def main (argv):

  archivo abierto = abierto (argv [0], 'r')
  file_in = openfile.readlines ()
  openfile.close ()

  file_out = []
  para línea en file_in:
    # línea de impresión
    if line.find ('Z')! = -1:
      palabras = line.rstrip ('\ n')
      palabras = palabras.split ('')
      nueva palabra = ''
      para mí en palabras:
        si i [0] == 'Z':
          nueva palabra = 'W' + i [1:]
      if len (nueva palabra)> 0:
        palabras.append (nueva palabra)
        nueva línea = '' .join (palabras)
        file_out.append (nueva línea)
    más:
      file_out.append (línea)
  para el elemento en file_out:
    imprime el elemento "% s"%

if __name__ == "__main__":
   main (sys.argv [1:])
----

[[sec: rs274ngc-section]] (((Archivo INI, Sección RS274NGC)))
[[gcode: ini-features]]

=== [RS274NGC] Sección

* 'PARAMETER_FILE = myfile.var' -
    (((ARCHIVO DE PARÁMETROS))) El archivo ubicado en el mismo directorio que el ini
    archivo que contiene los parámetros utilizados por el intérprete (guardado
    entre carreras).

* 'ORIENT_OFFSET = 0' -
    (((ORIENT OFFSET))) Un valor flotante agregado al parámetro R word
    de una operación << mcode: m19, M19 Orient Spindle >>. Se usa para definir un arbitrario
    posición cero independientemente de la orientación de montaje del codificador.

* 'RS274NGC_STARTUP_CODE = G17 G20 G40 G49 G64 P0.001 G80 G90 G92 G94 G97 G98' -
    (((CÓDIGO DE INICIO RS274NGC))) Una cadena de códigos NC que el intérprete
    se inicializa con Esto no es un sustituto para especificar modal
    códigos g en la parte superior de cada archivo ngc, porque los códigos modales de
    las máquinas difieren, y pueden ser cambiadas por el código g interpretado anteriormente en
    La sesión.

* 'SUBROUTINE_PATH = ncsubroutines: / tmp / testsubs: lathesubs: millsubs' -
    (((RUTA SUBROUTINA))) Especifica una lista separada por dos puntos (:) de hasta 10
    directorios a buscar cuando se especifican subrutinas de un solo archivo
    en gcode. Estos directorios se buscan después de buscar
    [DISPLAY] PROGRAM_PREFIX (si está especificado) y antes de buscar
    [WIZARD] WIZARD_ROOT (si se especifica). Las rutas se buscan en el orden
    que están listados El primer archivo de subrutina coincidente
    encontrado en la búsqueda se utiliza. Los directorios se especifican en relación con el
    directorio actual para el archivo ini o como rutas absolutas. La lista debe
    no contienen espacios en blanco intermedios.

* 'CENTER_ARC_RADIUS_TOLERANCE_INCH = n' Predeterminado 0.00005

* 'CENTER_ARC_RADIUS_TOLERANCE_MM = n' Predeterminado 0.00127

* 'USER_M_PATH = myfuncs: / tmp / mcodes: experimentalmcodes' - (((USER M PATH)))
   Especifica una lista de dos puntos (:) directorios separados para el usuario definido
   funciones Los directorios se especifican en relación con el directorio actual
   para el archivo ini o como rutas absolutas. La lista no debe contener ninguna intervención.
   espacio en blanco
+
Se realiza una búsqueda para cada posible función definida por el usuario, típicamente
(M100-M199). El orden de búsqueda es:
+
. [DISPLAY] PROGRAM_PREFIX (si se especifica)
. Si no se especifica [DISPLAY] PROGRAM_PREFIX, busque la ubicación predeterminada: nc_files
. Luego busque en cada directorio de la lista [RS274NGC] USER_M_PATH
+
El primer ejecutable M1xx encontrado en la búsqueda se usa para cada M1xx.

[NOTA]
El número máximo de directorios USER_M_PATH se define en la compilación
tiempo (típico: 'USER_DEFINED_FUNCTION_MAX_DIRS == 5').

* 'INI_VARS = 1' Predeterminado 1
Permite que los programas de código G lean valores del archivo INI usando el formato
# <_ ini [sección] nombre>. Ver << gcode: parámetros, parámetros del código G>

* 'HAL_PIN_VARS = 1' Predeterminado 1
Permite que los programas de código G lean los valores de los pines HAL usando el formato
# <_ hal [Elemento Hal]> El acceso variable es de solo lectura
Consulte << gcode: parámetros, parámetros de código G >> para obtener más detalles y un
advertencia importante

* 'RETAIN_G43 = 0' Predeterminado 0
Cuando está configurado, puede activar G43 después de cargar la primera herramienta,
y luego no te preocupes por eso a través del programa. Cuando usted
finalmente descargue la última herramienta, el modo G43 se cancela.

* 'OWORD_NARGS = 0' Predeterminado 0
Si esta función está habilitada, una subrutina llamada puede determinar
número de parámetros posicionales reales pasados ​​al inspeccionar el
+ # <n_args> + parámetro.

* 'NO_DOWNCASE_OWORD = 0' Predeterminado 0
Conservar mayúsculas y minúsculas en los nombres de O-word dentro de los comentarios si está configurado, permite leer
elementos HAL de mayúsculas y minúsculas en comentarios estructurados como
'(depuración, # <_ hal [MixedCaseItem])'.

* 'OWORD_WARNONLY = 0' Predeterminado 0
Advertir en lugar de error en caso de errores en las subrutinas de O-word.

[NOTA] Las seis opciones anteriores fueron controladas por la máscara de bits 'CARACTERÍSTICAS'
en versiones de LinuxCNC anteriores a 2.8. Esta etiqueta INI ya no
trabajo.

[NOTA]
[WIZARD] WIZARD_ROOT es una ruta de búsqueda válida pero el asistente no se ha ejecutado por completo
implementado y los resultados de su uso son impredecibles.

* 'REMAP = M400 modalgroup = 10 argspec = Pq ngc = myprocedure'
Vea el capítulo << cha: remap, Remap Extender G-Code >> para más detalles.

* 'ON_ABORT_COMMAND = O <on_abort> call'
Vea el capítulo << cha: remap, Remap Extender G-Code >> para más detalles.

[[sec: emcmot-section]] (((Archivo INI, Sección EMCMOT)))

=== Sección [EMCMOT]

Esta sección es una sección personalizada y LinuxCNC no la utiliza directamente. Más
Las configuraciones utilizan valores de esta sección para cargar el controlador de movimiento. por
Para obtener más información sobre el controlador de movimiento, consulte << sec: motion, Motion >>
Sección.

* 'EMCMOT = motmod': el nombre del controlador de movimiento generalmente se usa aquí.

* 'BASE_PERIOD = 50000': el período de la tarea 'Base' en nanosegundos.

* 'SERVO_PERIOD = 1000000' - Este es el período de tarea "Servo" en nanosegundos.

* 'TRAJ_PERIOD = 100000': este es el período de la tarea 'Planificador de trayectoria' en
  nanosegundos

* 'COMM_TIMEOUT = 1.0' - Número de segundos para esperar a Motion (el
  parte en tiempo real del controlador de movimiento) para acusar recibo de
  mensajes de la tarea (la parte no en tiempo real del controlador de movimiento).

[[sec: sección-tarea]] (((Archivo INI, Sección TAREA)))

=== Sección [TAREA]

* 'TAREA = milltask' -
    Especifica el nombre del ejecutable 'tarea'. El ejecutable 'tarea' hace varios
    cosas, como comunicarse con las interfaces de usuario a través de NML, comunicarse con el
    planificador de movimiento en tiempo real sobre memoria compartida no HAL e interpretar gcode.
    Actualmente solo hay una tarea ejecutable que tiene sentido para
    99.9% de usuarios, milltask.
    
* 'CYCLE_TIME = 0.010' -
    El período, en segundos, en el que se ejecutará TASK. Este parámetro
    afecta el intervalo de sondeo cuando se espera que se complete el movimiento, cuando
    ejecutar una instrucción de pausa y al aceptar un comando de un usuario
    interfaz. Por lo general, no es necesario cambiar este número.

[[sec: hal-section]] (((Archivo INI, Sección HAL)))

=== sección [HAL]

* 'HALFILE = example.hal': ejecuta el archivo 'example.hal' al inicio.
    Si se especifica 'HALFILE' varias veces, los archivos se ejecutan en el orden en que
    aparecer en el archivo ini. Casi todas las configuraciones tendrán al menos
    uno 'HALFILE', y los sistemas paso a paso suelen tener dos de estos archivos, uno que
    especifica la configuración paso a paso genérica ('core_stepper.hal') y
    uno que especifica el pin de la máquina ('xxx_pinout.hal').
    MEDIOS se encuentran mediante una búsqueda. Si el archivo nombrado se encuentra en el directorio
    que contiene el archivo ini, se utiliza. Si el archivo nombrado no se encuentra en este
    directorio de archivos ini, se realiza una búsqueda utilizando una biblioteca de sistema de halfiles.
    Un HALFILE también se puede especificar como una ruta absoluta (cuando el nombre comienza con
    un personaje). No se recomiendan rutas absolutas ya que su uso puede limitar
    reubicación de configuraciones.

* 'HALFILE = texample.tcl [arg1 [arg2] ...]]' - Ejecuta el archivo tcl 'texample.tcl'
    al inicio con arg1, arg2, etc. como :: argv list. Los archivos con un sufijo .tcl son
    procesado como se indica arriba, pero use haltcl para procesar Vea el
    << cha: haltcl, HALTCL Chapter >> para más información.

* 'HALFILE = LIB: sys_example.hal' - Ejecuta el archivo de la biblioteca del sistema 'sys_example.hal'
    Al inicio.
    El uso explícito de LIB: el prefijo provoca el uso de la biblioteca del sistema HALFILE sin
    buscando en el directorio de archivos ini.

* 'HALFILE = LIB: sys_texample.tcl [arg1 [arg2 ...]]' - Ejecuta la biblioteca del sistema
    archivo 'sys_texample.tcl' al inicio.
    El uso explícito de LIB: el prefijo provoca el uso de la biblioteca del sistema HALFILE sin
    buscando en el directorio de archivos ini.
+
Los elementos HALFILE especifican archivos que cargan componentes Hal y generan señales
conexiones entre pines de componentes. Los errores comunes son 1) omisión de
declaración addf necesaria para agregar las funciones de un componente a un hilo, 2)
Especificadores de señal (netos) incompletos. La omisión de las declaraciones addf requeridas es
Casi siempre es un error. Las señales generalmente incluyen una o más entradas
conexiones y una sola salida (pero ambas no son estrictamente necesarias).
Se proporciona un archivo de biblioteca del sistema para verificar estas condiciones y
informar a stdout y en una ventana emergente gui:
----
    HALFILE = LIB: halcheck.tcl [nopopup]
----
[NOTA]
La línea LIB: halcheck.tcl debería ser el último [HAL] HALFILE.
Especifique la opción 'nopopup' para suprimir el mensaje emergente y permitir el inicio inmediato.
Las conexiones realizadas con un POSTGUI_HALFILE no están marcadas.


* 'TWOPASS = ON': utilice el procesamiento de dos pasos para cargar componentes HAL. Con el procesamiento TWOPASS,
    [HAL] HALFILE = las líneas se procesan en dos pasadas. En el primer pase (pass0), todos
    Se leen HALFILES y se acumulan múltiples aspectos de los comandos loadrt y loadusr.
    Estos comandos de carga acumulada se ejecutan al final de pass0. Esta acumulación permite
    líneas de carga que se especificarán más de una vez para un componente dado (siempre que
    nombres = nombres utilizados son únicos en cada uso). En el segundo pase (pase1), el
    HALFILES son releídos y todos los comandos excepto los comandos de carga ejecutados previamente
    son ejecutados

* 'TWOPASS = nodelete verbose': la función TWOPASS se puede activar con cualquier
  cadena no nula que incluye las palabras clave verbose y nodelete. El detallado
  la palabra clave hace que la impresión de detalles sea estándar. La palabra clave nodelete conserva
  archivos temporales en / tmp.
+
Para obtener más información, consulte el capítulo << cha: hal-twopass, Hal TWOPASS >>.

* 'HALCMD = command' - Ejecuta 'command' como un solo comando HAL.
   Si se especifica 'HALCMD' varias veces, los comandos se ejecutan en el orden
    aparecen en el archivo ini. Las líneas 'HALCMD' se ejecutan después de todo
    Líneas 'HALFILE'.

* 'SHUTDOWN = shutdown.hal' - Ejecuta el archivo 'shutdown.hal' cuando sale LinuxCNC.
   Dependiendo de los controladores de hardware utilizados, esto puede permitir configurar salidas a
    valores definidos cuando LinuxCNC sale normalmente. Sin embargo, porque hay
    no se garantiza que este archivo se ejecutará (por ejemplo, en el caso de un
    bloqueo de la computadora) no es un reemplazo para una parada física adecuada
    cadena u otras protecciones contra fallas de software.

* 'POSTGUI_HALFILE = example2.hal' - Ejecute 'example2.hal' después de que la GUI haya creado
  sus pines HAL. Algunas GUI crean pines hal y admiten el uso de un halfile postgui
  para usarlos. Las GUI que admiten halfiles postgui incluyen Touchy, Axis, Gscreen y
  gmoccapy.

  Vea la sección << sec: pyvcp-with-axis, pyVCP with Axis >> Section para más información.

* 'HALUI = halui': agrega los pines de la interfaz de usuario de HAL. Para más información, ver
   el capítulo << cha: interfaz de usuario hal, interfaz de usuario HAL >>.

[[sec: halui-section]] (((Archivo INI, Sección HALUI)))

=== sección [HALUI]

* 'MDI_COMMAND = G53 G0 X0 Y0 Z0' -
     Se puede ejecutar un comando MDI utilizando halui.mdi-command-00. Incremento
    el número de cada comando que se enumera en la sección [HALUI].

[[sec: sección de aplicaciones]] (((Archivo INI, Sección de APLICACIONES)))

=== Sección [APLICACIONES]

LinuxCNC puede iniciar otras aplicaciones antes de que se inicie la interfaz gráfica de usuario especificada.
Las aplicaciones se pueden iniciar después de un retraso especificado para permitir
acciones dependientes de gui (como crear pines hal específicos de gui).

* 'DELAY = value' - segundos para esperar antes de comenzar otro
   aplicaciones. Puede ser necesario un retraso si una aplicación tiene
   dependencias en acciones [HAL] POSTGUI_HALFILE o gui-created
   Hal pines (retardo predeterminado = 0).

* 'APP = appname [arg1 [arg2 ...]]' - Aplicación que se iniciará.
   Esta especificación se puede incluir varias veces. El nombre de la aplicación puede ser
   nombrado explícitamente como un nombre de archivo especificado absoluto o tilde (primer carácter
   es / o ~), un nombre de archivo relativo (los primeros caracteres del nombre de archivo son ./), o como
   un archivo en el directorio inifile. Si no se encuentra ningún archivo ejecutable usando
   estos nombres, luego la ruta de búsqueda del usuario se utiliza para encontrar la aplicación.

   Ejemplos:

** Simule las entradas a los pines hal para la prueba (usando sim_pin, una simple interfaz gráfica de usuario para configurar las entradas a los parámetros, pines no conectados o señales sin escritores):

   APP = sim_pin motion.probe-input halui.abort motion.analog-in-00
** Invoque halshow con una lista de observación previamente guardada. Como linuxcnc establece el directorio de trabajo en el directorio para el archivo inifile, puede hacer referencia a los archivos en ese directorio (ejemplo: my.halshow):

APP = halshow my.halshow

** Alternativamente, se podría especificar un archivo de lista de observación identificado con un nombre de ruta completo:

APP = halshow ~ / saved_shows / spindle.halshow

** Abra halscope usando una configuración previamente guardada:

APP = halscope -i my.halscope

[[sec: traj-section]] (((Archivo INI, Sección TRAJ)))

=== Sección [TRAJ]

[ADVERTENCIA]
El nuevo Planificador de trayectoria (TP) está activado de forma predeterminada. +
Si no tiene configuraciones TP en su sección [TRAJ] - LinuxCNC por defecto es: +
ARC_BLEND_ENABLE = 1 +
ARC_BLEND_FALLBACK_ENABLE = 0 +
ARC_BLEND_OPTIMIZATION_DEPTH = 50 +
ARC_BLEND_GAP_CYCLES = 4 +
ARC_BLEND_RAMP_FREQ = 100

La sección [TRAJ] contiene parámetros generales para la trayectoria.
módulo de planificación en 'movimiento'.

* 'ARC_BLEND_ENABLE = 1' - Activa el nuevo TP. Si se establece en 0, TP utiliza parabólico
mezcla (1 segmento mira hacia adelante). Valor predeterminado 1.

* 'ARC_BLEND_FALLBACK_ENABLE = 0' - Opcionalmente recurrir a mezclas parabólicas
si la velocidad estimada es más rápida Sin embargo, esta estimación es aproximada y
Parece que solo deshabilitarlo proporciona un mejor rendimiento. Valor predeterminado 0.

* 'ARC_BLEND_OPTIMIZATION_DEPTH = 50': anticipa la profundidad en la cantidad de segmentos.
+
Para ampliar esto un poco, puede elegir este valor de forma algo arbitraria.
Aquí hay una fórmula para estimar cuánta 'profundidad' necesita para un determinado
config:
+
# n = v_max / (2.0 * a_max * t_c)
# dónde:
# n = profundidad de optimización
# v_max = velocidad máxima del eje (UU / seg)
# a_max = aceleración máxima del eje (UU / seg)
# t_c = servo período (segundos)
+
Entonces, una máquina con una velocidad máxima del eje de 10 IPS, una aceleración máxima
de 100 IPS ^ 2, y un período de servo de 0.001 seg necesitaría:
+
10 / (2.0 * 100 * 0.001) = 50 segmentos para alcanzar siempre la velocidad máxima
a lo largo del eje más rápido.
+
En la práctica, este número no es tan importante para sintonizar, ya que
mirar hacia adelante rara vez necesita toda la profundidad a menos que tenga muchos muy cortos
segmentos Si durante la prueba, nota ralentizaciones extrañas y no puede
averiguar de dónde vienen, primero intente aumentar esta profundidad usando
La fórmula anterior.
+
Si aún ve ralentizaciones extrañas, puede deberse a que tiene
segmentos en el programa. Si este es el caso, intente agregar un pequeño
tolerancia para la detección Naive CAM. Una buena regla general es esta:
+
# min_length ~ = v_req * t_c
# dónde:
# v_req = velocidad deseada en UU / seg
# t_c = servo período (segundos)
+
Si desea recorrer un camino a 1 IPS = 60 IPM, y su servo
el período es de 0.001 segundos, entonces cualquier segmento más corto que min_length se ralentizará
El camino hacia abajo. Si configura la tolerancia Naive CAM a aproximadamente esta longitud mínima,
segmentos demasiado cortos se combinarán para eliminar esto
embotellamiento. Por supuesto, establecer la tolerancia demasiado alta significa un gran camino
desviaciones, por lo que debes jugar un poco para encontrar un buen valor. Carné de identidad
comience en 1/2 de la longitud mínima, luego continúe según sea necesario.

* 'ARC_BLEND_GAP_CYCLES = 4' Qué tan corto debe ser el segmento anterior antes
el planificador de trayectorias lo 'consume'.
+
A menudo, una combinación de arco circular dejará segmentos de línea cortos entre
Las mezclas. Como la geometría tiene que ser circular, no podemos mezclar
toda una línea si la siguiente es un poco más corta. Desde la trayectoria
el planificador tiene que tocar cada segmento al menos una vez, significa que es muy pequeño
segmentos ralentizarán las cosas significativamente. Mi solución a esta manera de
"consume" el segmento corto haciéndolo parte del arco de mezcla. Ya que
la línea + mezcla es un segmento, no tenemos que reducir la velocidad para golpear el
segmento muy corto Probablemente, no necesitará tocar esta configuración.

* 'ARC_BLEND_RAMP_FREQ = 20' - Esta es una frecuencia de 'corte' para usar ramificado
velocidad.
+
'Velocidad en rampa' en este caso solo significa aceleración constante sobre el
segmento entero Esto es menos óptimo que un perfil de velocidad trapezoidal,
ya que la aceleración no está maximizada. Sin embargo, si el segmento es
lo suficientemente corto, no hay suficiente tiempo para acelerar mucho antes de golpear
El siguiente segmento. Recordemos los segmentos de línea corta de los anteriores
ejemplo. Como son líneas, no hay aceleración en las curvas, así que
somos libres de acelerar hasta la velocidad solicitada. Sin embargo, si esto
la línea está entre dos arcos, entonces tendrá que desacelerar rápidamente nuevamente
estar dentro de la velocidad máxima del siguiente segmento. Esto significa que nosotros
tener un pico de aceleración, luego un pico de desaceleración, causando un
gran tirón, para muy poco aumento de rendimiento. Esta configuración es una forma de
elimine este tirón para segmentos cortos.
+
Básicamente, si un segmento se completará en menos tiempo que 1 /
ARC_BLEND_RAMP_FREQ, no nos molestamos con un perfil de velocidad trapezoidal
en ese segmento, y use aceleración constante. (Ajuste
ARC_BLEND_RAMP_FREQ = 1000 es equivalente a usar siempre trapezoidal
aceleración, si el servo loop es de 1kHz).
+
Puede caracterizar la pérdida de rendimiento en el peor de los casos comparando el
Velocidad que alcanza un perfil trapezoidal frente a la rampa:
+
# v_ripple = a_max / (4.0 * f)
# dónde:
# v_ripple = velocidad promedio "pérdida" debido a la rampa
# a_max = aceleración máxima del eje
# f = frecuencia de corte del INI
+
Para la máquina mencionada, la ondulación para una frecuencia de corte de 20Hz
es 100 / (4 * 20) = 1.25 IPS. Esto parece alto, pero tenga en cuenta que
es solo una estimación del peor de los casos. En realidad, el movimiento trapezoidal
el perfil está limitado por otros factores, como la aceleración normal o
velocidad solicitada, por lo que la pérdida de rendimiento real debería ser mucho
menor. Aumentar la frecuencia de corte puede exprimir más
rendimiento, pero hace que el movimiento sea más duro debido a la aceleración
discontinuidades Un valor en el rango de 20Hz a 200Hz debería ser razonable
para comenzar.
+
Finalmente, ninguna cantidad de ajustes acelerará una trayectoria con muchas
Esquinas pequeñas y estrechas, ya que está limitado por la aceleración en las curvas.

* 'SPINDLES = 3' - El número de husos a soportar. Es imperativo que esto
número coincide con el parámetro "num_spindles" pasado al módulo de movimiento.

* 'COORDINATES = X Y Z': los nombres de los ejes que se controlan.
Solo X, Y, Z, A, B, C, U, V, W son válidos. Solo ejes nombrados en 'COORDENADAS'
son aceptados en el código g. Está permitido escribir un nombre de eje dos veces
(p. ej., X Y Y Z para una máquina de pórtico).
Para las 'cinemáticas trivkins' comunes, los números de articulación se asignan en secuencia
de acuerdo con el parámetro trivkins 'coordenadas ='. Entonces, para trivkins
'coordenadas = xz', la articulación0 corresponde a X y la articulación1 corresponde a Z.
Consulte la página de manual de cinemática ('$ man kins') para obtener información sobre
Trivkins y otros módulos de cinemática.

* 'LINEAR_UNITS = <unidades>' - (((UNIDADES LINEALES))) Especifica las 'unidades de máquina' para ejes lineales.
Las opciones posibles son mm o pulgadas.
Esto no afecta las unidades lineales en el código NC (G20 y G21
las palabras hacen esto).

* 'ANGULAR_UNITS = <unidades>' - (((UNIDADES ANGULARES))) Especifica las 'unidades de máquina' para ejes de rotación.
Las opciones posibles son 'grados', 'grados' (360 por círculo), 'rad', 'radian'
(2pi por círculo), 'grad' o 'gon' (400 por círculo).
Esto no afecta las unidades angulares del código NC. En RS274NGC, A-, B-
y C- las palabras siempre se expresan en grados.

* 'DEFAULT_LINEAR_VELOCITY = 0.0167' - La tasa inicial para movimientos de ejes lineales, en
unidades de máquina por segundo. El valor que se muestra en 'Eje' es igual a
unidades de máquina por minuto.

* 'DEFAULT_LINEAR_ACCELERATION = 2.0': en máquinas con cinemática no trivial, la aceleración utilizada
para trotar "teleop" (espacio cartesiano), en 'unidades de máquina' por segundo por segundo.

* 'MAX_LINEAR_VELOCITY = 5.0' - (((MAX VELOCITY))) La velocidad máxima para cualquier eje o coordinado
mover, en 'unidades de máquina' por segundo. El valor mostrado es igual a 300 unidades por
minuto.

* 'MAX_LINEAR_ACCELERATION = 20.0' - (((MAX ACCELERATION))) La aceleración máxima para cualquier eje o
movimiento coordinado del eje, en 'unidades de máquina' por segundo por segundo.

* 'POSITION_FILE = position.txt': si se establece en un valor no vacío, las posiciones conjuntas se almacenan entre
se ejecuta en este archivo. Esto permite que la máquina comience con el mismo
coordina que tenía en el apagado. Esto supone que no hubo movimiento de
la máquina mientras está apagada. Si no se establece, las posiciones conjuntas no se almacenan
y comenzará en 0 cada vez que se inicie LinuxCNC. Esto puede ayudar en pequeños
máquinas sin interruptores de inicio. Si usa la interfaz de resolución de Mesa
este archivo se puede usar para emular codificadores absolutos y eliminar el
necesidad de referencia (sin pérdida de precisión). Ver la página de manual de hostmot2
para más detalles.

* 'NO_FORCE_HOMING = 1': el comportamiento predeterminado es que LinuxCNC fuerce
usuario para iniciar la máquina antes de ejecutar cualquier comando MDI o un programa.
Normalmente, solo se permite trotar antes de dirigir. Para configuraciones usando
cinemática de identidad, establecer NO_FORCE_HOMING = 1 permite al usuario hacer
MDI mueve y ejecuta programas sin dirigir primero la máquina. Interfaces
el uso de cinemática de identidad sin capacidad de búsqueda necesitará tener esto
opción establecida en 1.

* 'HOME = 0 0 0 0 0 0 0 0 0' - Se necesita una posición de inicio mundial para los módulos de cinemática
que calculan las coordenadas mundiales usando kinematicsForward () al cambiar
de modo conjunto a teleoperador. Hasta nueve valores de coordenadas (X Y Z A B C U V W)
pueden especificarse, los elementos finales no utilizados pueden omitirse. Este valor es solo
utilizado para máquinas con cinemática no trivial. En máquinas con trivial
cinemática (molino, torno, tipos de pórtico) este valor se ignora.
Nota: la configuración de hexapod sim requiere un valor distinto de cero para la coordenada Z.

[ADVERTENCIA]
LinuxCNC no conocerá sus límites de viaje conjunto cuando use 'NO_FORCE_HOMING = 1'.

[[sec: kins-section]] (((Archivo INI, Sección KINS)))

=== Sección [KINS]
* 'JOINTS = 3': especifica el número de juntas (motores) en el sistema.
Por ejemplo, una máquina trivkins XYZ con un solo motor para cada eje tiene 3
articulaciones Una máquina de pórtico con un motor en cada uno de los dos ejes,
y dos motores en el tercer eje, tiene 4 articulaciones.
(Esta variable de configuración puede ser utilizada por una interfaz gráfica de usuario para establecer el número de uniones
(num_joints) especificado en el módulo de movimiento (motmod)).
La interfaz gráfica de usuario Axis, pncconf y stepconf usan este elemento.

* 'KINEMATICS = trivkins': especifique un módulo de cinemática para el módulo de movimiento.
Guis puede usar esta variable para especificar la línea de carga en archivos hal para
El módulo motmod. Para obtener más información sobre los módulos de cinemática, consulte el
página de manual: '$ man kins'

[[sec: sección del eje]] (((Archivo INI, Sección AXIS)))

=== Sección [AXIS_ <letter>]
El <letter> especifica uno de: X Y Z A B C U V W

* 'MAX_VELOCITY = 1.2' -
Velocidad máxima para este eje en << sec: sección traj, unidades de máquina >> por segundo.

* 'MAX_ACCELERATION = 20.0' -
Aceleración máxima para este eje en unidades de máquina por
segundo cuadrado

* 'MIN_LIMIT = -1000' -
(((MIN LIMIT))) El límite mínimo (límite suave) para el movimiento del eje, en unidades de máquina.
Cuando se excede este límite, el controlador aborta el movimiento del eje.

* 'MAX_LIMIT = 1000' -
(((LÍMITE MÁXIMO))) El límite máximo (límite suave) para el movimiento del eje, en unidades de máquina.
Cuando se excede este límite, el controlador aborta el movimiento del eje.

* 'WRAPPED_ROTARY = 1' -
Cuando esto se establece en 1 para una junta ANGULAR, la junta se moverá 0-359.999
grados Los números positivos moverán la articulación en una dirección positiva y
los números negativos moverán la articulación en la dirección negativa.

* 'LOCKING_INDEXER_JOINT = 4': este valor selecciona una unión para usar
un indexador de bloqueo para el eje especificado <letter>. En este ejemplo, el
la articulación es 4, que correspondería al eje B para un sistema XYZAB con
Trivkins (identidad) cinemática.
Cuando se establece, un movimiento G0 para este eje iniciará un desbloqueo con el
pin de desbloqueo de joint.4.y luego espere el pin de desbloqueo de joint.4.is luego mueva
la articulación a la velocidad rápida para esa articulación. Después del movimiento el
joint.4.unlock será falso y el movimiento esperará a joint.4.is-desbloqueado
volverse falso No se permite mover con otras articulaciones al mover un
junta rotativa bloqueada.
Para crear los pines de desbloqueo, use el parámetro motmod:

unlock_joints_mask = máscara conjunta

Los bits de la máscara conjunta son: (LSB) 0: articulación0, 1: articulación1, 2: articulación2, ...

Ejemplo: loadrt motmod ... unlock_joints_mask = 0x38
crea pasadores de desbloqueo para juntas 3,4,5

* 'OFFSET_AV_RATIO = 0.1': si no es cero, este elemento permite el uso de
Hal pines de entrada para compensaciones de eje externo:

'axis. <letter> .eoffset-enable'
'axis. <letter> .eoffset-count'
'axis. <letter> .eoffset-scale'

Consulte el capítulo: << cha: external-offsets, 'External Axis Offsets' >> para
Información de uso.

[[sec: sección conjunta]] (((Archivo INI, Sección CONJUNTA)))

=== [JOINT_ <num>] Sección
<num> especifica el número de unión 0 ... (num_joints-1)
El valor de 'num_joints' lo establece [KINS] JOINTS =

Las secciones [JOINT_0], [JOINT_1], etc. contienen parámetros generales para
los componentes individuales en el módulo de control conjunto. La sección conjunta
los nombres comienzan a numerarse en 0 y pasan por el número de uniones
especificado en la entrada [KINS] JOINTS menos 1.

Típicamente (para sistemas que usan 'cinemática trivkins', hay un 1: 1
correspondencia entre una articulación y un eje):

* JUNTA_0 = X
* JUNTA_1 = S
* JUNTA_2 = Z
* JUNTA_3 = A
* JUNTA_4 = B
* JUNTA_5 = C
* JUNTA_6 = U
* JUNTA_7 = V
* JUNTA_8 = W

Otros módulos de cinemática con cinemática de identidad están disponibles para admitir
configuraciones con conjuntos parciales de ejes. Por ejemplo, usando trivkins
con coordenadas = XZ, las relaciones de ejes comunes son:

* JUNTA_0 = X
* JUNTA_1 = Z

Para obtener más información sobre los módulos cinemáticos, consulte la página de manual: '$ man kins'

* 'TIPO = LINEAL' -
El tipo de articulación, ya sea LINEAL o ANGULAR.

* 'UNIDADES = PULGADAS' -
(((UNITS))) Si se especifica, esta configuración anula la configuración relacionada [TRAJ] UNITS.
(por ejemplo, [TRAJ] LINEAR_UNITS si el TIPO de esta articulación es LINEAR,
[TRAJ] ANGULAR_UNITS si el TIPO de esta articulación es ANGULAR)

* 'MAX_VELOCITY = 1.2' -
Velocidad máxima para esta articulación en << sec: sección traj, unidades de máquina >> por segundo.

* 'MAX_ACCELERATION = 20.0' -
Aceleración máxima para esta unión en unidades de máquina por
segundo cuadrado

* 'RETROCESO = 0.0000' -
(((Contragolpe))) Contragolpe en unidades de máquina. Valor de compensación de reacción
se puede utilizar para compensar pequeñas deficiencias en el hardware utilizado para
conducir un porro. Si se agrega reacción a una articulación y está utilizando
paso a paso, el STEPGEN_MAXACCEL debe aumentarse de 1,5 a 2 veces el
MAX_ACCELERATION para la articulación. La compensación de reacción excesiva puede causar un
eje para sacudirse a medida que cambia de dirección. Si un COMP_FILE se especifica para un
eje BACKLASH no se utiliza.

// agrega un enlace a unidades de máquina

* 'COMP_FILE = file.extension' -
(((Compensación))) El archivo de compensación consiste en un mapa de posición
información para la articulación. Los valores del archivo de compensación están en unidades de máquina.
Cada conjunto de valores está en una línea separada por un espacio. El primer valor
es el valor nominal (la posición ordenada). El segundo y tercer valor
dependerá de la configuración de COMP_FILE_TYPE. Puntos entre valores nominales
están interpolados entre los dos nominales. Los archivos de compensación deben comenzar
con el mínimo nominal y estar en orden ascendente al mayor valor de
nominales. Los nombres de archivo distinguen entre mayúsculas y minúsculas y pueden contener letras y / o
números. Actualmente, el límite dentro de LinuxCNC es de 256 tripletas por eje.
+
+
Si se especifica COMP_FILE para un eje, BACKLASH no se utiliza. UNA
Se debe especificar 'COMP_FILE_TYPE' para cada 'COMP_FILE'.

* 'COMP_FILE_TYPE = 0 o 1': especifica el tipo de archivo de compensación. los
El primer valor es la posición nominal (ordenada) para ambos tipos.

** 'Tipo 0:' El segundo valor especifica la posición real a medida que se mueve el eje
en la dirección positiva (valor creciente) y el tercer valor especifica
la posición real a medida que el eje se mueve en la dirección negativa
(valor decreciente).
+
+
Tipo 0 Ejemplo
+
----
-1.000 -1.005 -0.995
0,000 0,002 -0,003
1.000 1.003 0.998
----

** 'Tipo 1:' El segundo valor especifica el desplazamiento positivo del nominal mientras
viajando en la dirección positiva. El tercer valor especifica el negativo
compensado de nominal mientras viaja en una dirección negativa.
+
+
Ejemplo de tipo 1
+
----
-1.000 0.005 -0.005
0,000 0,002 -0,003
1.000 0.003 -0.004
----

* 'MIN_LIMIT = -1000' - (((MIN LIMIT))) El límite mínimo para el movimiento del eje, en
Unidades de máquina. Cuando se alcanza este límite, el controlador aborta el eje
movimiento El eje debe estar orientado antes de que MIN_LIMIT esté en vigor. Para un rotativo
eje con rotación ilimitada que no tiene MIN_LIMIT para ese eje en el
[JOINT_n], entonces se usa el valor -1e99.

* 'MAX_LIMIT = 1000' - (((MAX LIMIT))) El límite máximo para el movimiento del eje, en
Unidades de máquina. Cuando se alcanza este límite, el controlador aborta el eje
movimiento El eje debe estar alojado antes de que MAX_LIMIT esté en vigor. Para un rotativo
eje con rotación ilimitada que no tiene MAX_LIMIT para ese eje en el
[JOINT_n], luego se usa el valor 1e99.

* 'MIN_FERROR = 0.010' - (((MIN FERROR))) Este es el valor en unidades de máquina por
que el eje puede desviarse de la posición ordenada a muy baja
velocidades. Si MIN_FERROR es más pequeño que FERROR, los dos producen una rampa de
error de puntos de disparo. Podría pensar en esto como un gráfico donde una dimensión es
velocidad y el otro está permitido después del error. A medida que la velocidad aumenta
La cantidad de error de seguimiento también aumenta hacia el valor FERROR.

* 'FERROR = 1.0' - (((FERROR))) FERROR es el error de seguimiento máximo permitido,
en unidades de máquina. Si la diferencia entre la posición ordenada y la detectada
excede esta cantidad, el controlador deshabilita los cálculos servo, establece todos
las salidas a 0.0, y desactiva los amplificadores. Si MIN_FERROR está presente en
el archivo .ini, se utilizan los siguientes errores proporcionales a la velocidad. Aquí el
El error de seguimiento máximo permitido es proporcional a la velocidad, con FERROR
aplicando a la tasa rápida establecida por [TRAJ] MAX_VELOCITY, y proporcionalmente
errores de seguimiento más pequeños para velocidades más lentas. El seguimiento máximo permitido
El error siempre será mayor que MIN_FERROR. Esto evita pequeños seguimientos
errores para ejes estacionarios por abortar inadvertidamente el movimiento. Pequeña
Los siguientes errores siempre estarán presentes debido a la vibración, etc.

* 'LOCKING_INDEXER = 1' -
Indica que la articulación se utiliza como indexador de bloqueo.

.Buscador de blancos

Estos parámetros están relacionados con Homing, para una mejor explicación lea el
<< cha: configuración de referencia, Configuración de referencia >> Capítulo.

* 'INICIO = 0.0' -
La posición a la que irá la articulación al finalizar el recorrido de referencia
secuencia.

* 'HOME_OFFSET = 0.0' -
La posición conjunta del interruptor de inicio o pulso índice, en
<< sec: traj-section, unidades de máquina >>. Cuando se encuentra el punto de inicio durante
En el proceso de referencia, esta es la posición asignada a ese punto.
Al compartir interruptores de inicio y de límite y usar una secuencia de inicio que
deje el interruptor de inicio / límite en el estado activado, el desplazamiento de inicio puede ser
se utiliza para definir la posición del interruptor de inicio para que sea diferente de 0 si su INICIO
Se desea que la posición sea 0.

* 'HOME_SEARCH_VEL = 0.0' -
(((HOME SEARCH VEL))) Velocidad de referencia inicial en unidades de máquina por segundo.
El signo indica la dirección de viaje. Un valor de cero significa asumir que la corriente
La ubicación es la posición de inicio de la máquina. Si su máquina no tiene
interruptores de inicio querrá dejar este valor en cero.

* 'HOME_LATCH_VEL = 0.0' -
Velocidad de referencia en unidades de máquina por segundo a la casa
cambiar la posición del pestillo. El signo indica la dirección de viaje.

* 'HOME_FINAL_VEL = 0.0' -
Velocidad en unidades de máquina por segundo desde la posición de cierre del hogar al hogar
posición. Si se deja en 0 o no se incluye en la articulación, la velocidad rápida es
usado. Debe ser un número positivo.

* 'HOME_USE_INDEX = NO' -
Si el codificador utilizado para esta articulación tiene un pulso índice, y el movimiento
la tarjeta tiene provisión para esta señal, puede configurarla en sí. Cuando es
Sí, afectará el tipo de patrón de inicio utilizado. Actualmente no puedes
inicio para indexar con steppers a menos que esté usando stepgen en modo de velocidad
y PID.

* 'HOME_INDEX_NO_ENCODER_RESET = NO' -
Use SÍ si el codificador utilizado para esta articulación no restablece su contador
cuando se detecta un pulso índice después de la afirmación de la articulación
index_enable hal pin. Aplicable solo para HOME_USE_INDEX = YES.

* 'HOME_IGNORE_LIMITS = NO' -
Cuando usa el interruptor de límite como interruptor de inicio y el interruptor de límite
Esto debe establecerse en SÍ. Cuando se establece en SÍ, el interruptor de límite para esto
la articulación se ignora al dirigir Debes configurar tu referencia
para que al final de la mudanza de su casa el interruptor de inicio / límite no esté en el
Con el estado activado, recibirá un error de interruptor de límite después del traslado de inicio.

* 'HOME_IS_SHARED = <n>' -
Si la entrada de inicio es compartida por más de un conjunto conjunto <n> a 1 para
evitar que se inicie el recorrido de referencia si uno de los conmutadores compartidos es
ya está cerrado. Establezca <n> en 0 para permitir el recorrido de referencia si un interruptor está cerrado.

* 'HOME_ABSOLUTE_ENCODER = 0 | 1 | 2 '-
Usado para indicar que la articulación usa un codificador absoluto. A petición
para el recorrido de referencia, el valor conjunto actual se establece en el valor 'HOME_OFFSET'.
Si la configuración 'HOME_ABSOLUTE_ENCODER' es 1, la máquina hace lo habitual
movimiento final al valor 'INICIO'.
Si la configuración 'HOME_ABSOLUTE_ENCODER' es 2, no se realiza ningún movimiento final.

* 'HOME_SEQUENCE = <n>' -
Se utiliza para definir la secuencia "Inicio todo". <n> debe comenzar en 0 o
1 o -1. Se pueden especificar secuencias adicionales con números crecientes
por 1 (en valor absoluto). No se permite omitir los números de secuencia.
Si se omite una HOME_SEQUENCE, la unión no será alojada por el
Función "Home All". Se puede dirigir más de una articulación al mismo tiempo
tiempo especificando el mismo número de secuencia para más de una articulación.
Se utiliza un número de secuencia negativa para diferir el movimiento final para
todas las articulaciones tienen ese número de secuencia (negativo o positivo).
Para obtener información adicional, consulte: << sec: sección de referencia, SECUENCIA DEL HOGAR >>

* 'VOLATILE_HOME = 0' -
Cuando se habilita (se establece en 1), esta unión no se alojará si la máquina
La alimentación está apagada o si E-Stop está encendido. Esto es útil si su máquina tiene
Home cambia y no tiene retroalimentación de posición, como un paso y
máquina de dirección.

.Servo

Estos parámetros son relevantes para las articulaciones controladas por servos.

[ADVERTENCIA]
Las siguientes son entradas de archivos INI personalizadas que puede encontrar en un archivo INI de muestra
o un archivo generado por asistente. Estos no son utilizados por el software LinuxCNC. Ellos
solo están ahí para poner todas las configuraciones en un solo lugar. Para más información sobre
entradas de archivo INI personalizadas ver el
<< sub: variables personalizadas, Secciones personalizadas y Variables >> subsección.

Los siguientes elementos pueden ser utilizados por un componente PID y la suposición es
que la salida es voltios.

* 'DEADBAND = 0.000015': qué tan cerca está lo suficientemente cerca como para considerar el motor en posición,
en << sec: traj-section, unidades de máquina >>. Esto a menudo se establece en una distancia equivalente a 1, 1.5, 2,
o 3 recuentos de codificador, pero no hay reglas estrictas.
Las configuraciones más sueltas (más grandes) permiten menos 'caza' de servos a expensas de una menor precisión.
Las configuraciones más estrictas (más pequeñas) intentan una mayor precisión a expensas de más servo 'caza'.
¿Es realmente más preciso si también es más incierto?
Como regla general, es bueno evitar, o al menos limitar, la 'caza' de servos si puede.

Tenga cuidado al ir por debajo del recuento de 1 codificador, ya que puede crear una condición donde
no hay lugar donde tu servo sea feliz. Esto puede ir más allá de 'cazar' (lento) a
'nervioso' (rápido), e incluso 'chillido', que es fácil de confundir con
oscilación causada por un ajuste incorrecto. Es mejor ser un conteo o dos sueltos
aquí al principio, hasta que haya pasado por 'afinación bruta' al menos.

Ejemplo de cálculo de unidades de máquina por pulso de codificador para usar al decidir el valor de DEADBAND:

//////////////////////////////////////////////////////////////////////////////////////////////////////////// /////////
latexmath: [\ frac {X \, pulgadas} {1 \, encoder \, count} =
\ frac {1 \, revolution} {1000 \, encoder \, lines} \ times
\ frac {1 \, codificador \, línea} {4 \, cuadratura \, conteos} \ veces
\ frac {0.200 \, pulgadas} {1 \, revolución} =
\ frac {0.200 \, pulgadas} {4000 \, encoder \, recuentos} =
\ frac {0.000050 \, pulgadas} {1 \, encoder \, count}]
//////////////////////////////////////////////////////////////////////////////////////////////////////////// /////////

imagen :: images / encoder-count-math.png [align = "center"]

* 'BIAS = 0.000' - Esto es utilizado por hm2-servo y algunos otros.
El sesgo es una cantidad constante
eso se agrega a la salida. En la mayoría de los casos, debe dejarse en cero.
Sin embargo, a veces puede ser útil para compensar las compensaciones en el servo
amplificadores, o para equilibrar el peso de un objeto que se mueve
verticalmente el sesgo se desactiva cuando el bucle PID está desactivado, al igual que
Todos los demás componentes de la salida.

* 'P = 50' - La ganancia proporcional para el servo conjunto. Este valor
multiplica el
error entre la posición ordenada y la real en unidades de máquina, lo que resulta
en una contribución a la tensión calculada para el amplificador del motor. los
las unidades en la ganancia de P son voltios por unidad de máquina, por ejemplo,
imagen: images / p-term.png [altura = 25]

// latexmath: [$ \ frac {volt} {mu} $].

* 'I = 0' - La ganancia integral para el servo conjunto. El valor
multiplica el
error acumulativo entre la posición ordenada y la real en la máquina
unidades, lo que resulta en una contribución a la tensión calculada para el
Amplificador de motor. Las unidades en la ganancia I son voltios por unidad de máquina
segundo, por ejemplo, image: images / i-term.png [height = 25]

// latexmath: [$ \ frac {volt} {mu \, s} $].

* 'D = 0' - La ganancia derivada para el servo conjunto. El valor
multiplica el
diferencia entre los errores actuales y anteriores, lo que resulta en una
contribución a la tensión calculada para el amplificador del motor. las unidades
en la ganancia D hay voltios por unidad de máquina por segundo, por ejemplo,
imagen: images / i-term.png [altura = 25]

// latexmath: [$ \ frac {volt} {mu / s} $].

* 'FF0 = 0': ganancia de avance de orden 0. Este numero es
multiplicado por el
posición ordenada, lo que resulta en una contribución a la tensión calculada
para el amplificador del motor Las unidades en la ganancia FF0 son voltios por
unidad de máquina, por ejemplo, imagen: images / p-term.png [altura = 25]

// latexmath: [$ \ frac {volt} {mu} $].

* 'FF1 = 0': ganancia de avance de 1er orden. Este numero es
multiplicado por el
cambio en la posición ordenada por segundo, lo que resulta en una contribución a
El voltaje calculado para el amplificador del motor. Las unidades en el FF1 ganan
son voltios por unidad de máquina por segundo, por ejemplo, imagen: images / i-term.png [altura = 25]

// latexmath: [$ \ frac {volt} {mu \, s} $].

* 'FF2 = 0': ganancia de avance de segundo orden. Este numero es
multiplicado por el
cambio en la posición ordenada por segundo por segundo, lo que resulta en un
contribución a la tensión calculada para el amplificador del motor. las unidades
en la ganancia FF2 hay voltios por unidad de máquina por segundo por segundo,
por ejemplo, image: images / ff2.png [height = 25]

// latexmath: [$ \ frac {volt} {mu \, s ^ ​​{2}} $].

* 'OUTPUT_SCALE = 1.000' -

* 'OUTPUT_OFFSET = 0.000': estos dos valores son los factores de escala y compensación para
la salida conjunta a los amplificadores del motor.
El segundo valor (desplazamiento) se resta de
la salida calculada (en voltios), y dividida por el primer valor (escala
factor), antes de ser escrito en los convertidores D / A. Las unidades en el
Los valores de escala están en voltios verdaderos por voltios de salida DAC. Las unidades en el
El valor de compensación está en voltios. Estos se pueden usar para linealizar un DAC.
Específicamente, al escribir salidas, LinuxCNC primero convierte la deseada
salida en unidades cuasi-SI a valores de actuador sin procesar, por ejemplo, voltios para un
amplificador DAC. Esta escala
se parece a: image: images / output-offset.png []

// latexmath: [raw = \ frac {output-offset} {scale}]

El valor de la escala se puede obtener analíticamente haciendo una unidad
análisis, es decir, las unidades son [unidades SI de salida] / [unidades de actuador]. por
ejemplo, en una máquina con un amplificador de modo de velocidad tal que
1 voltio da como resultado una velocidad de 250 mm / seg.

imagen :: images / scale-math.png [align = "center"]

// latexmath: [$ amplifier [volts] = (salida [\ frac {mm} {sec}]
// - desplazamiento [\ frac {mm} {sec}]) / 250 \ frac {mm} {sec \, volt}] $]

Tenga en cuenta que las unidades del desplazamiento están en unidades de máquina, por ejemplo,
mm / seg, y se restan previamente de las lecturas del sensor. El valor
para este desplazamiento se obtiene al encontrar el valor de su salida que
produce 0.0 para la salida del actuador. Si el DAC está linealizado, esto
el desplazamiento es normalmente 0.0.

La escala y el desplazamiento también se pueden usar para linealizar el DAC,
resultando en valores que reflejan los efectos combinados del amplificador
ganancia, no linealidad DAC, unidades DAC, etc.

Para hacer esto, siga este procedimiento.

. Cree una tabla de calibración para la salida, impulsando el DAC con un
Voltaje deseado y medición del resultado.

. Haga un ajuste lineal de mínimos cuadrados para obtener los coeficientes a, b tales
esa imagen: images / calibracion-1.png []
. Tenga en cuenta que queremos una producción sin procesar de modo que nuestro resultado medido sea
idéntico a la salida ordenada. Esto significa
.. image: images / calibracion-2.png []
.. image: images / calibracion-3.png []
. Como resultado, los coeficientes ayb del ajuste lineal pueden ser
utilizado como la escala y el desplazamiento para el controlador directamente.

Consulte la siguiente tabla para ver un ejemplo de mediciones de voltaje.

// latexmath: [meas = a * raw + b]
// latexmath: [cmd = a * raw + b]
// latexmath: [raw = (cmd-b) / a]

Mediciones de voltaje de salida

[ancho = "50%", cols = "2 * ^", opciones = "encabezado"]
| ===============
| Raw | Medido
| -10 | -9,93
| -9 | -8,83
| 0 | -0,03
| 1 | 0,96
| 9 | 9,87
| 10 | 10,87
| ===============

* 'MAX_OUTPUT = 10' - El valor máximo para la salida de la compensación PID
que se escribe en el amplificador del motor, en voltios. El calculado
El valor de salida está sujeto a este límite. El límite se aplica antes
escalado a unidades de salida sin formato. El valor se aplica simétricamente a
tanto el lado positivo como el negativo.

* 'INPUT_SCALE = 20000' - en configuraciones de muestra
* 'ENCODER_SCALE = 20000' - en configuraciones construidas PNCconf
Especifica el número de pulsos que
corresponde a un movimiento de una unidad de máquina como se establece en la sección [TRAJ].
Para una junta lineal, una unidad de máquina será igual a
la configuración de LINEAR_UNITS.
Para una junta angular, una unidad es igual a la configuración en ANGULAR_UNITS.
Un segundo número, si se especifica, se ignora.
Por ejemplo, en un conteo de 2000 por codificador de revoluciones, y 10
engranajes de revoluciones por pulgada y unidades de pulgada deseadas
tener:

image :: images / encoder-scale.png [align = "center"]

// latexmath: [INPUT \ _SCALE =
// \ frac {2000 \, count} {rev} \ times \ frac {10 \, rev} {inch} =
// \ frac {20000 \, recuentos} {pulgadas}]

Paso a paso

Estos parámetros son relevantes para las articulaciones controladas por steppers.

[ADVERTENCIA]
Las siguientes son entradas de archivos INI personalizadas que puede encontrar en un archivo INI de muestra
o un archivo generado por asistente. Estos no son utilizados por el software LinuxCNC. Ellos
solo están ahí para poner todas las configuraciones en un solo lugar. Para más información sobre
entradas de archivo INI personalizadas ver el
<< sub: variables personalizadas, Secciones personalizadas y Variables >> subsección.

Los siguientes elementos pueden ser utilizados por un componente stepgen.

* 'SCALE = 4000' - en configuraciones de muestra
* 'STEP_SCALE = 4000' - en configuraciones construidas PNCconf
Especifica el número de pulsos que corresponde a un
movimiento de una unidad de máquina como se establece en la sección [TRAJ].
Para sistemas paso a paso, esto es
El número de pulsos escalonados emitidos por unidad de máquina. Para una junta lineal
una unidad de máquina será igual a la configuración de LINEAR_UNITS. Por un
la unidad angular de una unidad es igual a la configuración en ANGULAR_UNITS. por
servo sistemas, este es el número de pulsos de retroalimentación por unidad de máquina.
Un segundo número, si se especifica, se ignora.

Por ejemplo, en un motor paso a paso de 1.8 grados con medio paso, y 10
revoluciones por pulgada / pulgada, y deseado << sec: sección de traj, unidades de máquina >> de pulgada, nosotros
tener:

image :: images / stepper-scale.png [align = "center"]

// latexmath: [scale =
// \ frac {2 \, pasos} {1.8 \, grado} \ times \ frac {360 \, grado} {rev} \ times \ frac {10 \, rev} {inch} =
// \ frac {4000 \, pasos} {pulgadas}]

* 'ENCODER_SCALE = 20000' (Opcionalmente utilizado en configuraciones construidas PNCconf) -
Especifica el número de pulsos que
corresponde a un movimiento de una unidad de máquina como se establece en la sección [TRAJ].
Para una junta lineal, una unidad de máquina será igual a
la configuración de LINEAR_UNITS.
Para una junta angular, una unidad es igual a la configuración en ANGULAR_UNITS.
Un segundo número, si se especifica, se ignora.
Por ejemplo, en un conteo de 2000 por codificador de revoluciones, y 10
engranajes de revoluciones por pulgada y unidades de pulgada deseadas
tener:

image :: images / encoder-scale.png [align = "center"]

// latexmath: [ENCODER \ _SCALE =
// \ frac {2000 \, count} {rev} \ times \ frac {10 \, rev} {inch} =
//\frac{20000\, counts}{inch} ]
* 'STEPGEN_MAXACCEL = 21.0' - Límite de aceleración para el generador de pasos.
Esto debería ser del 1% al 10%
más grande que la articulación MAX_ACCELERATION. Este valor mejora la afinación
del "bucle de posición" de stepgen. Si ha agregado compensación de reacción
a una articulación, entonces esto debería ser 1.5 a 2 veces mayor que
MAX_ACCELERATION.

* 'STEPGEN_MAXVEL = 1.4': los archivos de configuración anteriores tienen un límite de velocidad para
el paso
generador también. Si se especifica, también debería ser 1% a 10% más grande
que la articulación MAX_VELOCITY. Pruebas posteriores han demostrado que el uso de
STEPGEN_MAXVEL no mejora el ajuste del bucle de posición del stepgen.


[[sec: emcio-section]] (((Archivo INI, Sección EMCIO)))

=== [EMCIO] Sección

* 'EMCIO = io' - Nombre del programa controlador IO

* 'CYCLE_TIME = 0.100' -
El período, en segundos, en el que se ejecutará EMCIO. Haciendo
es 0.0 o un
un número negativo le dirá a EMCIO que no duerma en absoluto. Generalmente hay
No es necesario cambiar este número.

* 'TOOL_TABLE = tool.tbl' -
El archivo que contiene información sobre herramientas, descrito en
El manual de usuario.

* 'TOOL_CHANGE_POSITION = 0 0 2' -
Especifica la ubicación XYZ a la que moverse al realizar un
cambio de herramienta si se utilizan tres dígitos.
Especifica la ubicación XYZABC cuando se usan 6 dígitos.
Especifica la ubicación XYZABCUVW cuando se utilizan 9 dígitos.
Los cambios de herramienta se pueden combinar. Por ejemplo, si combina el
Relájese con la posición de cambio, puede mover primero la Z y luego la X e Y.

* 'TOOL_CHANGE_WITH_SPINDLE_ON = 1' -
El husillo se dejará encendido durante el cambio de herramienta cuando el valor sea 1.
Útil para tornos o máquinas donde el material está en el husillo,
No es la herramienta.

* 'TOOL_CHANGE_QUILL_UP = 1' -
El eje Z se moverá a la máquina cero antes del cambio de herramienta cuando
el valor es 1. Esto es lo mismo que emitir un G0 G53 Z0.

* 'TOOL_CHANGE_AT_G30 = 1' -
La máquina se mueve al punto de referencia definido por los parámetros.
5181-5186 para G30 si el valor es 1. Para obtener más información, consulte el
<< gcode: parámetros, sección de parámetros y el
<< gcode: g30-g30.1, Sección G30 >>.

* 'RANDOM_TOOLCHANGER = 1' -
Esto es para máquinas que no pueden volver a colocar la herramienta en el bolsillo
vino de. Por ejemplo, máquinas que intercambian la herramienta en el
bolsillo activo con la herramienta en el husillo.



