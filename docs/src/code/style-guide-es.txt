= Estilo de codificación

Este capítulo describe el estilo de código fuente preferido por el equipo LinuxCNC.

== No hacer daño

Al realizar pequeñas ediciones en el código en un estilo diferente al
descrito a continuación, observe el estilo de codificación local. Cambios rápidos de uno
estilo de codificación a otra disminución de la legibilidad del código.

Nunca verifique el código después de ejecutar "sangría" en él. El espacio en blanco
los cambios introducidos por el guion hacen que sea más difícil seguir el
historial de revisión del archivo.

No use un editor que realice cambios innecesarios en los espacios en blanco (por ejemplo,
que reemplaza 8 espacios con un tabulador en una línea, de lo contrario
modificado, o líneas de ajuste de texto no modificadas de otra manera)

== Tabulaciones

Una tabulación siempre corresponde a 8 espacios. No escriba código que
se muestra correctamente solo con una configuración de tabulación diferente.

== Sangría

Use 4 espacios por nivel de sangría. Combinando 8 espacios en una pestaña
es aceptable pero no requerido.

== Colocación de llaves

Ponga la llave de apertura al final de la línea, y ponga la llave de cierre primero:

[fuente, c]
----
si (x) {
    // hacer algo apropiado
}
----

La llave de cierre está en una línea propia, excepto en los casos en que
es seguido por una continuación de la misma declaración, es decir, un 'while'
en una declaración do o un 'else' en una declaración if, así:

[fuente, c]
----
hacer {
    // algo importante
} while (x> 0);
----

y

[fuente, c]
----
si (x == y) {
    // Haz una cosa
} más si (x <y) {
    // haz otra cosa
} más {
    // hacer una tercera cosa
}
----

Esta colocación de llaves también minimiza el número de vacíos (o casi
líneas vacías), lo que permite una mayor cantidad de código o comentarios
visible a la vez en un terminal de un tamaño fijo.

== Naming

C es un lenguaje espartano, y así debería ser tu nombre. A diferencia de Modula-2
y los programadores Pascal, los programadores C no usan nombres lindos como
ThisVariableIsATemporaryCounter. Un programador de C llamaría eso
variable 'tmp', que es mucho más fácil de escribir, y no menos importante
difícil de comprender.

Sin embargo, los nombres descriptivos para las variables globales son imprescindibles. Llamar a un
La función global 'foo' es un delito de tiro.

Las variables GLOBALES (para usarse solo si * realmente * las necesita) necesitan
tener nombres descriptivos, al igual que las funciones globales. Si
tiene una función que cuenta el número de usuarios activos, debe
 llame a eso 'count_active_users ()' o similar, debe * no * llamarlo
'cntusr ()'.

Codificar el tipo de una función en el nombre (llamado húngaro
notación) tiene daño cerebral: el compilador conoce los tipos de todos modos y
puede verificarlos, y solo confunde al programador. No es de extrañar
Microsoft hace programas con errores.

Los nombres de variables LOCALES deben ser cortos y al grano. Si usted tiene
algún contador de bucle entero aleatorio, probablemente debería llamarse 'i'.
Llamarlo 'loop_counter' no es productivo, si no hay posibilidad de
siendo mal entendido Del mismo modo, 'tmp' puede ser casi cualquier tipo de
variable que se utiliza para mantener un valor temporal.

Si tiene miedo de mezclar sus nombres de variables locales, tiene
otro problema, que se llama desequilibrio de la hormona del crecimiento funcional
síndrome. Ver el siguiente capítulo.

== Funciones

Las funciones deben ser cortas y dulces, y hacer una sola cosa. Ellos
debe caber en una o dos pantallas de texto (el tamaño de pantalla ISO / ANSI
es 80x24, como todos sabemos), y hacer una cosa y hacerlo bien.

La longitud máxima de una función es inversamente proporcional a la
complejidad y nivel de sangría de esa función. Entonces, si tienes un
función conceptual simple que es solo una larga (pero simple)
caso-declaración, donde tienes que hacer muchas cosas pequeñas para muchos
diferentes casos, está bien tener una función más larga.

Sin embargo, si tiene una función compleja y sospecha que un
estudiante de primer año de secundaria menos que superdotado podría ni siquiera
entienda de qué se trata la función, debe adherirse a
límites máximos tanto más de cerca. Usar funciones de ayuda con
nombres descriptivos (puede pedirle al compilador que los incorpore si
piensa que es crítico para el rendimiento, y probablemente hará un mejor trabajo
de lo que habrías hecho).

Otra medida de la función es el número de variables locales. Ellos
no debe exceder de 5-10, o estás haciendo algo mal. Repensar el
función, y dividirlo en pedazos más pequeños. Un cerebro humano generalmente puede
realizar un seguimiento de aproximadamente 7 cosas diferentes, cualquier cosa más y
se confunde Sabes que eres brillante, pero tal vez te gustaría
Entiende lo que hiciste dentro de 2 semanas.

== comentando

Los comentarios son buenos, pero también existe el peligro de comentar en exceso.
NUNCA intente explicar CÓMO funciona su código en un comentario: es mucho mejor
escribir el código para que el * funcionamiento * sea obvio, y es un desperdicio de
Es hora de explicar el código mal escrito.

En general, desea que sus comentarios digan QUÉ hace su código, no
CÓMO. Un comentario en recuadro que describe la función, el valor de retorno y quién
lo llama colocado encima del cuerpo es bueno. Además, trate de evitar poner
comentarios dentro del cuerpo de una función: si la función es tan compleja que
necesita comentar partes por separado, probablemente debería volver a leer el
Sección de funciones de nuevo. Puede hacer pequeños comentarios para anotar o advertir
sobre algo particularmente inteligente (o feo), pero trate de evitar el exceso.
En su lugar, coloque los comentarios al frente de la función, diciéndoles a las personas
lo que hace, y posiblemente POR QUÉ lo hace.

Si se utilizan comentarios en la línea de / * Fix me * /, por favor, por favor,
decir por qué algo necesita ser reparado. Cuando se ha realizado un cambio en el
parte afectada del código, elimine el comentario o modifíquelo para
indica que se ha realizado un cambio y necesita pruebas.

== Scripts de Shell y Makefiles

No todos tienen las mismas herramientas y paquetes instalados. Algunas personas
use vi, otros emacs: algunos incluso evitan tener cualquiera de los paquetes
instalado, prefiriendo un editor de texto liviano como nano o el
construido en Midnight Commander.

gawk versus mawk - Nuevamente, no todos tendrán gawk instalado, mawk
es casi una décima parte del tamaño y, sin embargo, se ajusta al Posix AWK
estándar. Si se necesita algún comando específico de gawk oscuro que mawk
no proporciona, que el script se romperá para algunos usuarios. Lo mismo
se aplicaría a mawk. En resumen, use la invocación genérica awk en
preferencia a gawk o mawk.

== Convenciones de C ++

Los estilos de codificación de C ++ siempre terminan en acalorados debates (un poco
como los argumentos de emacs versus vi). Una cosa es cierta, sin embargo, un
El estilo común utilizado por todos los que trabajan en un proyecto conduce a la uniformidad y
código legible

Convenciones de nomenclatura: constantes de #defines o enumeraciones
debe estar en mayúscula de afuera hacia afuera. Justificación: hace que sea más fácil detectar
compila constantes de tiempo en el código fuente. p.ej. EMC_MESSAGE_TYPE

Las clases y los espacios de nombres deben poner en mayúscula la primera letra de cada palabra
y evitar guiones bajos. Justificación: identifica clases, constructores y
destructores p.ej. GtkWidget

Los métodos (o nombres de funciones) deben seguir las recomendaciones C anteriores
y no debe incluir el nombre de la clase. Justificación: mantiene un común
estilo en fuentes C y C ++. p.ej. get_foo_bar ()

Sin embargo, los métodos booleanos son más fáciles de leer si evitan los guiones bajos
y use un prefijo 'is' (no debe confundirse con los métodos que manipulan
un booleano). Justificación: identifica el valor de retorno como VERDADERO o FALSO y
nada más. p.ej. isOpen, isHomed

NO use 'No' en un nombre booleano, solo conduce a confusión
Al hacer pruebas lógicas. p.ej. isNotOnLimit o is_not_on_limit son MALOS.

Los nombres de las variables deben evitar el uso de mayúsculas y guiones bajos
a excepción de nombres locales o privados. El uso de variables globales debería
evitarse tanto como sea posible. Justificación: aclara cuáles son
variables y cuales son los métodos. Público: p. axislimit Privado: p.
Velocidad máxima_

Convenciones de nomenclatura de métodos específicos

Los términos get y set deben usarse donde se accede a un atributo
directamente. Justificación: indica el propósito de la función o método.
p.ej. get_foo set_bar

Para los métodos que involucran atributos booleanos, se prefiere establecer y restablecer.
Justificación: como arriba. p.ej. set_amp_enable reset_amp_fault

Los métodos intensivos en matemáticas deben usar el cálculo como prefijo. Razón fundamental:
Muestra que es computacionalmente intensivo y acaparará la CPU. p.ej.
compute_PID

Las abreviaturas en los nombres deben evitarse siempre que sea posible.
la excepción es para nombres de variables locales. Justificación: claridad del código. p.ej.
se prefiere el puntero sobre el cómputo ptr se prefiere sobre la comparación cmp es
de nuevo preferido sobre cmp.

Las enumeraciones y otras constantes pueden tener como prefijo un nombre de tipo común
p.ej. enumeración COLOR {COLOR_RED, COLOR_BLUE};

Se debe evitar el uso excesivo de macros y definiciones.
Se prefieren métodos o funciones. Justificación: mejora la depuración
proceso.

Los archivos de encabezado Incluir declaraciones deben incluirse en la parte superior de un
archivo fuente y no disperso por todo el cuerpo. Ellos deberían ser
ordenados y agrupados por su posición jerárquica dentro del sistema
con los archivos de bajo nivel incluidos primero. Incluir rutas de archivo deben
NUNCA sea absoluto: use el compilador -I flag en su lugar. Razón fundamental:
Los encabezados pueden no estar en el mismo lugar en todos los sistemas.

Los punteros y las referencias deben tener su símbolo de referencia junto al
nombre de la variable en lugar del nombre del tipo. Justificación: Reduce la confusión.
p.ej. float * x o int & i

Las pruebas implícitas para cero no deben usarse excepto para booleano
variables p.ej. if (spindle_speed! = 0) NO if (spindle_speed)

Solo las declaraciones de control de bucle deben incluirse en una construcción for ().
p.ej. suma = 0; para (i = 0; i <10; i ++) {sum + = value [i]; }

NO para (i = 0, suma = 0; i <10; i ++) suma + = valor [i];

Del mismo modo, deben evitarse las declaraciones ejecutables en condicionales. p.ej.
if (fd = open (nombre_archivo) es malo.

Deben evitarse las declaraciones condicionales complejas - Introducir temporal
variables booleanas en su lugar.

Los paréntesis deben usarse en abundancia en las expresiones matemáticas.
no confíe en la precedencia del operador cuando un paréntesis adicional aclararía
cosas.

Nombres de archivo: las fuentes y los encabezados de C ++ usan la extensión .cc y .hh. El uso
de .c y .h están reservados para C. sin formato Los encabezados son para clase, método,
y declaraciones de estructura, no código (a menos que se declaren las funciones
en línea).

== Estándares de codificación de Python

Utilice el estilo http://www.python.org/dev/peps/pep-0008/[PEP 8] para
Código de Python

== Estándares de codificación comp

En la parte de declaración de un archivo .comp, comience cada declaración en
La primera columna. Insertar líneas en blanco adicionales cuando ayudan a grupos relacionados
artículos.

En la parte del código de un archivo .comp, siga el estilo de codificación C normal.


