:lang: es

[[cha:code-notes]]

= Notas sobre el código

== Público objetivo

Este documento es una colección de notas sobre los aspectos internos de LinuxCNC.
Es de interés principalmente para los desarrolladores. Sin embargo, gran parte de la información
también puede ser de interés para los integradores de sistemas y otros que tienen
simplemente curiosidad sobre cómo funciona LinuxCNC. Mucha de esta información esta ahora
desactualizada y su exactitud nunca ha sido revisada.

== Organización

Habrá un capítulo para cada uno de los componentes principales de LinuxCNC,
así como un capitulo sobre como trabajan juntos. Este documento es
un trabajo en progreso, y su diseño puede cambiar en el futuro.


== Términos y definiciones

* 'EJE (AXIS)': un eje es uno de los nueve grados de libertad que definen la
    posición de una herramienta en el espacio cartesiano tridimensional. Esos nueve ejes son
    referidos como  X, Y, Z, A, B, C, U, V y W. Las coordenadas ortagonales lineales
    X, Y y Z determinan dónde está posicionada la punta de la herramienta.
    Las coordenadas angulares A, B y C determinan la orientación de la herramienta.
    Un segundo conjunto de coordenadas lineales ortagonales U, V y W
    permite el movimiento de la herramienta (típicamente para acciones de corte) en relación con los
    ejes previamente desplazados y girados.
    Desafortunadamente, "eje" también se utiliza a veces para referirse a un grado de libertad de la propia máquina,
    como el carro transversal, la mesa o la pínola de una máquina fresadora tipo Bridgeport. En
    una Bridgeport esto no causa confusión, ya que el movimiento de la mesa, por ejemplo,
    corresponde directamente al movimiento a lo largo del eje X. Sin embargo,
    las articulaciones del hombro y el codo de un brazo robot o los accionadores lineales de un
    hexápodo no corresponden al movimiento a lo largo de ningún eje cartesiano.
    En general, es importante hacer la distinción entre los ejes cartesianos
    y los grados de libertad de la máquina. En este documento, esto último
    se llamarán 'articulaciones', no ejes. (Las GUIs y algunas otras partes del
    código no siempre puede seguir esta distinción, pero los elementos internos de
    el controlador de movimiento si lo hacen.)


* 'ARTICULACION (JOINT)': una articulacion es cada una de las partes móviles de una máquina. Las articulaciones son
    distintas de los ejes, aunque los dos términos se usan (mal) a veces para referirse
    a lo mismo. En LinuxCNC, una articulacion es una cosa física que puede ser
    movida, no una coordenada en el espacio. Por ejemplo, la pinola, la mensula, el carro transversal,
    o la mesa de una fresadora Bridgeport son articulaciones. El hombro, codo y
    muñeca de un brazo de robot son articulaciones, al igual que los accionadores lineales de un hexápodo.
    Cada articulacion tiene asociado un motor o actuador de algún tipo.
    Las articulaciones no se corresponden necesariamente con los ejes X, Y y Z,
    aunque para máquinas con cinemática trivial puede ser el caso.
    Incluso en esas máquinas, la posición de la articulacion y la posición del eje son
    cosas fundamentalmente diferentes. En este documento, los términos 'articulacion' y
    'eje' se usan cuidadosamente para respetar sus distintos significados.
    Desafortunadamente, eso no es necesariamente cierto en otros lugares.
    En particular, las GUI para máquinas con cinemática trivial pueden pasar por alto u
    ocultar completamente la distinción entre articulaciones y ejes. Adicionalmente,
    el archivo ini usa el término 'eje' para datos que serían descritos más precisamente
    como datos de articulacion, tales como escalado de entrada y salida, etc.

    N.T. Esta diferencia ya está recojida en las versiones mas recientes de LinuxCNC. Los archivos
    .INI ya tienen una seccion [JOINT_n] para cada articulacion.

[[pose-def]]
* 'POSE': una pose es una posición completamente especificada en el espacio cartesiano 3D. En
    el controlador de movimiento LinuxCNC, cuando nos referimos a una pose nos referimos a una
    estructura EmcPose, que contiene seis coordenadas lineales (X, Y, Z, U, V, y W) y tres angulares (A, B y C).

== Visión general de la arquitectura

La arquitectura de LinuxCNC contiene cuatro componentes: un controlador de movimiento(EMCMOT),
un controlador de IO discretas (EMCIO), un ejecutor de tareas que los coordina (EMCTASK) y
varias interfaces de usuario, en modos texto o gráfico.
Cada una de ellas será descrita en el presente documento, tanto desde el punto de vista del diseño
como desde el punto de vista de los desarrolladores (dónde encontrar los datos necesarios, cómo
ampliar/modificar fácilmente cosas, etc.).

image::LinuxCNC-block-diagram-small.png[align="center"]

La arquitectura del software LinuxCNC, a nivel más basico, es una
jerarquía de tres controladores: (1) el controlador de comandos de nivel de tarea y el programa
intérprete, (2) el controlador de movimiento y (3) el controlador de E/S discretas.
El controlador de E/S discretas se implementa como una jerarquía de controladores,
en este caso para los subsistemas husillo, refrigerante y auxiliar (por ejemplo, e-stop, lubricacion, etc.)
El controlador de tareas coordina las acciones de los controladores de movimiento y
de E/S discretas. Sus acciones están programadas en programas de control numérico
de "código G y M" convencional, que son interpretadas por
el controlador de tareas y se envían al Controlador de movimiento o
de E/S discretas como mensajes NML en los momentos apropiados.

== Introducción al controlador de movimiento

El controlador de movimiento recibe comandos de los módulos de espacio de usuario a través de una
memoria intermedia compartida, y ejecuta esos comandos en tiempo real.
El estado del controlador se pone a disposición de los módulos de espacio de usuario
a través de la misma área de memoria compartida. El controlador de movimiento interactúa
con los motores y otro hardware utilizando HAL (Capa de Abstracción del Hardware).
Este documento asume que el lector tiene un entendimiento básico de HAL, y utiliza términos como
pines HAL, señales HAL, etc., sin explicárlos, Para más información sobre HAL, vea el
capitulo HAL. Otro capítulo de este documento entrará
eventualmente en las partes internas de la propia HAL, pero en este
capítulo, solo usaremos la API HAL, tal como se define en src/hal/hal.h.

image::LinuxCNC-motion-controller-small.png[align="center"]

== Diagramas de bloques y flujo de datos

La siguiente figura es un diagrama de bloques de un controlador de articulaciones. Hay un controlador por articulacion.
Estos controladores funcionan a un nivel más bajo que la cinemática, un nivel
donde todas las articulaciones son completamente independientes. Todos los datos para una articulación
están en una sola estructura articular. Algunos miembros de esa estructura son
visibles en el diagrama de bloques, como coarse_pos, pos_cmd y motor_pos_fb.

image::emc2-motion-joint-controller-block-diag.png[align="center"]

.Diagrama de bloques del controlador de articulación

La figura de arriba muestra cinco de los
siete conjuntos de información de posición que forman el flujo principal de datos a través
del controlador de movimiento. Las siete formas de datos de posición son las siguientes:

. 'emcmotStatus\->carte_pos_cmd' - Esta es la posición deseada, en
   coordenadas cartesianas. Se actualiza a la velocidad de traj, no a la de servo.
   En modo coordinado y en modo teleop, está determinado por el planificador de trayectorias. 
   En modo libre, es copiado bien de actualPos, o generado mediante la aplicación de cimematica directa a (2) o a
   (3).
. 'emcmotStatus\->joints[n].coarse_pos' - Esta es la posición deseada, en
   coordenadas de articulacion, pero antes de la interpolación. Se actualiza a la tasa de traj,
   no a la de servo. En modo coordinado y en modo teleop, se genera aplicando
   cimematica inversa a (1). En modo libre, se copia de (3), creo.
. 'emcmotStatus\->joints[n].pos_cmd - Esta es la posición deseada, en
   coordenadas de articulacion, después de la interpolación. Cada periodo servo se genera
   un nuevo conjunto de estas coordenadas. En modo coordenadas y en modo teleop, se genera desde (2)
   por el interpolador. En modo libre, es generado por el planificador de trayectorias de modo libre.
. 'emcmotStatus\->joints[n].motor_pos_cmd' - Esta es la posición deseada,
   en coordenadas de motor. Las coordenadass del motor son generadas agregando la compensación
   backlash, compensación de error del tornillo de avance, y offset (para homing) a
   (3). Se genera de la misma manera independientemente del modo, y es la
   salida al bucle PID u otro bucle de posición.
. 'emcmotStatus\->joints[n].motor_pos_fb' - Esta es la posición actual, en
   coordenadas del motor. Es la entrada de los codificadores u otro dispositivo de retroalimentación
   (o de codificadores virtuales en máquinas de bucle abierto). Es "generado" por
   lectura del dispositivo de retroalimentación.
. 'emcmotStatus\->joints[n].pos_fb' - Esta es la posición real, en coordenadas de articulación.
   Se genera restando el offset, la compensación de error de tornillo de avance
   y la compensación de backlash de (5). Se genera
   de la misma manera independientemente del modo de operación.
. 'emcmotStatus\->carte_pos_fb' - Esta es la posición actual, en coordenadas cartesianas.
   Se actualiza a la velocidad de traj, no a la de servo.
   Idealmente, actualPos siempre se calcularía aplicando
   cinemática directa a (6). Sin embargo, la cinemática directa puede no estar disponible, o
   pueden ser inutilizables porque uno o más ejes no están alineados. En ese
   caso, las opciones son: A) falsificarlo copiando (1), o B) admitir que
   no sé saben realmente las coordenadas cartesianas, y simplemente no actualizar
   actualPos. Cualquiera que sea el método utilizado, no veo ninguna razón para no hacerlo
   de la misma manera independientemente del modo de operación. Propondría lo
   siguiente: si hay cinemática directa, usarla, a menos que no funcionen
   debido a ejes sin homing u otros problemas, en cuyo caso se hara (B). Si no hay
   cinemática directa, hacer (A), ya que de lo contrario actualPos _nunca_ sera
   actualizado.

== Homing

=== Diagrama de estado de Homing

image::homing.svg[align="center"]

=== Otro diagrama homing

image::hss.svg[align="center"]

== Comandos

Esta sección simplemente lista todos los comandos que se pueden enviar al
módulo de movimiento, junto con explicaciones detalladas de lo que hacen.
Los nombres de los comandos se definen en una gran typedef enum en
emc2/src/emc/motion/motion.h, llamada cmd_code_t. (Tenga en cuenta que en el
código, cada nombre de comando comienza con 'EMCMOT_', que se omite aquí.)

Los comandos se implementan mediante una gran instrucción switch en la
función emcmotCommandHandler(), que se llama a la velocidad de servo.
Más sobre esa función más adelante.

Hay aproximadamente 44 comandos. Esta lista todavía está bajo
construcción.

=== ABORT

El comando ABORT simplemente detiene todo movimiento. Puede ser emitido en cualquier
momento, y siempre será aceptado. No desactiva el controlador de movimiento
o cambia cualquier información de estado; simplemente cancela cualquier
movimiento que esté actualmente en progreso. footnote:[Parece que
el código de nivel superior (TASK y superior) también usa ABORT para borrar fallos.
Siempre que haya un fallo persistente (como estar fuera de los
interruptores de límite hardware), el código de nivel superior envía un flujo constante
de ABORTs al controlador de movimiento en la esperanza de que la causa del fallo
desaparezca.... miles de ellos ... Eso significa que el controlador de movimiento
debe evitar fallos persistentes. Esto necesita ser investigado.]

==== Requisitos

Ninguno. El comando siempre se acepta y actúa de inmediato.

==== Resultados

En modo libre, los planificadores de trayectoria en modo libre quedan deshabilitados. Como
resultado, cada articulacion de detiene tan rápido como su límite de aceleración (desaceleración)
permite. La parada no está coordinada. En modo teleop, la velocidad cartesiana comandada se pone a cero.
No sé exactamente qué tipo de parada resulta (coordinada, no coordinada, etc.), pero lo resolveremos
finalmente. En el modo coordinado, se le dice al planificador de trayectoria de modo coordinado que
aborte el movimiento actual. Una vez más, no sé el resultado exacto de esto,
pero lo documentaré cuando lo descubra.

=== FREE

El comando FREE pone el controlador de movimiento en modo libre. Modo libre
significa que cada articulación es independiente las demas articulaciones. 
Las coordenadas cartesianas, las poses y la cinemática se ignoran cuando se 
encuentra en modo libre.
En esencia, cada articulación tiene su propio planificador simple de trayectoria, y cada
articulación ignora completamente a las otras. Algunos comandos (como Joint
JOG y HOME) solo funcionan en modo libre. Otros comandos, incluyendo cualquier cosa
que trata con coordenadas cartesianas, no funciona en modo libre.

==== Requisitos

El controlador de comandos no aplica requisitos para el comando FREE,
que será siempre aceptado. Sin embargo, si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG() == FALSE), entonces el comando será ignorado.
Este comportamiento está controlado por un código que ahora se encuentra en la función
'set_operating_mode()' en control.c, ese código necesita ser limpiado.
Creo que el comando no debe ser ignorado en silencio; el controlador de comandos
debe determinar si se puede ejecutar y devolver un error si no se puede.

==== Resultados

Si la máquina ya está en modo libre, no devuelve nada. De lo contrario,
la máquina se coloca en modo libre. El planificador de trayectoria de modo libre
de cada articulación se inicializa en la ubicación actual de la articulación, pero
no están habilitados y las articulaciones quedan estacionarias.

=== TELEOP

El comando TELEOP coloca la máquina en modo teleoperador. En modo teleop,
el movimiento de la máquina se basa en coordenadas cartesianas utilizando
cinemática, en lugar de articulaciones individuales como en modo libre. Sin embargo,
el planificador de trayectoria per se no se usa. En su lugar, el movimiento es
controlado por un vector de velocidad. El movimiento en modo teleop es muy parecido a
jogging, excepto que se realiza en el espacio cartesiano en lugar de en el espacio de
articulaciones. En una máquina con cinemática trivial, hay poca diferencia
entre el modo teleop y el modo libre, y las GUI para esas máquinas podrían
ni siquiera emitir este comando. Sin embargo, para máquinas no triviales como
robots y hexápodos, el modo teleop se utiliza para la mayoría de los movimientos tipo 
jogs ordenados por el usuario


==== Requisitos

El controlador de comandos rechazará el comando TELEOP con un mensaje de error
si la cinemática no se puede activar porque una o más
articulaciones no han sido puestas a home. Además, si alguna articulación está en movimiento.
(GET_MOTION_INPOS_FLAG() == FALSE), entonces el comando será ignorado
(sin mensaje de error). Este comportamiento es controlado por el código que
ahora se encuentra en la función 'set_operating_mode()' en control.c.
Creo que el comando no debe ser ignorado en silencio; el controlador de comandos
debe determinar si se puede ejecutar y devolver un error si no se puede.

==== Resultados

Si la máquina ya está en modo teleop, no devuelve nada. De lo contrario,
la máquina se coloca en modo teleop. El código de cinemática queda activado,
Los interpoladores se drenan y se nivelan, y los comandos de velocidad cartesiana
se ponen a cero.

=== COORD

El comando COORD coloca la máquina en modo coordinado. En modo coordinado,
el movimiento de la máquina se basa en coordenadas cartesianas utilizando
cinemática, en lugar de articulaciones individuales como en modo libre.
Además, para generar movimiento se utiliza el planificador principal de trayectoria, basado
en los comandos en cola LINE, CIRCLE, y/o PROBE. El modo coord es el modo
que se utiliza cuando se ejecuta un programa de código G

==== Requisitos

El controlador de comandos rechazará el comando COORD con un mensaje de error
si la cinemática no se puede activar porque una o más
articulaciones no han sido puestas a home. Además, si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG() == FALSE), entonces el comando será ignorado
(sin mensaje de error). Este comportamiento es controlado por el código que es
ahora se encuentra en la función 'set_operating_mode()' en control.c.
Creo que el comando no debe ser ignorado en silencio; el controlador de comandos
debe determinar si se puede ejecutar y devolver un error si no se puede.

==== Resultados

Si la máquina ya está en modo coordinado, no devuelve nada. De lo contrario,
la máquina se coloca en modo coordinado. El código de cinemática queda activado,
los interpoladores se drenan y se nivelan, y las colas del planificador de trayectoria
quedan vacías. El planificador de trayectoria está activo y en espera de un comando
LINE, CIRCLE, o PROBE.

=== ENABLE

El comando ENABLE habilita el controlador de movimiento.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Si el controlador ya está habilitado, no devuelve nada. Si no, el controlador
queda habilitado. Las colas y los interpoladores se limpian. Cualquier movimiento u
operaciones de homing se terminan. Las salidas amp-enable asociadas
con articulaciones activas se encienden. Si la cinemática directa no esta
disponible, la máquina cambia al modo libre.

=== DISABLE

El comando DISABLE deshabilita el controlador de movimiento.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Si el controlador ya está deshabilitado, no devuelve nada. Si no, el controlador
queda desactivado. Las colas y los interpoladores se limpian. Cualquier movimiento u
operaciones de homing se terminan. Las salidas amp-enable asociadas
con las articulaciones activas se apagan. Si la cinemática directa no esta
disponible, la máquina cambia al modo libre.

=== ENABLE_AMPLIFIER

El comando ENABLE_AMPLIFIER activa la salida de habilitación de amplificador para un
amplificador de salida única, sin cambiar nada más. Puede ser usado para
habilitar un controlador de velocidad de husillo.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Actualmente, ninguno. (la antigua llamada a la función extAmpEnable esta
actualmente comentada). Eventualmente configurará el pin HAL de amplificador
habilitado a True.

=== DISABLE_AMPLIFIER

El comando DISABLE_AMPLIFIER desactiva la salida de habilitación del amplificador para un
amplificador único, sin cambiar nada más. De nuevo, útil para
controladores de velocidad de husillo.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Actualmente, ninguno. (la antigua llamada a la función extAmpEnable esta
actualmente comentada). Eventualmente configurará el pin HAL de amplificador
habilitado a False.

=== ACTIVATE_JOINT

El comando ACTIVATE_JOINT activa todos los cálculos asociados
con una sola articulacion, pero no cambia el pin de salida de habilitación del amplificador
de la articulacion.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Los cálculos para la articulacion especificada quedan habilitados. El pin que habilita
el amplificador no se cambia. Sin embargo, cualquier comando subsiguiente ENABLE o DISABLE
modifica el pin de habilitación del amplificador de la articulacion.

=== DEACTIVATE_JOINT

El comando DEACTIVATE_JOINT desactiva todos los cálculos asociados
con una sola articulacion, pero no cambia el pin de salida de habilitación del amplificador
de la articulacion.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Los cálculos para la articulacion especificada quedan (des?)habilitados. El pin que habilita
el amplificador no se cambia. Cualquier comando subsiguiente ENABLE o DISABLE
NO modifica el pin de habilitación del amplificador de la articulacion.

=== ENABLE_WATCHDOG

El comando ENABLE_WATCHDOG habilita un watchdog basado en hardware (si esta
presente).

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Actualmente nada. El viejo watchdog era una cosa extraña que usaba una
tarjeta de sonido específica. Se podra diseñar una nueva interfaz watchdog en el
futuro.

=== DISABLE_WATCHDOG

El comando DISABLE_WATCHDOG desactiva un watchdog basado en hardware (si esta
presente).

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Actualmente nada. El viejo watchdog era una cosa extraña que usaba una
tarjeta de sonido específica. Se podra diseñar una nueva interfaz watchdog en el
futuro.

=== PAUSE

El comando PAUSE detiene el planificador de trayectoria. No tiene efecto en
modo libre o teleop. En este punto no sé si detiene todo movimiento
inmediatamente, o si completa el movimiento actual y luego se detiene antes
de extraer otro movimiento de la cola.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

El planificador de trayectoria se detiene.

=== RESUME

El comando RESUME reinicia el planificador de trayectoria si está en pausa. Esto
no tiene efecto en modo libre o teleop, o si el planificador no está en pausa.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Se reanuda el planificador de trayectoria.

=== STEP

El comando STEP reinicia el planificador de trayectoria si está en pausa, y
le dice al planificador que se detenga de nuevo cuando llegue a un punto específico. Esto
no tiene efecto en modo libre o teleop. En este punto no sé
exactamente cómo funciona esto. Añadiré más documentación aquí cuando explore
más profundamente en el planificador de trayectoria.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

El planificador de trayectoria se reanuda, y luego se detiene cuando alcanza un
punto específico.

=== SCALE

El comando SCALE escala todos los límites de velocidad y los comandos por una
cantidad especificada. Se utiliza para implementar el reajuste de la velocidad de alimentación y otras
funciones similares. El escalado funciona en los modos libre, teleop y coord,
y afecta a todo, incluyendo las velocidades de homing, etc. Sin embargo,
los límites de velocidad de las articulaciones individuales no se ven afectados.

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado.

==== Resultados

Todos los comandos de velocidad se escalan por la constante especificada.

=== OVERRIDE_LIMITS

El comando OVERRIDE_LIMITS evita que los límites se disparen hasta el
final del siguiente comando JOG. Normalmente se utiliza para permitir que una máquina
salga de un interruptor de límite después de dispararse. (El comando,
en realidad, se puede utilizar para anular límites o para cancelar una anulación previa.)

==== Requisitos

Ninguno. El comando puede ser emitido en cualquier momento, y siempre será
aceptado. (Creo que solo debería funcionar en modo libre).

==== Resultados

Los límites en todas las articulaciones se anulan hasta el final del siguiente JOG.
(Esto no funciona actualmente ... una vez que un comando OVERRIDE_LIMITS
se recibe, los límites se ignoran hasta que otro comando OVERRIDE_LIMITS
vuelve a habilitarlos.)

=== HOME

El comando HOME inicia una secuencia home en una articulacion específica.
La secuencia de inicio real está determinada por una serie de parámetros de configuracion
y puede variar desde simplemente establecer la posición actual hasta
cero, a una búsqueda en etapas múltiples de un interruptor home y un pulso de índice,
seguido de un traslado a una posicion home arbitraria. Para más información
sobre la secuencia de inicio, vea la sección de inicio del Manual del integrador.

==== Requisitos

El comando se ignorará silenciosamente a menos que la máquina esté en modo libre.

==== Resultados

Cualquier movimiento de jog u otro movimiento conjunto se aborta, y empieza la secuencia home.

=== JOG_CONT

El comando JOG_CONT inicia un jog continuo en una sola articulación. Un
jog continuo se genera configurando la posición de destino del planificador
de trayectoria de modo libre a un punto más allá del final de recorrido de la articulación.
Esto asegura que el planificador se moverá constantemente hasta que sea detenido por los
límites de articulacion o por un comando ABORT.
Normalmente, una GUI envía un comando JOG_CONT cuando el usuario presiona un botón jog,
y ABORT cuando se suelta el botón.

==== Requisitos

El controlador de comandos rechazará el comando JOG_CONT con un mensaje de error
si la máquina no está en modo libre o si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG() == FALSE), o si el movimiento no está habilitado.
También se ignorará silenciosamente el comando si la unión ya está en o
más allá de su límite y el jog ordenado lo empeoraría.

==== Resultados

El planificador de trayectoria de modo libre para la articulación identificada por
emcmotCommand\->axis es activado, con una posición de destino más allá del final
del recorrido de la articulacion, y un límite de velocidad de emcmotCommand\->vel. Esto
comienza el movimiento de la articulación, y el movimiento continuará hasta que sea detenido por un
comando ABORT o al tocar un límite. El planificador de modo libre acelera hasta
el límite de aceleración de articulacion al comienzo del movimiento, y
desacelerara con el mismo límite, cuando se detiene.

=== JOG_INCR

El comando JOG_INCR inicia un jog incremental en una única articulacion.
Los jogs incrementales son acumulativos; en otras palabras, emitiendo dos comandos JOG_INCR
que cada uno pide 0,100 pulgadas de movimiento, resultarán en
0.200 pulgadas de desplazamiento, incluso si el segundo comando se emite antes de
que el primero acabe. Normalmente los jogs incrementales se detienen cuando han
recorrió la distancia deseada. Sin embargo, también se detienen cuando alcanzan un
límite, o en un comando ABORT.

==== Requisitos

El controlador de comandos rechazará silenciosamente el comando JOG_INCR si
la máquina no está en modo libre, o si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG() == FALSE), o si el movimiento no está habilitado.
También se ignorará silenciosamente el comando si la unión ya está en o
más allá de su límite y el jog ordenado lo empeoraría.

==== Resultados

El planificador de trayectoria de modo libre para la articulación identificada por
emcmotCommand\->axis está activado, la posición de destino es
incrementada/decrementada por emcmotCommand\->offset, y la velocidad límite
se establece en emcmotCommand\->vel. El planificador de trayectoria en modo libre
generará un movimiento trapezoidal suave desde la posición actual hasta
la posición de destino. El planificador puede manejar correctamente los cambios en la
posición de destino que sucedan mientras el movimiento está en progreso, por lo que múltiples
comandos JOG_INCR se pueden emitir en rápida sucesión. El planificador de modo libre
acelera hasta el límite de aceleración de articulacion al comienzo del
movimiento, y  desacelerará con ese mismo límite hasta  detenerse en la
posición objetivo.

=== JOG_ABS

El comando JOG_ABS inicia un jog absoluto en una única articulación. Un
jog absoluto es un movimiento simple a una ubicación específica, en coordenadas de articulación.
Normalmente los jogs absolutos se detienen cuando alcanzan la ubicación deseada.
Sin embargo, también se detienen cuando se alcanzan un límite, o en un comando ABORT.

==== Requisitos

El controlador de comandos rechazará silenciosamente el comando JOG_ABS si
la máquina no está en modo libre, o si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG() == FALSE), o si el movimiento no está habilitado.
También ignorará silenciosamente el comando si la articulación ya está en o
más allá de su límite y el jog ordenado lo empeoraría.

==== Resultados

El planificador de trayectoria de modo libre para la articulación identificada por
emcmotCommand\->axis está activado, la posición de destino se establece en
emcmotCommand\->offset, y el límite de velocidad se establece en
emcmotCommand\->vel. El planificador de trayectoria de modo libre generará un
movimiento trapezoidal suave desde la posición actual hasta la posición objetivo.
El planificador puede manejar correctamente los cambios en la posicion objetivo
que sucedan mientras el movimiento está en progreso. Si múltiples comandos JOG_ABS
se emiten en rápida sucesión, cada nuevo comando cambia la
posición de destino y la máquina pasa a la posición final ordenada.
El planificador de modo libre
acelera hasta el límite de aceleración de articulacion al comienzo del
movimiento, y  desacelerará con ese mismo límite hasta  detenerse en la
posición objetivo.

=== SET_LINE

El comando SET_LINE agrega una línea recta a la cola del planificador de trayectoria.

(Más, despues)

=== SET_CIRCLE

El comando SET_CIRCLE agrega un movimiento circular a la cola del planificador de trayectoria.

(Más, despues)

=== SET_TELEOP_VECTOR

El comando SET_TELEOP_VECTOR le indica al controlador de movimiento que se mueva
a lo largo de un vector específico en el espacio cartesiano.

((Más, despues))

=== PROBE

El comando PROBE le indica al controlador de movimiento que se mueva hacia un
punto específico en el espacio cartesiano, deteniendose y registrando su
posición si la entrada de la sonda se dispara.

((Más, despues))

=== CLEAR_PROBE_FLAG

El comando CLEAR_PROBE_FLAG se usa para restablecer la entrada de la sonda en
preparación para un comando PROBE. (Pregunta: ¿por qué no debería el comando PROBE
reiniciar automáticamente la entrada?)

((Más, despues))

=== SET_xxx

Hay aproximadamente 15 comandos SET_xxx, donde xxx es el nombre de
algún parámetro de configuración. Se anticipa que habrá
varios comandos SET más a medida que se agregan más parámetros. Me gustaría
encontrar una forma más limpia de configurar y leer los parámetros de configuración.
Los métodos existentes requieren que se agreguen muchas líneas de código a múltiples
archivos cada vez que se agrega un parámetro. Gran parte de ese código es idéntico o
casi idéntico para cada parámetro.


== Compensación de error de tornillo y backlash

 +

== Controlador de tareas (EMCTASK)

=== Estado

Task tiene tres estados internos posibles: *E-stop*, *E-stop Reset*,
y *Machine On*.

image::task-state-transitions.svg[align = "center"]

== Controlador IO (EMCIO)

El controlador de E/S es un módulo separado que acepta comandos NML de TASK. +
Interactúa con E/S externas utilizando pines HAL. +
iocontrol.cc se carga a través del script linuxcnc antes de TASK. +
Actualmente hay dos versiones de iocontrol. La segunda versión maneja los errores de hardware de cambio de herramienta +
+

Actualmente ESTOP/Enable, el refrigerante, el lubricante y el cambio de herramientas son manejados por +
iocontrol. Estos son eventos de velocidad relativamente baja; las E/S coordinadas de alta velocidad se manejan en motion.+
 +

emctaskmain.cc envía comandos de E/S a través de taskclass.cc +
Las funciones de Taskclass envían mensajes NML a iocontrol.cc +
taskclass usa los comandos definidos en c++ en su archivo o, +
si está definido, ejecuta comandos basados en python definidos en archivos proporcionados por el usuario. +
+

Proceso de bucle principal de iocontrol:

- registros para señales SIGTERM y SIGINT del sistema operativo. +
- comprueba si las entradas HAL han cambiado +
- comprueba si read_tool_inputs() indica que el cambio de herramienta ha finalizado y establece emcioStatus.status +
- busca mensajes NML relacionados con E/S +
  +

números de mensaje nml: de emc.hh:

#define EMC_IO_INIT_TYPE                             ((NMLTYPE) 1601) +
#define EMC_TOOL_STAT_TYPE                           ((NMLTYPE) 1199) +
#define EMC_TOOL_INIT_TYPE                           ((NMLTYPE) 1101) +
#define EMC_TOOL_HALT_TYPE                           ((NMLTYPE) 1102) +
#define EMC_TOOL_ABORT_TYPE                          ((NMLTYPE) 1103) +
#define EMC_TOOL_PREPARE_TYPE                        ((NMLTYPE) 1104) +
#define EMC_TOOL_LOAD_TYPE                           ((NMLTYPE) 1105) +
#define EMC_TOOL_UNLOAD_TYPE                         ((NMLTYPE) 1106) +
#define EMC_TOOL_LOAD_TOOL_TABLE_TYPE                ((NMLTYPE) 1107) +
#define EMC_TOOL_SET_OFFSET_TYPE                     ((NMLTYPE) 1108) +
#define EMC_TOOL_SET_NUMBER_TYPE                     ((NMLTYPE) 1109) +
// el siguiente mensaje se envía a io al comienzo de un M6 +
// incluso antes de que emccanon emita el movimiento a la posición de cambio de herramienta +
#define EMC_TOOL_START_CHANGE_TYPE ((NMLTYPE) 1110) +


== Interfaces de usuario

 +

== Introducción a libnml 

libnml se deriva de rcslib de NIST sin todo el apoyo multiplataforma.
Muchos de los wrappers alrededor del código específico de una plataforma han sido
eliminados junto con gran parte del código que no es requerido por LinuxCNC.
Espero que quedara suficiente compatibilidad con rcslib para que
las aplicaciones puedan implementarse en plataformas que no sean Linux y aún pueden ser
capaz de comunicarse con LinuxCNC.

Este capítulo no pretende ser una guía definitiva para el uso de libnml
(o rcslib); en cambio, eventualmente proporcionará una visión general de cada
clase C++ y sus funciones miembro. Inicialmente, la mayoría de estas notas
se agregarán como comentarios aleatorios a medida que el código sea examinado y modificado.

== LinkedList

Clase base para mantener una lista enlazada. Este es uno de los bloques de construccion centrales
utilizados para pasar mensajes NML y una variedad de estructuras de datos internos.

== LinkedListNode

Clase base para producir una lista enlazada - Propósito, mantener punteros a
los nodos anterior y siguiente, puntero a los datos y tamaño de los
datos.

No se asigna memoria para el almacenamiento de datos.

== Memoria compartida (SharedMemory)

Proporciona un bloque de memoria compartida junto con un semáforo (heredado
de la clase Semaphore). La creación y destrucción del semáforo es
manejada por el constructor y destructor SharedMemory.

== Buffer de memoria compartida (ShmBuffer)

Clase para pasar mensajes NML entre procesos locales usando una 
memoria intermedia compartida. Gran parte del funcionamiento interno se hereda de la clase CMS.

== Temporizador (Timer)

La clase Timer proporciona un temporizador periódico limitado solo por la
resolución del reloj del sistema. Si, por ejemplo, un proceso necesita ser
ejecutado cada 5 segundos, independientemente del tiempo necesario para ejecutar el proceso,
el siguiente fragmento de código muestra cómo:

[source,c]
----
main()
{
    timer = new Timer(5.0);    /* Inicializar un temporizador con un bucle de 5 segundos */
    while(0) {
        /* Hacer algún proceso */
        timer.wait();    /* Espere hasta el siguiente intervalo de 5 segundos */
    }
    delete timer;
}
----

== Semáforo (Semaphore)

La clase Semaphore proporciona un método de exclusiones mutuas para
acceder a un recurso compartido. La función para obtener un semáforo se puede
bloquear hasta que el acceso esté disponible, regresar después de un tiempo de espera o regresar
inmediatamente con o sin ganar el semáforo. El constructor
crea un semáforo o adjúnta a uno existente si el ID ya está en
uso.

Semaphore::destroy() debe ser llamado por el último proceso solamente.

== CMS

En el corazón de libnml se encuentra la clase CMS, que contiene la mayoría de las
funciones utilizadas por libnml y en última instancia NML. Muchas de las funciones internas
están sobrecargadas para permitir métodos de paso de datos dependientes del hardware.
En definitiva, todo gira en torno a un
bloque central de memoria (denominado "búfer de mensajes" o simplemente
'buffer'). Este búfer puede existir como un bloque de memoria compartida accedido por
otros procesos CMS/NML, o un búfer local y privado para datos que se están
transfiriendo por red o interfaces seriales.

El búfer se asigna dinámicamente en tiempo de ejecución para permitir una mayor
flexibilidad del subsistema CMS/NML. El tamaño del buffer debe ser suficientemente grande
para acomodar el mensaje más grande, mas una pequeña cantidad para uso interno
y permitir que el mensaje se codifique si se elige esta opción
(los datos codificados se tratarán más adelante). La siguiente figura es una
vista interna del espacio buffer.

image::CMS_buffer.png [align = "center"]

.buffer CMS 

La clase base de CMS es principalmente responsable de crear las
vías de comunicación e interconexión al O.S.

////////////////////////////////////////////////////////////////////////
== NML Notes /* FIX ME */

Colección de notas aleatorias y pensamientos mientras se estudia libnml.
y el código rcslib.

Mucho de esto necesita ser editado y reescrito de manera coherente
antes de su publicación.
///////////////////////////////////////////////////////////////////////

== Formato de archivo de configuración

La configuración de NML consiste en dos tipos de formatos de línea. Uno para
Buffers, y un segundo para Procesos que se conectan a los buffers.

=== línea de búfer

El formato NIST original de la línea de búfer es:

* 'B name type host size neut RPC# buffer# max_procs key [tipo específico de configuración]'

* 'B': identifica esta línea como una configuración de búfer.
* 'name' - es el identificador del búfer.
* 'type': describe el tipo de búfer: SHMEM, LOCMEM, FILEMEM, PHANTOM o GLOBMEM.
* 'host' - es una dirección IP o nombre de host para el servidor NML
* 'size' - es el tamaño del búfer
* 'neut': un valor booleano para indicar si los datos en el búfer están codificados en un
     formato independiente de la máquina, o en bruto.
* 'RPC#' - Obsoleto - Se retiene el marcador de posición solo por compatibilidad con versiones anteriores.
* 'buffer#': un número de ID único que se usa si un servidor controla varios buffers.
* 'max_procs' - es el máximo de procesos permitidos para conectarse a este búfer.
* 'key': es un identificador numérico para un búfer de memoria compartida

=== Tipo especifico de configuracion

El tipo de búfer implica opciones de configuración adicionales mientras que
el sistema operativo del host excluye ciertas combinaciones. En una tentativa de
extraer la documentación publicada en un formato coherente, solo se cubrirá el tipo de búfer *SHMEM*

* 'mutex=os_sem': modo predeterminado para proporcionar un semáforo de bloqueo del buffer.
* 'mutex=none' - No utilizado
* 'mutex=no_interrupts' - no aplicable en un sistema Linux
* 'mutex=no_switching' - no aplicable en un sistema Linux
* 'mutex=mao split' - divide el búfer a la mitad (o más) y permite
     que un proceso acceda a parte del búfer mientras que un segundo proceso esta
     escribiendo en la otra parte.
* 'TCP=(número de puerto)'- especifica qué puerto de red usar.
* 'UDP=(número de puerto)' - ídem
* 'STCP=(número de puerto)' - ídem
* 'serialPortDevName = (puerto serie)' - No documentado.
* 'passwd=file_name.pwd' - agrega una capa de seguridad al búfer al
     requerir que cada proceso proporcione una contraseña.
* 'bsem': la documentación de NIST implica una clave para un semáforo de bloqueo,
     y si bsem=-1, se evitan los bloqueos de lecturas.
* 'queue' - Habilita el paso de mensajes en cola.
* 'ascii' - codifica mensajes en un formato de texto plano
* 'disp' - Codifica los mensajes en un formato adecuado para la visualización (???)
* 'xdr' - Codifica mensajes en representación de datos externos (XDR). (vea rpc/xdr.h para más detalles).
* 'diag': habilita los diagnósticos almacenados en el búfer (¿temporizaciones y conteos de bytes?)

=== Línea de proceso

El formato NIST original de la línea de proceso es:

* P name buffer type host ops server timeout master c_num [configuraciones específicas de tipo]*

* 'P': identifica esta línea como una configuración de proceso.
* 'name' - es el identificador del proceso.
* 'buffer' - es uno de los buffers definidos en otro lugar en el archivo de configuración.
* 'type' - define si este proceso es local o remoto en relación con el búfer.
* 'host' - especifica dónde se está ejecutando este proceso en la red.
* 'ops' - le da al proceso permiso de solo lectura, solo escritura o de lectura/escritura al búfer.
* 'server' - especifica si este proceso ejecutará un servidor para este búfer.
* 'timeout' - establece las características de tiempo de espera para los accesos al búfer.
* 'master' - indica si este proceso es responsable de crear y destruir el búfer.
* 'c_num' - un número entero entre cero y (max_procs -1)

=== Comentarios de configuración

Algunas de las combinaciones de configuración son inválidas, mientras que otras
implican ciertas restricciones. En un sistema Linux, GLOBMEM es obsoleto,
mientras que PHANTOM solo es realmente útil en la etapa de prueba de una
aplicación. Igualmente para FILEMEM. LOCMEM es de poca utilidad para una
aplicación multiprocesos y solo ofrece limitadas ventajas de rendimiento sobre SHMEM.
Esto deja a SHMEM como el único tipo de búfer para usar con LinuxCNC.

La opción neut es solo de uso en un sistema multiprocesador donde
arquitecturas diferentes (e incompatibles) están compartiendo un bloque de
memoria. La probabilidad de ver un sistema de este tipo fuera de un
museo o laboratorio de investigación es remoto y solo es relevante para
buffers GLOBMEM.

El número de RPC está documentado como obsoleto y solo se conserva
por razones de compatibilidad.

Con un nombre de búfer único, tener una identidad numérica parece ser
inútil. Se necesita revisar el código para identificar la lógica. Del mismo modo,
el campo key parece ser redundante en principio y podría derivarse
desde el nombre del búfer.

El propósito de limitar el número de procesos permitidos para conectarse a
cualquier búfer no está claro a partir de la documentación existente y del
código fuente original. Permitir procesos múltiples no especificados para
conectarse a un búfer no es más difícil de implementar.

Los tipos de exclusión mutua se reducen a uno de dos; el predeterminado "os_sem" o "mao split".
La mayoría de los mensajes NML son relativamente cortos y se pueden copiar
hacia o desde el búfer con retrasos mínimos, por lo que las lecturas divididas no son
esenciales.

La codificación de datos solo es relevante cuando se transmite a un proceso remoto.
El uso de TCP o UDP implica codificación XDR. La codificación ASCII puede tener
algo de uso en diagnósticos o para pasar datos a un sistema integrado que
no implementa NML.

Los protocolos UDP tienen menos controles de datos y permiten que caigan un porcentaje de
paquetes. TCP es más confiable, pero es ligeramente más lento.

Si LinuxCNC se va a conectar a una red, uno esperaría que fuese
local y detrás de un firewall. La única razón para permitir el acceso a
LinuxCNC a través de Internet sería para diagnósticos remotos. Esto puede ser
logrado de manera mucho más segura utilizando otros medios, tal vez por un interfaz web.

El comportamiento exacto cuando el tiempo de espera se establece a cero o a un valor negativo
no está claro a partir de los documentos del NIST. Solo los valores de INF y positivos son
mencionados. Sin embargo, subyacente en el código fuente de rcslib, es evidente
que se aplica lo siguiente:

timeout > 0 - Bloqueo de acceso hasta que se alcanza el intervalo timeout o
el acceso al búfer está disponible.

timeout = 0 - El acceso al búfer solo es posible si no hay otro proceso que
está leyendo o escribiendo en ese momento.

timeout < 0 o INF - El acceso está bloqueado hasta que el búfer esté disponible.

== clase base NML
// FIX ME

Ampliar las listas y la relación entre NML, NMLmsg y la
clases de nivel inferior cms.

No debe confundirse con NMLmsg, RCS_STAT_MSG o RCS_CMD_MSG.

NML es responsable de analizar el archivo de configuración, configurar los buffers cms
y es el mecanismo para enrutar mensajes al/los buffer/s correcto/s.
Para hacer esto, NML crea varias listas para:

* Los buffers cms creados o conectados.
* Procesos y buffers a los que se conectan.
* una larga lista de funciones de formato para cada tipo de mensaje.

Este último elemento es probablemente el nudo de gran parte de la malignidad de
libnml/rcslib y NML en general. Cada mensaje que se pasa a través de NML
requiere que se adjunte una cierta cantidad de información además de
los datos reales. Para ello, se llaman varias funciones de formato en
secuencia para ensamblar fragmentos del mensaje general. Las funciones de formato
incluirán NML_TYPE, MSG_TYPE, además de los datos
declarados en las clases derivadas de NMLmsg. Cambios en el orden en el que
se llaman a las funciones de formato y también las variables pasadas
rompe la compatibilidad con rcslib: hay razones para
mantener la compatibilidad con rcslib, y buenas razones para jugar con el
código. La pregunta es, ¿qué conjunto de razones están prevaleciendo?

=== Interioridades de NML

==== constructor NML

NML::NML() analiza el archivo de configuración y lo almacena en una lista enlazada para ser
pasado a los constructores de cms en lineas simples. Es función del
constructor de NML llamar al constructor de cms relevante para cada búfer
y mantener una lista de los objetos cms y los procesos asociados
con cada búfer.

A partir de los punteros almacenados en las listas, NML puede interactuar con
cms, lo que explica por qué Doxygen no muestra las relaciones reales involucradas.

[NOTE]
La configuración se almacena en la memoria antes de pasar un puntero a
una línea específica al constructor de cms. El constructor de cms entonces analiza
la línea nuevamente para extraer un par de variables ... Tendria más
sentido hacer TODO el análisis y guardar las variables en una estructura que se
pasase al constructor cms - Esto eliminaría el manejo de cadenas
y reduciria el codigo duplicado en cms ....

==== lectura/escritura NML

Las llamadas a NML::read y NML::write realizan tareas similares en la forma
de procesar el mensaje - La única variación real está en la
dirección del flujo de datos.

Una llamada a la función de lectura primero obtiene datos del búfer, luego
llama a format_output(), mientras que una función de escritura llamaría
format_input() antes de pasar los datos al búfer. El trabajo de construir o deconstruir el
el mensaje está dentro de format_xxx(). A su vez, se llama una lista de funciones variadas para
colocar varias partes del encabezado NML (no debe confundirse con el encabezado cms)
en el orden correcto: la última función llamada es emcFormat() en
emc.cc.

==== NMLmsg y relaciones NML

NMLmsg es la clase base de la que se derivan todas las clases de mensajes.
Cada clase de mensaje debe tener una ID única definida (y pasada al
constructor) y también una función update(*cms), que será
llamada por las funciones de lectura/escritura NML cuando se llama al formateador NML
- El puntero al formateador habrá sido declarado en el constructor NML
en algún momento. En virtud de las listas enlazadas NML creadas,
es capaz de seleccionar el puntero cms que se pasa al formateador y
por lo tanto, qué buffer se va a utilizar.

== Añadiendo comandos NML personalizados

LinuxCNC es bastante impresionante, pero algunas partes necesitan algunos ajustes. Como sabemos
la comunicación se realiza a través de canales NML. Los datos enviados a través de tales
canales eson una de las clases definidas en emc.hh (implementado en
emc.cc). Si alguien necesita un tipo de mensaje que no existe, debe
seguir estos pasos para agregar uno nuevo. (El mensaje que agregamos en el
ejemplo se llama EMC_IO_GENERIC (hereda de EMC_IO_CMD_MSG, que hereda de
RCS_CMD_MSG))

. agregue la definición de la clase EMC_IO_GENERIC a emc2/src/emc/nml_intf/emc.hh
. agregue el tipo define: #define EMC_IO_GENERIC_TYPE ((NMLTYPE) 1605) +
.. (se elige 1605 simplemente porque estaba disponible) a emc2/src/emc/nml_intf/emc.hh
. agregue el caso EMC_IO_GENERIC_TYPE a emcFormat en emc2/src/emc/nml_intf/emc.cc
. agregue el caso EMC_IO_GENERIC_TYPE a emc_symbol_lookup en emc2/src/emc/nml_intf/emc.cc
. añada la funcion EMC_IO_GENERIC::update a emc2/src/emc/nml_intf/emc.cc

Recompile, y el nuevo mensaje debería estar allí. La siguiente parte es
envar tales mensajes desde algún lugar y recibirlos en otro,
y hacer algunas cosas con ellos.


== La tabla de herramientas y el cambiador de herramientas

LinuxCNC interactúa con el hardware del cambiador de herramientas y tiene una abstracción interna
del cambiador de herramientas. LinuxCNC gestiona la información de la herramienta en un archivo
de tabla de herramientas.



=== Abstracción del cambiador de herramientas en LinuxCNC

LinuxCNC soporta dos tipos de hardware de cambio de herramientas, que
se llama _nonrandom_ y _random_. El ajuste ini
<<sec:emcio-section,[EMCIO]RANDOM_TOOLCHANGER>> controla cuál
es el tipo de hardware al que LinuxCNC está conectado.


==== Cambiadores de herramientas nonrandom

El hardware de cambiador de herramientas no aleatorio pone cada herramienta de nuevo en el bolsillo desde
la que fue originalmente cargada.

Ejemplos de hardware de cambiador de herramientas no aleatorio son el cambiador de herramientas "manual",
torretas de herramientas para tornos, y racks.

Cuando se configura para un cambiador de herramientas no aleatorio, LinuxCNC no cambia el
número de bolsillo en el archivo de tabla de herramientas a medida que las herramientas se cargan y descargan.
Internamente a LinuxCNC, en el cambio de herramienta, la información de la herramienta se copia
del bolsillo fuente de la tabla de herramientas al bolsillo 0 (que representa el
husillo), reemplazando la información de la herramienta que se encontraba anteriormente.

NOTA: En LinuxCNC configurado para un cambiador de herramientas no aleatorio, la herramienta 0 (T0) tiene
significado especial: "sin herramienta". Es posible que T0 no aparezca en el archivo de la tabla de herramientas, y
cambiar a T0 resultará en que LinuxCNC asumira que tiene el husillo vacío.


==== Cambiadores de herramientas Random

El hardware de cambiador de herramientas al azar intercambia la herramienta en el husillo (si existe) con
la herramienta solicitada en el cambio de herramienta. Así, el bolsillo en el que reside una herramienta
cambia a medida que estas se intercambian dentro y fuera del husillo.

Un ejemplo de hardware de cambiador de herramientas al azar es un cambiador de herramientas de carrusel.

Cuando se configura para un cambiador de herramientas al azar, LinuxCNC intercambia el número de bolsillo
de la herramienta antigua y la nueva en el archivo de tabla de herramientas cuando se cargan las herramientas.
Internamente a LinuxCNC, en el cambio de herramienta, la información de la herramienta está *intercambiada*
entre el bolsillo fuente de la tabla de herramientas y el bolsillo 0 (que representa
el husillo). Así que después de un cambio de herramienta, el bolsillo 0 en la tabla de herramientas tiene
la información de la nueva herramienta y el bolsillo del que la nueva herramienta
proviene tiene la información de la herramienta antigua (la herramienta que estaba
en el husillo antes del cambio de herramienta), en su caso.

NOTA: En LinuxCNC configurado para un cambiador de herramientas aleatorio, la herramienta 0 (T0) *no* tiene
significado especial. Se trata exactamente como cualquier otra herramienta en la tabla de herramientas.
Es habitual usar T0 para representar "sin herramienta" (es decir, una herramienta con
cero TLO), para que el eje pueda vaciarse convenientemente cuando sea necesario.


=== La tabla de herramientas

LinuxCNC realiza un seguimiento de las herramientas en un archivo llamado <<sec:tool-table,tabla de herramientas>>. 
La tabla de herramientas registra la siguiente información para cada herramienta:

número de herramienta::

    Un entero que identifica de forma única esta herramienta. Los números de herramientas son
    manejado de forma diferente por LinuxCNC cuando se configura para cambiadores de herramientas
    aleatorios y no aleatorios:

    * Cuando LinuxCNC está configurado para un cambiador de herramientas no aleatorio, este
        número debe ser positivo. T0 recibe un manejo especial y no esta
        permitido que aparezca en la tabla de herramientas.

    * Cuando LinuxCNC está configurado para un cambiador de herramientas al azar, este número
        debe ser no negativo. T0 está permitido en la tabla de herramientas, y
        normalmente se utiliza para representar "sin herramienta", es decir, bolsillo vacío.

número de bolsillo::

    Un entero que identifica el bolsillo o la ranura en el hardware cambiador de herramientas
    donde reside la herramienta. Los números de bolsillo son manejados de forma
    diferente por LinuxCNC cuando se configura para cambiadores de herramientas aleatorio o
    no aleatorio:

    * Cuando LinuxCNC está configurado para un cambiador de herramientas no aleatorio, el número
        de bolsillo en el archivo de herramienta puede ser cualquier entero positivo (el bolsillo
        0 no está permitido). LinuxCNC compacta silenciosamente los numeros de bolsillo
        cuando se carga el archivo de herramientas, por lo que puede haber una diferencia
        entre los números de bolsillo en el archivo de herramientas y los 
        números de bolsillo internos utilizados por LinuxCNC con cambiador de herramientas no aleatorio.

    * Cuando LinuxCNC está configurado para un cambiador de herramientas al azar,
        los números en el archivo de la herramienta deben estar entre 0 y 55, ambos inclusive.
        Los bolsillos 1-55 están en el cambiador de herramientas, el bolsillo 0 es el husillo.

diámetro::

    Diámetro de la herramienta, en unidades de máquina.

desplazamiento de la longitud de la herramienta::

    Desplazamiento de la longitud de la herramienta (también llamado TLO), en hasta 9 ejes, en unidades máquina.
    Los ejes que no tienen un TLO especificado asumen 0.


=== Codigos G que afectan a las herramientas

Los codigos G que usan o afectan la información de la herramienta son:


==== Txxx

Le dice al hardware del cambiador de herramientas que se prepare para cambiar a una determinada
herramienta +xxx+.

Manejado por + Interp::convert_tool_select()+.

. Se le pide a la máquina que se prepare para cambiar a la herramienta seleccionada
    llamando a la función canonica +SELECT_POCKET()+ con el número de bolsillo
    de la herramienta solicitada.

    .. (saicanon) No-op.

    .. (emccanon)crea un mensaje +EMC_TOOL_PREPARE+ con el número de bolsillo
        solicitado y lo envía a Task, que lo envía
        a IO. IO recibe el mensaje y le pide a HAL que prepare
        el bolsillo configurando +iocontrol.0.tool-prep-pocket+,
        +iocontrol.0.tool-prep-number+, y +iocontrol.0.tool-prepare+.
        IO luego llama repetidamente a +read_tool_inputs()+ para sondear el pin HAL
        +iocontrol.0.tool-ready+, que emite señales desde el cambiador de herramientas
        hardware, a través de HAL, a IO para que se complete la preparación de la herramienta solicitada.
        Cuando ese pin se hace verdadero, IO establece +emcioStatus.tool.pocketPrepped+
        al número de bolsillo de la herramienta solicitada.

. De vuelta en interp, a +settings->selected_pocket+ se le asigna el numero de bolsillo
    de la herramienta solicitada _xxx_.

==== M6

Le dice al cambiador de herramientas que cambie a la herramienta seleccionada actualmente (seleccionada
por el anterior comando Txxx).

Manejado por +Interp::convert_tool_change()+.

. Se le pide a la máquina que cambie a la herramienta seleccionada
    llamando a la función canonica +CHANGE_TOOL()+ con
    +settings->selected_pocket+.

    .. (saicanon) Establece el sai +_active_slot+ en el número de bolsillo que se pasa.
        La información de la herramienta se copia del bolsillo seleccionado
        de la tabla de herramientas (es decir, de sai +_tools[_active_slot]+)
        al husillo (también conocido como sai +_tools[0]+).

    .. (emccanon) Envía un mensaje +EMC_TOOL_LOAD+ a Task, que
        lo envía a IO. IO establece +emcioStatus.tool.toolInSpindle+
        al número de herramienta de la herramienta en el bolsillo identificado
        por +emcioStatus.tool.pocketPrepped+ (establecido por +Txxx+
        alias +SELECT_POCKET()+). A continuación, solicita que el
        hardware del cambiador de herramientas realize un cambio de herramienta, configurando
        el pin HAL +iocontrol.0.tool-change+ a True. Luego,
        IO +read_tool_inputs()+ detectará que el pin HAL
        +iocontrol.0.tool_changed+ se ha establecido en True, lo que indica que
        el cambiador de herramientas ha completado el cambio de herramienta. Cuando esto pasa,
        llama a +load_tool()+ para actualizar el estado de la máquina.

        ... +load_tool()+ con un cambiador de herramientas no aleatorio
            copia la información de la herramienta desde el bolsillo seleccionado
            al husillo (bolsillo 0).

        ... + load_tool()+ con un cambiador de herramientas al azar intercambia la
            información entre el bolsillo 0 (el husillo) y el 
            bolsillo seleccionado, y luego guarda la tabla de herramientas.

. De vuelta en interp, +settings->current_pocket+ se le asigna la nueva
    herramienta desde +settings->selected_pocket+ (establecido por +Txxx+).
    Los parámetros numerados (<<sub:parámetros numerados,#5400-#5413>>)
    se actualizan con la nueva información de la herramienta desde el bolsillo 0 (husillo).



==== G43/G43.1/G49

Aplica el desplazamiento de longitud de la herramienta. G43 usa el TLO de la herramienta cargada actualmente,
o de una herramienta especificada si la palabra H está dada en el bloque. G43.1 obtiene
TLO desde las palabras de eje en el bloque. G49 cancela el TLO (usa 0 para
el offset en todos los ejes).

Controlado por+Interp::convert_tool_length_offset()+.

. Comienza por construir un +EmcPose+ que contiene las compensaciones de los 9 ejes.
    Para +G43.1+, estas compensaciones de herramienta provienen de las palabras del eje en el
    bloque actual. Para +G43+ estas compensaciones provienen de la herramienta actual
    (la herramienta en el bolsillo 0), o de la herramienta especificada por la palabra H en
    el bloque. Para G49, las compensaciones son todas 0.

. Las compensaciones se pasan a la función +USE_TOOL_LENGTH_OFFSET()+ de Canon.

    .. (saicanon) Graba el TLO en +_tool_offset+ .

    .. (emccanon) Crea un mensaje +EMC_TRAJ_SET_OFFSET+ que contiene el
        offset y lo envía a Task, que copia las compensaciones a
        +emcStatus->task.toolOffset+ y los envía a Motion a través de
        un comando +EMCMOT_SET_OFFSET+ . Motion copia las compensaciones
        a +emcmotStatus->tool_offset+ , donde se usa para compensar
        movimientos futuros.

. De vuelta en interp, las compensaciones se registran en +settings->tool_offset+.
    El bolsillo efectivo se registra en +settings->tool_offset_index+,
    aunque este valor nunca se usa.


==== G10 L1/L10/L11

Modifica la tabla de herramientas.

Manejado por +Interp::convert_setup_tool()+ .

. Escoge el número de herramienta de la palabra P en el bloque y encuentra el
    bolsillo para esa herramienta:

        .. Con una configuración de cambiador de herramientas no aleatoria, este es siempre el
            número de bolsillo en el cambiador de herramientas (incluso cuando la herramienta está en
            el husillo).

        .. Con una configuración de cambiador de herramientas al azar, si la herramienta está actualmente
            cargada utiliza el bolsillo 0 (bolsillo 0 significa "el husillo"),
            y si la herramienta no está cargada, utiliza el número de bolsillo en
            el cambiador de herramientas. (Esta diferencia es importante.)

. Averigua cuáles deberían ser las nuevas compensaciones.

. La nueva información de la herramienta (diámetro, desplazamientos, ángulos y orientación),
    junto con el número de herramienta y el número de bolsillo, se pasan a la llamada Canon
    SET_TOOL_TABLE_ENTRY().

    .. (saicanon) Copia la nueva información de la herramienta en el bolsillo especificado
        (en la tabla de herramientas interna de sai, +_tools+).

    .. (emccanon) Construye un mensaje +EMC_TOOL_SET_OFFSET+ con la nueva
        información de la herramienta, y la envia a Task, que la pasa
        a IO. IO actualiza el bolsillo especificado a su
        copia interna de la tabla de herramientas (+emcioStatus.tool.toolTable+), y
        si la herramienta especificada está cargada actualmente (se compara con
        +emcioStatus.tool.toolInSpindle+) la nueva información de la herramienta
        también se copia en el bolsillo 0 (el husillo). (FIXME: eso es un
        buglet, solo debe copiarse en máquinas no aleatorias.) Finalmente IO
        guarda la nueva tabla de herramientas.

. De vuelta en interp, si la herramienta modificada está cargada actualmente en el
    husillo, y si la máquina es un cambiador de herramientas no aleatorio, entonces
    la nueva información de la herramienta se copia del bolsillo de origen
    al bolsillo 0 (el husillo) en la copia de la tabla de herramientas de interp,
    +settings->tool_table+ (Esta copia no es necesaria en máquinas con cambiador aleatorio de
    herramienta porque las herramientas no tienen un bolsillo y
    en su lugar, simplemente actualizamos la herramienta en el bolsillo 0 directamente.)

. Los parámetros numerados relevantes
    (<<sub:parámetros numerados,#5400-#5413>>) se actualizan desde la información de herramienta
    en el husillo (copiando la información de +settings->tool_table+ to +settings->parameters+). (FIXME: esto es
    un buglet, los parámetros solo deberían actualizarse si fue la
    herramienta actual la que fue modificada).

. Si la herramienta modificada está cargada actualmente en el
    husillo, y si la configuración es para un cambiador de herramientas no aleatorio, entonces
    la nueva información de la herramienta también se escribe en el bolsillo 0 de la tabla de herramientas,
    a través de una segunda llamada a SET_TOOL_TABLE_ENTRY(). (Esta segunda actualización de tabla de herramientas
    no es necesaria en máquinas de cambio de herramientas al azar porque
    las herramientas no tienen un bolsillo fijo y, en cambio, solo actualizamos la herramienta
    en el bolsillo 0 directamente.)


==== M61

Establecer el número actual de la herramienta. Esto cambia la representación interna de LinuxCNC.
de qué herramienta está en el husillo, sin mover realmente el cambiador de herramientas
o intercambiando cualquier herramienta.

Manejado por +Interp::convert_tool_change()+.

Canon: +CHANGE_TOOL_NUMBER()+

settings->current_pocket tiene asignado el número de bolsillo actualmente
sosteniendo la herramienta especificada por el argumento de la palabra Q.


==== G41/G41.1/G42/G42.1

Habilitar la compensación del radio de corte (generalmente llamada _cutter comp_).

Controlado por +Interp::convert_cutter_compensation_on()+.

No hay llamada Canon, la compensación de corte ocurre en el intérprete. Utiliza la tabla de herramienta
de la forma esperada: si se proporciona un número de herramienta de la palabra D, se busca
el número de bolsillo del número de herramienta especificado en la tabla, y si
no se suministra la palabra D, utiliza el bolsillo 0 (el husillo).


==== G40

Cancela la compensación del radio de corte.

Controlado por +Interp::convert_cutter_compensation_off()+.

No hay llamada Canon, la compensación de corte ocurre en el intérprete. No se usa
la tabla de herramientas





=== Variables internas de estado 

¡Esta no es una lista exhaustiva! La información de la herramienta se propaga a través de
LinuxCNC.


==== IO

+emcioStatus+ es de tipo +EMC_IO_STAT+

emcioStatus.tool.pocketPrepped::

    Cuando IO recibe la señal HAL de que la preparación del cambiador de herramientas esta
    completa (después de un comando +Txxx+), esta variable se establece en el
    bolsillo de la herramienta solicitada. Cuando IO recibe la señal HAL de
    que el cambio de herramienta en sí está completo (después de un comando +M6+),
    esta variable se restablece a -1.

emcioStatus.tool.toolInSpindle::

    Número de la herramienta actualmente instalada en el husillo.
    Exportado en el pin HAL +iocontrol.0.tool-number+ (s32).

emcioStatus.tool.toolTable[]::

    Una matriz +CANON_TOOL_TABLE+ de estructuras, de longitud +CANON_POCKETS_MAX+.
    Cargada desde el archivo de la tabla de herramientas al inicio y mantenida allí.
    El índice 0 es el husillo, los índices 1-(CANON_POCKETS_MAX-1)
    son los bolsillos en el cambiador de herramientas. Esta es una copia completa
    de la información de la herramienta, mantenida por separado de Interp +settings.tool_table+.


==== interp

+settings+ es de tipo +settings+, que es +struct setup_struct+.
Definido en +src/emc/rs274ngc/interp_internal.hh+.

settings.selected_pocket::

    Bolsillo de la herramienta seleccionada más recientemente por +Txxx+.

settings.current_pocket::

    Bolsillo original de la herramienta actualmente en el husillo. En otras palabras:
    desde qué bolsillo del cambiador de herramientas fue cargada la herramienta que está actualmente en el husillo
     .

settings.tool_table[]::

    Una matriz de información de la herramienta. El índice en la matriz es el "bolsillo
    número "(también conocido como" número de ranura "). Bolsillo 0 es el husillo, bolsillos 1
    hasta (CANON_POCKETS_MAX-1) son los bolsillos del cambiador de herramientas.

settings.tool_offset_index::

    No usado. FIXME: Probablemente debería ser eliminado.

settings.toolchange_flag::

    Interp establece esto en verdadero cuando se llama a la funciónCHANGE_TOOL() de Canon.
    Se verifica en +Interp::convert_tool_length_offset()+
    para decidir qué bolsillo usar para G43 (sin palabra H):
    +settings->current_pocket+ si el cambio de herramienta aún está en progreso,
    bolsillo 0 (el husillo) si el cambio de herramienta está completo.

settings.random_toolchanger::

    Establecer desde la variable ini +[EMCIO]RANDOM_TOOLCHANGER+ al inicio.
    Controla la lógica de manejo de varias tablas de herramientas. (IO también lee esta
    variable ini y cambia su comportamiento en función de ella. Por ejemplo,
    al guardar la tabla de herramientas, el cambiador de herramientas al azar guarda la herramienta en
    el husillo (bolsillo 0), pero el cambiador de herramientas no aleatorio guarda cada herramienta
    en su "bolsillo de origen".)

settings.tool_offset::

    Esta es una variable +EmcPose+.

    * Se utiliza para calcular la posición en varios lugares.

    * Enviado a Motion a través del mensaje +EMCMOT_SET_OFFSET+.
        Todo movimiento que se hace con las compensaciones es exportado a los pines HAL.
        +motion.0.tooloffset.[xyzabcuvw]+. FIXME: exportar estos desde
        en algún lugar más cercano a la tabla de herramientas (io o interp, probablemente)
        y elimine el mensaje EMCMOT_SET_OFFSET.

settings.pockets_max::

    Se usa de manera intercambiable con +CANON_POCKETS_MAX+ (una constante #define,
    fijada a 56 a partir del 30 de diciembre de 2012). FIXME: Esta variable de configuración
    actualmente no es útil y probablemente debería eliminarse.

settings.tool_table::

    Esta es una matriz de estructuras +CANON_TOOL_TABLE+ (definida en
    +src/emc/nml_intf/emctool.h+), con +CANON_POCKETS_MAX+ entradas.
    Indexado por "número de bolsillo", también conocido como "número de ranura". El índice 0 es el
    husillo, los índices 1-(CANON_POCKETS_MAX-1) son los bolsillos en el cambiador de herramienta.
    Los números de bolsillo de un cambiador de herramientas al azar son significativos.
    En un cambiador de herramientas no aleatorio no tienen sentido; 
    los números de bolsillo en el archivo de tabla de herramientas se ignoran y las herramientas se asignan
    a ranuras +tool_table+ secuencialmente.

settings.tool_change_at_g30::
settings.tool_change_quill_up::
settings.tool_change_with_spindle_on::

    Estos se establecen a partir de variables ini en la sección +[EMCIO]+, y
    controlar cómo se realizan los cambios de herramienta.


== Contabilización de uniones y ejes.

=== En el búfer de estado

Task y las interfaces de usuario utilizan el búfer de estado.

FIXME: `axis_mask` y` axes` especifican en exceso el número de ejes

`status.motion.traj.axis_mask`::

    Una máscara de bits con un "1" para los ejes que están presentes y un "0"
    para los ejes que no están presentes. X es el bit 0, Y es el bit 1, etc.
    Por ejemplo, una máquina con ejes X y Z tendría una `axis_mask`
    de 0x5, una máquina XYZ tendría 0x7, y una máquina XYZB tendría
    tener una `axis_mask` de 0x17.

`status.motion.traj.axes` (en desuso)::

    El valor de esta variable es uno más que el índice del eje numerado más alto presente en la máquina.
    Como en `axis_mask`, el índice de X es 0, Y es 1, etc. Una máquina XZ tiene un valor de 'ejes'
    de 3, al igual que una máquina XYZ. Una máquina XYZW tiene un valor de 'ejes' 9.
    Esta variable no es muy útil, y su uso está en desuso.
    Utilice `axis_mask` en su lugar.

`status.motion.traj.joints`::

    Un recuento del número de articulaciones que tiene la máquina. Un torno normal
    tiene 2 articulaciones; uno que maneja el eje X y otro que maneja el eje Z.
    Una fresadora de pórtico XYYZ tiene 4 articulaciones; una X de conducción, una Y de un lado de conducción
    de la Y, otra al otro lado de la Y, y otra conduciendo Z.
    Una XYZA también tiene 4 articulaciones.

`status.motion.axis[EMCMOT_MAX_AXIS]`::

    Una matriz de estructuras de eje `EMCMOT_MAX_AXIS`. `axis [n]` es válido
    si `(axis_mask & (1 << n))` es True. Si `(axis_mask & (1 << n))`
    es False, entonces `axis [n]` no existe en esta máquina y debe
    ser ignorado.

`status.motion.joint [EMCMOT_MAX_JOINTS]` ::

    Una matriz de estructuras de articulaciones `EMCMOT_MAX_JOINTS`. `joint [0]` hasta
    `joint[joint-1]` son válidos, los otros no existen en esta máquina
    y deben ser ignorado.

Las cosas no están de esta manera actualmente en las ramas de ejes-articulaciones, pero
las desviaciones de este diseño se consideran errores. Para un ejemplo de
un error, vea el tratamiento de ejes en src/emc/ini/initraj.cc:loadTraj().
Sin duda hay más, y se necesita su ayuda para encontrarlos y arreglalos.


=== Motion

El componente en tiempo real del controlador Motion primero obtiene el número de articulaciones
del parámetro de tiempo de carga `num_joints`. Esto determina cuantos pines HAL para articulaciones
se crean al inicio.

El número de articulaciones de Motion se puede cambiar en tiempo de ejecución utilizando
El comando `EMCMOT_SET_NUM_JOINTS` de la Task.

El controlador de movimiento siempre funciona en los ejes `EMCMOT_MAX_AXIS`.
Siempre crea nueve conjuntos de pines `axis.*.*`
