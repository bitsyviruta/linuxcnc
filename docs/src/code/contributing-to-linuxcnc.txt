:lang: es

= Contribuciones a LinuxCNC

== Introducción

Este documento contiene información para desarrolladores sobre la infraestructura
de LinuxCNC, y describe las mejores prácticas para contribuir con código
y actualizaciones de documentación para el proyecto LinuxCNC.

A lo largo de este documento, "fuente" significa tanto el código fuente de
programas y bibliotecas como el texto fuente para la documentación.


== Comunicación entre desarrolladores de LinuxCNC

Las dos formas principales en que los desarrolladores de proyectos se comunican entre sí son:

* A través de IRC, en #linuxcnc-devel en FreeNode.

* A través del correo electrónico, en la lista de correo de los desarrolladores:
  https://lists.sourceforge.net/lists/listinfo/emc-developers


== El proyecto de LinuxCNC en Source Forge

Usamos Source Forge para listas de correo: http://sourceforge.net/p/emc/mailman/


== El sistema de control de revisiones git

Todas las fuentes de LinuxCNC se mantiene en el sistema de control de revisiones git.
footnote:[http://git-scm.com/].

=== Repositorio oficial LinuxCNC en git

El repositorio oficial git de LinuxCNC está en http://github.com/linuxcnc/linuxcnc/

Cualquiera puede obtener una copia de solo lectura del árbol fuente de LinuxCNC a través de git:

`git clone https://github.com/linuxcnc/linuxcnc linuxcnc-dev`

Si usted es un desarrollador con acceso de inserción (push), entonces siga las instrucciones de github
para configurar un repositorio desde el que pueda hacer envios.

Tenga en cuenta que el comando clone pone el repositorio LinuxCNC local en un
directorio llamado, en el ejemplo, `linuxcnc-dev`, en lugar del predeterminado `linuxcnc`.
Esto se debe a que el software LinuxCNC espera que sus configuraciones y
programas de código G estén en un directorio llamado `$HOME/linuxcnc`, y mezclarlo con el
repositorio git seria confuso.

Los problemas y las solicitudes pull son bienvenidas en github:
https://github.com/LinuxCNC/linuxcnc/issues
https://github.com/LinuxCNC/linuxcnc/pulls

=== Uso de git en el proyecto LinuxCNC

Utilizamos los flujos de trabajo de git "merging upwards" y "topic branches" descritos
aquí:

https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html

Tenemos una rama de desarrollo llamada `master`, y una o más ramas estables
con nombres como `2.6` o `2.7` que indican el número de versión
de los lanzamientos que hacemos.

Las correcciones de errores van en la rama estable aplicable más antigua, y esa rama se
fusiona en la siguiente rama estable más nueva, y así sucesivamente hasta `master`.
El autor de la corrección de errores puede hacer las fusiones por sí mismo, o pueden
dejar las fusiones a algun otro miembro.

Las nuevas características generalmente van en la rama `master`, pero algunos tipos de
características (específicamente controladores y documentación de dispositivos aislados)
puede (a discreción de los administradores de lanzamiento de la rama estable) entrar en
una rama estable y fusionarse como lo hacen las correcciones de errores.


=== Tutoriales git

Hay muchos tutoriales de git, gratuitos y excelentes, en Internet.

El primer lugar donde buscar es probablemente la página de manual "gittutorial".
Esta página de manual es accesible ejecutando "man gittutorial" en un terminal
(si tiene instaladas las páginas de manual de git). gittutorial y la
documentación subsiguiente también está disponible en línea aquí:

* tutorial de git:
  https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html

* tutorial git 2:
  https://www.kernel.org/pub/software/scm/git/docs/gittutorial-2.html

* Git de cada dia, con 20 comandos más o menos:
  https://www.kernel.org/pub/software/scm/git/docs/giteveryday.html

* Manual de usuario de Git:
  https://www.kernel.org/pub/software/scm/git/docs/user-manual.html

Para una documentación más completa de git ver el libro "Pro Git":
http://git-scm.com/book

Otro tutorial en línea que se ha recomendado es "Git for the Lazy":
http://wiki.spheredev.org/Git_for_the_lazy


== Descripción general del proceso

La descripción a alto nivel de cómo contribuir a los cambios en las fuente
es la siguiente:

* Comuníquese con los desarrolladores del proyecto y háganos saber lo que esta
  modificando.

* Clone el repositorio git

* Realice sus cambios en una rama local, asegurándose de "firmar" sus confirmaciones
  de acuerdo con nuestra política (ver a continuación).

* Agregar documentación y pruebas es una parte importante al agregar una nueva
  característica. De lo contrario, otros no sabrán cómo usarla, y
  si otros cambios estropean su característica, puede pasar desapercibida sin una prueba.

* Comparta sus cambios con los otros desarrolladores de proyectos de una de estas maneras:

** Envie su rama a github y cree una solicitud de extracción de github a
   https://github.com/linuxcnc/linuxcnc (esto requiere una cuenta github)

** Envíe su rama a un repositorio git públicamente visible (como github,
   bitbucket, su propio servidor de acceso público, etc.) y comparta esa
   ubicación en la lista de correo de emc-developers, o

** Envíe sus confirmaciones por correo electrónico a la lista de correo de emc-developers (use `git
   format-patch` para crear los parches)

* Defienda su parche

** Explique qué problema aborda y por qué debería incluirse
   en LinuxCNC

** Sea receptivo a las preguntas y comentarios de la comunidad de desarrolladores.

** No es raro que un parche pase por varias revisiones antes
   de ser aceptado


== Configuración de git

Para ser considerados para su inclusión en las fuentes de LinuxCNC, los commits
deben tener campos de Autor correctos que identifiquen al autor de los mismos.
Una buena manera de garantizar esto es establecer su configuración global de git:

`git config --global user.name "Su nombre completo"`

`git config --global user.email "usted@ejemplo.com"`

Use su nombre real (no un mote) y use una dirección de correo electrónico no confusa.


== Uso efectivo de git

=== Confirmacion de contenidos

Mantenga sus confirmaciones pequeñas y concisas. Cada confirmacion debe aportar
un cambio lógico al repositorio.

=== Escriba buenos mensajes de confirmacion

Mantenga los mensajes de confirmación con alrededor de 72 columnas de ancho (para que no se recorten
en un ventana de terminal de tamaño predeterminado cuando se muestran con `git log`).

Use la primera línea como resumen de la intención del cambio (casi
como el asunto de un correo electrónico). Sígualo con una línea en blanco, y
luego un mensaje más largo que explique el cambio. Ejemplo:

    Deshacerse de RTAPI_SUCCESS, usar 0 en su lugar

    La prueba "retval < 0" debería parecer familiar; es el mismo tipo de
    prueba que se usa en el espacio de usuario (devuelve -1 para error) y en el espacio de kernel
    (devuelve -ERRNO para error)

=== Confirmar (commit) a la rama adecuada

Las correcciones de errores deberían ir a la rama aplicable más antigua. Las nuevas características deberían
entra en la rama principal. Si no está seguro de donde pertenece un cambio,
pregunte en irc o en la lista de correo.

=== Usar múltiples commits para organizar cambios

Cuando sea apropiado, organice sus cambios en una rama (una serie de
commits) donde cada commit es un paso lógico hacia su objetivo ultimo.
Por ejemplo, primero, hacer de un código complejo una nueva
función. Luego, en un segundo commit, arreglar un posible error subyacente. Despues, en el
tercer commit, agregar una nueva característica que se facilita mediante la refactorización
y que no habría funcionado sin arreglar ese error.

Esto es útil para los revisores, porque es más fácil ver que el
paso "factorizar código en una nueva función" era correcto cuando no hay
otras ediciones mezcladas; es más fácil ver que el error está solucionado cuando
el cambio que lo corrige está separado de la nueva característica; y así sucesivamente.

=== Seguir el estilo del código circundante

Haga un esfuerzo para seguir el estilo de sangría predominante del código circundante.
En particular, los cambios en espacios en blanco hacen más difícil para otros
desarrolladores rastrear los cambios a lo largo del tiempo. Cuando se deba reformatear el código,
hagalo como un commit separado de cualquier cambio semántico.

=== Simplificar las historias complicadas antes de compartirla con otros desarrolladores

Con git es posible grabar cada edición y falso comienzo como un
commit separado. Esto es muy conveniente como una forma de crear puntos de control
durante el desarrollo, pero a menudo no se quiere compartir estos falsos
comienzos con otros

Git proporciona dos formas principales de limpiar el historial, y ambas se pueden hacer
libremente antes de compartir el cambio:

`git commit --amend` le permite hacer cambios adicionales a la última cosa
que ha confirmado, modificando opcionalmente también el mensaje de confirmacion. Utilize esto
si se da cuenta enseguida de que dejó algo fuera de la confirmacion,
o del mensaje de confirmación.

`git rebase --interactive upstream-branch` le permite revisar cada
confirmación desde que bifurcó su rama de características de la rama ascendente,
posiblilitando la edicion , eliminacion o combinacion de commits.
Rebase también se puede usar para dividir commits individuales
en múltiples commits nuevos.

=== Asegurese de que cada commit compila

Si su cambio consiste en varios parches, `git rebase -i` se puede usar para
reordenar estos parches en una secuencia de commits que establece más claramente
los pasos de su trabajo. Una consecuencia potencial de reordenamiento de parches
es que podría tener dependencias incorrectas, por ejemplo, introducir un
uso de una variable, y la declaración de esa variable en un parche posterior.

Mientras que la rama HEAD se construirá, no todos los commits podrían construir en tales
casos. Eso rompe `git bisect` - algo que alguien más podría usar
más tarde para encontrar el commit que introdujo un error. Así que más allá de
asegúrese de que su ramificación se construye, es importante asegurar que cada commit
construye también.

Hay una manera automática de verificar una rama para que cada commit sea construible
- ver http://dustin.sallings.org/2010/03/28/git-test-sequence.html
y el código en https://github.com/dustin/bindir/blob/master/git-test-sequence.
Úselo de la siguiente manera (en este caso, probando cada confirmación desde el origin/master hasta
HEAD, incluyendo la ejecución de pruebas de regresión):

----
cd linuxcnc-dev
git-test-sequence origin/master.. '(cd src && make && ../scripts/runtests)'
----

Esto se informará como 'All's well' o 'Broke on <commit>'.

=== Cambiar el nombre de los archivos

Utilice la capacidad de cambiar el nombre de los archivos con mucha cautela. Al igual que
variar la sangría en archivos individuales, cambiar el nombre hace que sea más difícil seguir
los cambios con el tiempo. Como mínimo, debe buscar un consenso en irc o
la lista de correo de que el cambio de nombre es una mejora.

=== Preferir "rebase"

Use `git pull --rebase` en lugar de` git pull` desnudo para mantener una
buena historia lineal. Al usar rebase, siempre conserva su trabajo como
revisiones que están por delante del origin/master, por lo que puede hacer cosas como
`git format-patch` para compartir con los demás sin envios al
repositorio central.


== Otras formas de contribuir

Hay muchas formas de contribuir a LinuxCNC, que no se abordan
en este documento. Estas formas incluyen:

* Responder preguntas en el foro, listas de correo y en IRC

* Informar de errores en el rastreador de errores, foro, listas de correo o en IRC

* Ayudar a probar las características experimentales
