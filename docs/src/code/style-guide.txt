:lang: es

= Estilo de codificación

Este capítulo describe el estilo del código fuente preferido por el equipo de LinuxCNC.

== No provocar daños

Cuando realice pequeñas ediciones para codificar en un estilo diferente al que está
descrito a continuación, observe el estilo de codificación local. Cambios rápidos de un
estilo de codificación a otro disminuye la legibilidad del código.

Nunca verifique el código después de ejecutar "indent" en él. Los cambios de espacio en blanco
introducidos por indent hacen que sea más difícil seguir el
historial de revisión del archivo.

No use un editor que realice cambios innecesarios en los espacio en blanco (p. Ej.,
reemplazar 8 espacios con un tabulador en una línea no modificada de otro modo
o lineas partidas automaticamente, sin otra modificacion)

== Tabulación

Una tabulación siempre corresponde a 8 espacios. No escriba código que
se visualizaria correctamente con una configuración de tabulación diferente.

== Sangría

Use 4 espacios por nivel de sangría. Combinar 8 espacios en una tabulacion
es aceptable pero no obligatorio.

== Colocando llaves

Coloque la llave de apertura en el último lugar en la línea y coloque la de cierre en el primero:

[source,c]
----
if (x) {
    // hacer algo apropiado
}
----

La llave de cierre está en una línea propia, excepto en los casos donde
sea seguida por una continuación de la misma declaración, es decir, un 'while'
en un 'do' o un 'else' en un 'if', como esto:

[source,c]
----
do {
    // algo importante
} while (x > 0);
----

y

[source,c]
----
if (x == y) {
    // Hacer una cosa
} else if (x < y) {
    // hacer otra cosa
} else {
    // hacer una tercera cosa
}
----

Esta colocación de llaves también minimiza el número de vacíos (o 
líneas casi vacías), lo que permite una mayor cantidad de código o comentarios
visible a la vez en un terminal de tamaño fijo.

== Nombrado

C es un lenguaje espartano, y también debe serlo su nombrado. A diferencia de los programadores
de Modula-2 y de Pascal, los programadores de C no usan nombres adornados como
ThisVariableIsATemporaryCounter. Un programador de C llamaría a esa
variable 'tmp', que es mucho más fácil de escribir, y no menos
difícil de comprender.

Sin embargo, los nombres descriptivos de las variables globales son imprescindibles. Llamar a una
función global 'foo' es casi ofensivo.

Las variables GLOBALES (que se utilizarán solo si *realmente* las necesita) necesitan
tener nombres descriptivos, al igual que las funciones globales. Si
usted tiene una función que cuenta la cantidad de usuarios activos, debe
llamarla 'count_active_users()' o algo similar, y *no* debe llamarla
'cntusr()'.

Codificar el tipo de función en el nombre (la llamada notacion húngara) es dañino.
El compilador conoce los tipos de todos modos y puede verificarlos, pero confunde al programador. No es de extrañar que
Microsoft haga programas con errores.

Los nombres de variables LOCALES deben ser cortos, y apropiados. Si usted tiene
un contador entero aleatorio de bucle, probablemente debería llamarse 'i'.
Llamarlo 'loop_counter' no es productivo, si no cabe posibilidad de que no
sea entendido. Del mismo modo, 'tmp' puede ser casi cualquier tipo de
variable que se usa para mantener un valor temporal.

Si tiene miedo de confundir sus nombres de variables locales, tiene
otro problema, que se llama síndrome desequilibrio-función-hormona-crecimiento.
Ver el siguiente capítulo.

== Funciones

Las funciones deben ser cortas y agradables, y hacer solo una cosa.
Debe caber en una o dos pantallas de texto (el tamaño de pantalla ISO/ANSI
es 80x24, como todos sabemos), y hacer una cosa y hacerla bien.

La longitud máxima de una función es inversamente proporcional al
nivel de complejidad e indentación de esa función. Por tanto, si tiene una
función conceptualmente simple que es solo un largo (pero simple)
'case-statement', donde tiene que hacer muchas cosas pequeñas para una gran cantidad de
diferentes casos, está bien tener una función más larga.

Sin embargo, si tiene una función compleja, y sospecha que
un estudiante de primer año de secundaria poco listo no podrá
entender de qué trata la función, debera ir al límite máximo. Use funciones de ayuda con
nombres descriptivos (puede solicitar al compilador que los incluya en línea si
cree que es crítico para el rendimiento, y probablemente hará un mejor trabajo
que el hecho por usted).

Otra medida de la función es el número de variables locales.
No debe exceder 5-10, o está haciendo algo mal. Repiense la
función, y divídala en pedazos más pequeños. Un cerebro humano en general puede
realizar fácilmente un seguimiento de alrededor de 7 cosas diferentes, cualquier cosa más lo
puede confundir. Usted sabe que es brillante, pero tal vez le gustaría
entender lo que hizo dentro de 2 semanas.

== Comentando

Los comentarios son buenos, pero también existe el peligro de hacer excesivo comentario.
NUNCA intente explicar CÓMO funciona su código en un comentario: es mucho mejor
escribir el código para que el *trabajo* sea obvio. Es un desperdicio de
tiempo explicar código mal escrito.

En general, sus comentarios deben indicar QUÉ hace su código, no
CÓMO. Una caja de comentario que describe la función, el valor de retorno y quién
lo llama, colocada sobre el cuerpo, es buena cosa. Además, trate de evitar poner
comentarios dentro de un cuerpo de función: si la función es tan compleja que
necesita comentar por separado partes de él, probablemente debería volver a leer la
sección de funciones nuevamente. Puede hacer pequeños comentarios para advertir
sobre algo particularmente inteligente (o feo), pero trate de evitar los excesos.
En cambio, coloque los comentarios en la parte superior de la función, diciéndole a la gente
lo que hace y, posiblemente, POR QUÉ lo hace.

Si se utilizan comentarios como los /* Fix me */, por favor, por favor,
decir por qué algo necesita ser arreglado. Cuando se ha realizado un cambio en la
parte del código afectada, elimine el comentario o reformelo
para indicar que se ha realizado un cambio y necesita pruebas.

== Scripts de shell y Makefiles

No todo el mundo tienen las mismas herramientas y paquetes instalados. Algunas personas
usan vi, otros emacs. Algunos incluso evitan tener cualquier paquete
instalado, prefiriendo un editor de texto liviano como nano o uno
incorporado a Midnight Commander.

gawk versus mawk - Una vez más, no todos tendrán gawk instalado, mawk
es casi una décima parte del tamaño y, sin embargo, se ajusta al Posix AWK
estándar. Si se necesita un comando específico gawk oscuro que mawk
no proporciona, la secuencia de comandos no funcionara para algunos usuarios. Lo mismo
se aplicaría a mawk. En resumen, use la invocación awk genérica con preferencia a gawk o mawk.

== Convenciones C++

Los estilos de codificación C++ siempre terminan en acalorados debates (un poco
como los argumentos emacs versus vi). Una cosa es cierta sin embargo; un
estilo común utilizado por todos los que trabajan en un proyecto conduce a codigo uniforme y
legible

Convenciones de nombres: Las constantes resultantes de #define o enumeraciones
debe estar en mayúsculas. Justificación: hace que sea más fácil detectar
constantes en tiempo de compilacion en el código fuente. p.ej. EMC_MESSAGE_TYPE

Las clases y Namespaces deben tener en mayúscula la primera letra de cada palabra
y evitar subrayados. Justificación: identificacion de clases, constructores y
destructores. p.ej. GtkWidget

Los métodos (o nombres de funciones) deben seguir las recomendaciones C anteriores
y no debe incluir el nombre de la clase. Justificación: Mantener un estilo común
en fuentes C y C ++. p.ej. get_foo_bar()

Sin embargo, los métodos booleanos son más fáciles de leer si se evitan los guiones bajos
y se usa un prefijo 'is' (que no debe confundirse con métodos que manipulan
un booleano). Justificación: identificar el valor de retorno como VERDADERO o FALSO y
nada más. p.ej. isOpen, isHomed

NO use 'Not' en un nombre booleano, solo conduce a confusión
al hacer pruebas lógicas. p.ej. isNotOnLimit o is_not_on_limit son MALOS nombres.

Los nombres de variables deben evitar el uso de mayúsculas y guiones bajos
a excepción de los nombres locales o privados. El uso de variables globales debería
evitarse tanto como sea posible. Justificación: aclara qué son
variables y qué son métodos. Public: p.ej. axislimit Private: p.ej. maxvelocity_

Convenciones de nombres de métodos específicos

Los términos get y set deben usarse cuando se accede a un atributo
directamente. Justificación: indica el propósito de la función o método.
p.ej. get_foo set_bar

Para los métodos que implican atributos booleanos, se prefiere set y reset.
Justificación: como arriba. p.ej. set_amp_enable reset_amp_fault

Los métodos con matemáticas intensivas deben usar 'compute' como un prefijo. Razón fundamental:
Muestra que es intensivo desde el punto de vista computacional y acapara la CPU. p.ej.
compute_PID

Deben evitarse las abreviaturas en los nombres cuando sea posible.
La excepción es para nombres de variables locales. Justificación: Claridad del código. p.ej.
se prefiere 'pointer' a 'ptr', 'compute' es preferible a 'cmp', 'compare' es
preferido a 'cmp'.

Las enumeraciones y otras constantes pueden estar precedidos por un nombre de tipo común
p.ej. enum COLOR {COLOR_RED, COLOR_BLUE};

Se debe evitar el uso excesivo de macros y definiciones.
Son preferibles métodos o funciones. Justificación: Mejora el proceso de depuración.

Los archivos de encabezado se deben incluir en la parte superior de los
archivo fuente y no dispersos por todo el cuerpo. Deberían ser
ordenados y agrupados por su posición jerárquica dentro del sistema
incluyendo los archivos de bajo nivel primero. Las rutas de archivos en 'include'
NUNCA deben ser absolutas: utilice el indicador del compilador -I en su lugar. Razón fundamental:
Los encabezados pueden no estar en el mismo lugar en todos los sistemas.

Los punteros y las referencias deben tener su símbolo de referencia al lado del
nombre de variable en lugar del nombre de tipo. Justificación: reduce la confusión.
p.ej. float *x o int &i

Las pruebas implícitas para cero no se deben usar a excepción de variables booleanas. 
p.ej. if (spindle_speed != 0) NO if (spindle_speed)

Solo las instrucciones de control de bucle se deben incluir en una construcción for().
p.ej. sum = 0; for (i = 0; i < 10; i++) { sum += value[i]; }
y NO for (i = 0, sum =0; i < 10; i++) sum += value[i];

Del mismo modo, deben evitarse las declaraciones ejecutables en condicionales. p.ej.
if (fd = open(file_name) es malo.

Deben evitarse declaraciones condicionales complejas: introducir
variables booleanas en su lugar.

Los paréntesis deben usarse en abundancia en expresiones matemáticas:
no confiar en la precedencia del operador cuando un paréntesis adicional aclararía las
cosas.

Nombres de archivos: las fuentes y los encabezados C++ usan la extensión .cc y .hh. El uso
de .c y .h están reservados para C. Los encabezados son para declaraciones de clases, métodos,
y estructuras, no para código (a menos que las funciones estén declaradas en línea).

== Estándares de codificación Python

Use el estilo http://www.python.org/dev/peps/pep-0008/[PEP 8] para
código Python

== Estándares de codificación Comp

En la parte de declaración de un archivo .comp, comience cada declaración en
la primera columna. Inserte líneas en blanco adicionales cuando ayuden a agrupar elementos relacionados.

En la parte del código de un archivo .comp, siga el estilo de codificación C normal.

