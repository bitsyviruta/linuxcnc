= Notas de código

== Público previsto

Este documento es una colección de notas sobre los aspectos internos de LinuxCNC. Eso
es principalmente de interés para los desarrolladores, sin embargo, gran parte de la información
aquí también puede ser de interés para integradores de sistemas y otros que están
simplemente curioso sobre cómo funciona LinuxCNC. Mucha de esta información es ahora
desactualizado y nunca ha sido revisado por su precisión.

== Organización

Habrá un capítulo para cada uno de los componentes principales de LinuxCNC, como
así como capítulos que cubren cómo trabajan juntos. Este documento es
es un trabajo en progreso y su diseño puede cambiar en el futuro.

== Términos y definiciones

* 'EJE': un eje es uno de los nueve grados de libertad que define una herramienta
    posición en el espacio cartesiano tridimensional. Esos nueve ejes son
    referido como X, Y, Z, A, B, C, U, V y W. El lineal orthagonal
    Las coordenadas X, Y y Z determinan dónde está la punta de la herramienta
    posicionado Las coordenadas angulares A, B y C determinan la herramienta
    orientación. Un segundo conjunto de coordenadas lineales ortogonales U, V y W
    permite el movimiento de la herramienta (generalmente para acciones de corte) en relación con el
    Ejes previamente desplazados y rotados.
    Lamentablemente, "eje" es también
    a veces solía significar un grado de libertad de la máquina en sí, como
    como la silla de montar, la mesa o la pluma de una fresadora tipo Bridgeport. En
    un Bridgeport esto no causa confusión, ya que el movimiento de la mesa
    corresponde directamente al movimiento a lo largo del eje X. sin embargo, el
    articulaciones de hombro y codo de un brazo robótico y los actuadores lineales de un
    el hexápodo no corresponde al movimiento a lo largo de ningún eje cartesiano, y en
    en general es importante hacer la distinción entre el cartesiano
    ejes y grados de libertad de la máquina. En este documento, este último
    se llamarán 'articulaciones', no ejes. (Las GUI y algunas otras partes de
    el código no siempre sigue esta distinción, pero las partes internas de
    el controlador de movimiento hacer.)

* 'JUNTA': una junta es una de las partes móviles de la máquina. Las articulaciones son
    distinto de los ejes, aunque los dos términos a veces se usan (incorrectamente) para
    significa lo mismo. En LinuxCNC, una articulación es una cosa física que puede ser
    movido, no una coordenada en el espacio. Por ejemplo, la pluma, la rodilla, la silla de montar,
    y la mesa de un molino de Bridgeport son todas juntas. El hombro, el codo y
    La muñeca de un brazo robótico son articulaciones, al igual que los actuadores lineales de un
    hexápodo Cada articulación tiene un motor o actuador de algún tipo asociado
    con eso. Las articulaciones no corresponden necesariamente a los ejes X, Y y Z,
    aunque para máquinas con cinemática trivial que puede ser el caso.
    Incluso en esas máquinas, la posición conjunta y la posición del eje son
    cosas fundamentalmente diferentes. En este documento, los términos 'articulación' y
    'eje' se utilizan con cuidado para respetar sus significados distintos.
    Desafortunadamente, eso no es necesariamente cierto en ningún otro lado. En
    en particular, las GUI para máquinas con cinemática trivial pueden pasar por alto o
    oculta completamente la distinción entre articulaciones y ejes. Adicionalmente,
    el archivo ini usa el término 'eje' para datos que serían más precisos
    describirse como datos conjuntos, como el escalado de entrada y salida, etc.

* 'POSE': una pose es una posición completamente especificada en un espacio cartesiano en 3-D. En
    el controlador de movimiento LinuxCNC, cuando nos referimos a una pose nos referimos a un
    Estructura EmcPose, que contiene seis coordenadas lineales (X, Y, Z, U,
    V y W) y tres angulares (A, B y C).

== Descripción general de la arquitectura

Hay cuatro componentes contenidos en la Arquitectura LinuxCNC: un movimiento
controlador (EMCMOT), un controlador de E / S discreto (EMCIO), un ejecutor de tareas
que los coordina (EMCTASK) y varios modos de texto y gráficos
Interfaces de usuario. Cada uno de ellos se describirá en el presente
documento, tanto desde el punto de vista del diseño como de los desarrolladores
punto de vista (dónde encontrar los datos necesarios, cómo ampliar / modificar fácilmente
cosas, etc.).

imagen :: LinuxCNC-block-diagram-small.png [align = "center"]

Arquitectura de software LinuxCNC. En el nivel más general, LinuxCNC es un
jerarquía de tres controladores: el controlador de comando a nivel de tarea y el programa
intérprete, el controlador de movimiento y el controlador de E / S discreto. los
El controlador de E / S discreto se implementa como una jerarquía de controladores,
en este caso para husillo, refrigerante y auxiliar (p. ej., tope, lubricante)
subsistemas El controlador de tareas coordina las acciones del movimiento y
Controladores de E / S discretos. Sus acciones están programadas en convencional
programas de control numérico "código G y M", que son interpretados por
el controlador de tareas en mensajes NML y enviado a la moción o
Controladores de E / S discretos en los momentos apropiados.

== Introducción al controlador de movimiento

El controlador de movimiento recibe comandos de los módulos de espacio del usuario a través de un
memoria compartida y ejecuta esos comandos en tiempo real. los
el estado del controlador está disponible para los módulos de espacio de usuario
a través de la misma área de memoria compartida. El controlador de movimiento interactúa.
con los motores y otro hardware utilizando el HAL (abstracción de hardware
Capa). Este documento asume que el lector tiene una comprensión básica
del HAL, y utiliza términos como pines HAL, señales HAL, etc., sin
explicándolos. Para obtener más información sobre el HAL, consulte el
Manual HAL. Otro capítulo de este documento será
eventualmente entrará en lo interno del HAL mismo, pero en esto
capítulo, solo usamos la API HAL como se define en src / hal / hal.h.

imagen :: LinuxCNC-motion-controller-small.png [align = "center"]

== Diagramas de bloque y flujo de datos

La siguiente figura es un diagrama de bloques.
de un controlador conjunto. Hay un controlador conjunto por junta. los
Los controladores conjuntos funcionan a un nivel más bajo que la cinemática, un nivel
donde todas las articulaciones son completamente independientes. Todos los datos para una articulación
está en una sola estructura conjunta. Algunos miembros de esa estructura son
visible en el diagrama de bloques, como coarse_pos, pos_cmd y
motor_pos_fb.

imagen :: emc2-motion-joint-controller-block-diag.png [align = "center"]

.Diagrama de bloque del controlador articular

La figura anterior muestra cinco de los
siete conjuntos de información de posición que forman el flujo principal de datos a través de
El controlador de movimiento. Las siete formas de datos de posición son las siguientes:

. 'emcmotStatus \ -> carte_pos_cmd' - Esta es la posición deseada, en
   Coordenadas cartesianas. Se actualiza a la velocidad del traj, no al servo
   Velocidad. En modo coord, lo determina el planificador de traj. En teleop
   modo, está determinado por el planificador de traj? En modo libre, es
   copiado de actualPos, o generado mediante la aplicación de parentesco hacia adelante a (2) o
   (3)
. 'emcmotStatus \ -> junturas [n] .coarse_pos' - Esta es la posición deseada, en
   coordenadas conjuntas, pero antes de la interpolación. Se actualiza en el traj
   tasa, no la tasa de servo. En modo coord, se genera aplicando
   kines inversos a (1) En modo teleop, se genera aplicando inversa
   kines a (1) En modo libre, creo que se copia de (3).
. 'emcmotStatus \ -> junturas [n] .pos_cmd - Esta es la posición deseada, en
   cordones articulares, después de la interpolación. Un nuevo conjunto de estos acordes es
   generado cada período servo. En modo coord, se genera a partir de (2)
   por el interpolador. En modo teleop, se genera a partir de (2) por el
   interpolador. En modo libre, es generado por el modo libre traj
   planificador.
. 'emcmotStatus \ -> junturas [n] .motor_pos_cmd' - Esta es la posición deseada,
   en cables de motor. Las coordenadas del motor se generan agregando reacción
   compensación, compensación de error del tornillo de avance y compensación (para referencia) a
   (3) Se genera de la misma manera, independientemente del modo, y es el
   salida al bucle PID u otro bucle de posición.
. 'emcmotStatus \ -> junturas [n] .motor_pos_fb' - Esta es la posición real, en
   cables motores. Es la entrada de codificadores u otro dispositivo de retroalimentación
   (o desde codificadores virtuales en máquinas de bucle abierto). Es "generado" por
   leyendo el dispositivo de retroalimentación.
. 'emcmotStatus \ -> articulaciones [n] .pos_fb': esta es la posición real, en la articulación
   coordenadas Se genera restando el desplazamiento, error del tornillo de avance
   compensación y compensación de reacción de (5). Se genera el
   del mismo modo, independientemente del modo de funcionamiento.
. 'emcmotStatus \ -> carte_pos_fb' - Esta es la posición real, en cartesiano
   coordenadas Se actualiza a la velocidad del traj, no a la velocidad del servo.
   Idealmente, el actualPos siempre se calcularía aplicando hacia adelante
   cinemática a (6). Sin embargo, la cinemática directa puede no estar disponible, o
   pueden ser inutilizables porque uno o más ejes no están dirigidos. En eso
   caso, las opciones son: A) fingir copiando (1), o B) admitir que
   realmente no conozco las coordenadas cartesianas, y simplemente no actualizo
   actualPos. Cualquiera que sea el enfoque utilizado, no veo ninguna razón para no hacerlo.
   de la misma manera, independientemente del modo de operación. Yo propondría el
   siguiente: si hay parentescos hacia adelante, úselos, a menos que no funcionen
   debido a ejes no alojados u otros problemas, en cuyo caso hacer (B). Si no
   kines hacia adelante, do (A), ya que de lo contrario actualPos _never_ obtendrá
   actualizado.

== Homing

=== Diagrama de estado de referencia

imagen :: homing.svg [align = "center"]

=== Otro diagrama de referencia

imagen :: hss.svg [align = "center"]

== Comandos

Esta sección simplemente enumera todos los comandos que se pueden enviar a
módulo de movimiento, junto con explicaciones detalladas de lo que hacen. los
los nombres de los comandos se definen en una gran enumeración de typedef en
{linuxcnc} /src/emc/motion/motion.h, llamado cmd_code_t. (Tenga en cuenta que en el
código, cada nombre de comando comienza con 'EMCMOT_', que se omite aquí).

Los comandos se implementan mediante una instrucción de cambio grande en el
función emcmotCommandHandler (), que se llama a la velocidad del servo.
Más sobre esa función más adelante.

Hay aproximadamente 44 comandos: esta lista todavía está bajo
construcción.

=== ABORTAR

El comando ABORTAR simplemente detiene todo movimiento. Se puede emitir en cualquier
tiempo, y siempre será aceptado. No deshabilita el movimiento.
controlador o cambiar cualquier información de estado, simplemente cancela cualquier
moción que está actualmente en progreso. nota al pie: [Parece que el
El código de nivel superior (TAREA y superior) también usa ABORTO para borrar fallas.
Siempre que haya una falla persistente (como estar fuera del
interruptores de límite de hardware), el código de nivel superior envía una constante
flujo de ABORT al controlador de movimiento que intenta hacer
culpa irse. Miles de ellos ... Eso significa que la moción
El controlador debe evitar fallas persistentes. Esto necesita ser observado
dentro.]

==== Requisitos

Ninguna. El comando siempre se acepta y se actúa inmediatamente.

==== Resultados

En modo libre, los planificadores de trayectoria de modo libre están deshabilitados. Ese
da como resultado que cada junta se detenga tan rápido como su límite de aceleración (desaceleración)
permite. La parada no está coordinada. En modo teleop, el comando
La velocidad cartesiana se establece en cero. No sé exactamente qué tipo de
detener los resultados (coordinados, descoordinados, etc.), pero lo resolverá
finalmente. En modo coord, se le dice al planificador de trayectoria del modo coord
abortar el movimiento actual. De nuevo, no sé el resultado exacto de esto,
pero lo documentaré cuando lo resuelva.

=== GRATIS

El comando FREE pone el controlador de movimiento en modo libre. Modo libre
significa que cada articulación es independiente de todas las demás articulaciones. cartesiano
Las coordenadas, poses y cinemática se ignoran cuando está en modo libre. En
esencia, cada articulación tiene su propio planificador de trayectoria simple, y cada
articulación ignora por completo las otras articulaciones. Algunos comandos (como Joint
JOG y HOME) solo funcionan en modo libre. Otros comandos, incluso cualquier cosa
que trata con coordenadas cartesianas, no funciona en absoluto en modo libre.

==== Requisitos

El controlador de comandos no aplica requisitos al comando FREE,
Siempre será aceptado. Sin embargo, si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG () == FALSE), entonces el comando será ignorado.
Este comportamiento está controlado por un código que ahora se encuentra en la función
'set_operating_mode ()' en control.c, ese código debe limpiarse.
Creo que el comando no debe ignorarse en silencio, sino que
El controlador de comandos debe determinar si se puede ejecutar y devolver
un error si no puede

==== Resultados

Si la máquina ya está en modo libre, nada. De lo contrario, el
La máquina se coloca en modo libre. La trayectoria del modo libre de cada articulación
el planificador se inicializa en la ubicación actual de la articulación, pero el
los planificadores no están habilitados y las articulaciones son estacionarias.

=== TELEOP

El comando TELEOP coloca la máquina en modo de teleoperación. En teleop
modo, el movimiento de la máquina se basa en coordenadas cartesianas utilizando
cinemática, en lugar de en articulaciones individuales como en modo libre. sin embargo
el planificador de trayectoria per se no se usa, en cambio el movimiento es
controlado por un vector de velocidad. El movimiento en modo teleop es muy parecido a
trotar, excepto que se hace en espacio cartesiano en lugar de articulación
espacio. En una máquina con cinemática trivial, hay poca diferencia
entre el modo teleop y el modo libre, y las GUI para esas máquinas podrían
Ni siquiera emita este comando. Sin embargo, para máquinas no triviales como
robots y hexapodos, el modo teleop se utiliza para la mayoría de los jog ordenados por el usuario
movimientos de tipo

==== Requisitos

El controlador de comandos rechazará el comando TELEOP con un error
mensaje si la cinemática no se puede activar porque uno o más
las articulaciones no han sido dirigidas. Además, si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG () == FALSE), entonces el comando será ignorado
(sin mensaje de error). Este comportamiento está controlado por un código que es
ahora ubicado en la función 'set_operating_mode ()' en control.c. yo
cree que el comando no debe ser ignorado en silencio, sino el comando
El controlador debe determinar si se puede ejecutar y devolver un error
si no puede

==== Resultados

Si la máquina ya está en modo teleop, nada. De lo contrario el
la máquina se coloca en modo teleop. El código cinemático está activado,
los interpoladores son drenados y enjuagados, y la velocidad cartesiana
los comandos se ponen a cero.

=== COORD

El comando COORD coloca la máquina en modo coordinado. En coord
modo, el movimiento de la máquina se basa en coordenadas cartesianas utilizando
cinemática, en lugar de en articulaciones individuales como en modo libre. En
Además, el planificador de trayectoria principal se utiliza para generar movimiento, basado
en los comandos LINE, CIRCLE y / o PROBE en cola. El modo coord es el modo
que se usa al ejecutar un programa de código G.

==== Requisitos

El controlador de comandos rechazará el comando COORD con un error
mensaje si la cinemática no se puede activar porque uno o más
las articulaciones no han sido dirigidas. Además, si alguna articulación está en movimiento
(GET_MOTION_INPOS_FLAG () == FALSE), entonces el comando será ignorado
(sin mensaje de error). Este comportamiento está controlado por un código que es
ahora ubicado en la función 'set_operating_mode ()' en control.c. yo
cree que el comando no debe ser ignorado en silencio, sino el comando
El controlador debe determinar si se puede ejecutar y devolver un error
si no puede

==== Resultados

Si la máquina ya está en modo coord, nada. De lo contrario, el
La máquina se coloca en modo coord. El código cinemático está activado,
los interpoladores son drenados y enjuagados, y el planificador de trayectoria
las colas están vacías El planificador de trayectoria está activo y en espera de una LÍNEA,
CÍRCULO o comando SONDA.

=== ACTIVAR

El comando ENABLE habilita el controlador de movimiento.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Si el controlador ya está habilitado, nada. Si no, el controlador
está habilitado. Las colas y los interpoladores se sonrojan. Cualquier movimiento o
las operaciones de referencia se terminan. Las salidas de habilitación de amplificador asociadas
con articulaciones activas se encienden. Si la cinemática hacia adelante no es
disponible, la máquina se cambia al modo libre.

=== DESACTIVAR

El comando DISABLE deshabilita el controlador de movimiento.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Si el controlador ya está deshabilitado, nada. Si no, el controlador
está desactivado. Las colas y los interpoladores se sonrojan. Cualquier movimiento o
las operaciones de referencia se terminan. Las salidas de habilitación de amplificador asociadas
con las articulaciones activas están apagadas. Si la cinemática hacia adelante no es
disponible, la máquina se cambia al modo libre.

=== ENABLE_AMPLIFIER

El comando ENABLE_AMPLIFIER activa la salida de habilitación del amplificador para un
Amplificador de salida única, sin cambiar nada más. Puede ser usado para
habilitar un controlador de velocidad del husillo.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Actualmente nada. (Una llamada a la antigua función extAmpEnable es
actualmente comentado). Eventualmente configurará el pin de habilitación del amplificador HAL
cierto.

=== DISABLE_AMPLIFIER

El comando DISABLE_AMPLIFIER apaga la salida de habilitación del amplificador para un
Amplificador único, sin cambiar nada más. De nuevo, útil para
Controladores de velocidad del husillo.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Actualmente nada. (Una llamada a la antigua función extAmpEnable es
actualmente comentado). Eventualmente configurará el pin de habilitación del amplificador HAL
falso.

=== ACTIVATE_JOINT

El comando ACTIVATE_JOINT activa todos los cálculos asociados.
con una sola articulación, pero no cambia la salida de habilitación del amplificador de la articulación
alfiler.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Los cálculos para la articulación especificada están habilitados. El pin de habilitación del amplificador
no se cambia, sin embargo, cualquier comando ENABLE o DISABLE posterior
modificar el pin de habilitación del amplificador de la articulación.

=== DESACTIVAR_JUNTA

El comando DEACTIVATE_JOINT desactiva todos los cálculos asociados.
con una sola articulación, pero no cambia la salida de habilitación del amplificador de la articulación
alfiler.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Los cálculos para la articulación especificada están habilitados. El pin de habilitación del amplificador
no se cambia, y los siguientes comandos ENABLE o DISABLE no
modifique el pin de habilitación del amplificador de la articulación.

=== ENABLE_WATCHDOG

El comando ENABLE_WATCHDOG habilita un perro guardián basado en hardware (si
presente).

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Actualmente nada. El viejo perro guardián era una cosa extraña que usaba un
Tarjeta de sonido específica. Se puede diseñar una nueva interfaz de vigilancia en el
futuro.

=== DISABLE_WATCHDOG

El comando DISABLE_WATCHDOG deshabilita un perro guardián basado en hardware (si
presente).

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Actualmente nada. El viejo perro guardián era una cosa extraña que usaba un
Tarjeta de sonido específica. Se puede diseñar una nueva interfaz de vigilancia en el
futuro.

=== PAUSA

El comando PAUSE detiene el planificador de trayectoria. No tiene efecto en
modo libre o teleop. En este punto no sé si detiene todo el movimiento
inmediatamente, o si completa el movimiento actual y luego se detiene antes
tirando de otro movimiento de la cola.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

El planificador de trayectoria hace una pausa.

=== REANUDAR

El comando RESUME reinicia el planificador de trayectoria si está en pausa. Eso
no tiene efecto en modo libre o teleop, o si el planificador no está en pausa.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Se reanuda el planificador de trayectoria.

=== PASO

El comando STEP reinicia el planificador de trayectoria si está en pausa, y
le dice al planificador que se detenga nuevamente cuando llegue a un punto específico. Eso
no tiene efecto en modo libre o teleop. En este punto no se
exactamente cómo funciona esto. Agregaré más documentación aquí cuando excave
más profundo en el planificador de trayectoria.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

El planificador de trayectoria se reanuda y luego se detiene cuando llega a un
punto específico.

=== ESCALA

El comando SCALE escala todos los límites de velocidad y comandos por un
cantidad especificada Se utiliza para implementar la anulación de la velocidad de alimentación y otros
funciones similares El escalado funciona en modo libre, teleop y coord,
y afecta todo, incluidas las velocidades de referencia, etc. Sin embargo,
los límites individuales de velocidad conjunta no se ven afectados.

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado.

==== Resultados

Todos los comandos de velocidad son escalados por la constante especificada.

=== OVERRIDE_LIMITS

El comando OVERRIDE_LIMITS evita que los límites se disparen hasta que
Fin del siguiente comando JOG. Normalmente se usa para permitir que una máquina
salir de un interruptor de límite después de disparar. (El comando puede
en realidad se puede usar para anular límites o para cancelar una anulación anterior).

==== Requisitos

Ninguna. El comando puede emitirse en cualquier momento y siempre será
aceptado. (Creo que solo debería funcionar en modo libre).

==== Resultados

Los límites en todas las articulaciones se anulan hasta el final del próximo JOG
mando. (Esto está roto actualmente ... una vez que un comando OVERRIDE_LIMITS
se recibe, los límites se ignoran hasta que otro comando OVERRIDE_LIMITS
los vuelve a habilitar).

=== INICIO

El comando HOME inicia una secuencia de referencia en una articulación especificada. los
La secuencia de referencia real está determinada por una serie de configuraciones
parámetros, y puede variar desde simplemente establecer la posición actual hasta
cero, a una búsqueda en varias etapas para un interruptor de inicio y pulso de índice,
seguido de un traslado a una ubicación de inicio arbitraria. Para más información
sobre la secuencia de referencia, consulte la sección de referencia del Manual del integrador.

==== Requisitos

El comando se ignorará en silencio a menos que la máquina esté en modo libre.

==== Resultados

Se anula cualquier movimiento u otro movimiento conjunto, y la secuencia de referencia
empieza.

=== JOG_CONT

El comando JOG_CONT inicia un avance continuo en una sola articulación. UNA
el avance continuo se genera al establecer la trayectoria del modo libre
posición objetivo del planificador hasta un punto más allá del final de la articulación
rango de viaje. Esto asegura que el planificador se moverá constantemente
hasta que sea detenido por los límites conjuntos o por un comando ABORTAR.
Normalmente, una GUI envía un comando JOG_CONT cuando el usuario presiona un jog
botón, y ABORTAR cuando se suelta el botón.

==== Requisitos

El controlador de comandos rechazará el comando JOG_CONT con un error
mensaje si la máquina no está en modo libre, o si alguna junta está en movimiento
(GET_MOTION_INPOS_FLAG () == FALSE), o si el movimiento no está habilitado. Eso
también ignorará silenciosamente el comando si la articulación ya está en o
más allá de su límite y el trote ordenado lo empeoraría.

==== Resultados

El planificador de trayectoria de modo libre para la articulación identificada por
El eje emcmotCommand \ -> está activado, con una posición de destino más allá del final
de recorrido conjunto, y un límite de velocidad de emcmotCommand \ -> vel. Esta
comienza el movimiento de la articulación, y el movimiento continuará hasta que se detenga
ABORTAR el comando o al alcanzar un límite. El planificador de modo libre acelera
en el límite de aceleración conjunta al comienzo del movimiento, y
desacelerar en el límite de aceleración conjunta cuando se detiene.

=== JOG_INCR

El comando JOG_INCR inicia un avance gradual en una sola articulación.
Los jogs incrementales son acumulativos, en otras palabras, emiten dos JOG_INCR
comandos que cada uno pide 0.100 pulgadas de movimiento resultarán en
0.200 pulgadas de recorrido, incluso si el segundo comando se emite antes del
el primero termina. Normalmente, los jogs incrementales se detienen cuando tienen
recorrieron la distancia deseada, sin embargo, también se detienen cuando golpean un
límite, o en un comando ABORTAR.

==== Requisitos

El controlador de comandos rechazará silenciosamente el comando JOG_INCR si
la máquina no está en modo libre, o si alguna junta está en movimiento
(GET_MOTION_INPOS_FLAG () == FALSE), o si el movimiento no está habilitado. Eso
también ignorará silenciosamente el comando si la articulación ya está en o
más allá de su límite y el trote ordenado lo empeoraría.

==== Resultados

El planificador de trayectoria de modo libre para la articulación identificada por
emcmotCommand \ -> el eje está activado, la posición de destino es
incrementado / decrementado por emcmotCommand \ -> offset, y la velocidad
el límite se establece en emcmotCommand \ -> vel. El planificador de trayectoria de modo libre
generará un movimiento trapezoidal suave desde la posición actual hasta
La posición de destino. El planificador puede manejar correctamente los cambios en
posición objetivo que ocurre mientras el movimiento está en progreso, por lo que múltiples
Los comandos JOG_INCR se pueden emitir en rápida sucesión. El modo libre
el planificador acelera en el límite de aceleración conjunta al comienzo del
mover, y desacelerará en el límite de aceleración conjunta para detenerse en el
posición de objetivo.

=== JOG_ABS

El comando JOG_ABS inicia un desplazamiento absoluto en una sola articulación. Un
trotar absoluto es un simple movimiento a una ubicación específica, en conjunto
coordenadas Normalmente los trotes absolutos se detienen cuando alcanzan el deseado
ubicación, sin embargo, también se detienen cuando alcanzan un límite, o en un ABORT
mando.

==== Requisitos

El controlador de comandos rechazará silenciosamente el comando JOG_ABS si
la máquina no está en modo libre, o si alguna junta está en movimiento
(GET_MOTION_INPOS_FLAG () == FALSE), o si el movimiento no está habilitado. Eso
también ignorará silenciosamente el comando si la articulación ya está en o
más allá de su límite y el trote ordenado lo empeoraría.

==== Resultados

El planificador de trayectoria de modo libre para la articulación identificada por
emcmotCommand \ -> el eje está activado, la posición de destino se establece en
emcmotCommand \ -> offset, y el límite de velocidad se establece en
emcmotCommand \ -> vel. El planificador de trayectoria de modo libre generará un
movimiento trapezoidal suave desde la posición actual hasta el objetivo
posición. El planificador puede manejar correctamente los cambios en el objetivo
posición que sucede mientras el movimiento está en progreso. Si varios JOG_ABS
los comandos se emiten en rápida sucesión, cada nuevo comando cambia el
posición de destino y la máquina pasa a la posición final ordenada.
El planificador de modo libre acelera en el límite de aceleración conjunta en el
comienzo del movimiento, y se desacelerará en el límite de aceleración conjunta para
detenerse en la posición de destino.

=== SET_LINE

El comando SET_LINE agrega una línea recta al planificador de trayectoria
cola.

(Más tarde)

=== SET_CIRCLE

El comando SET_CIRCLE agrega un movimiento circular al planificador de trayectoria
cola.

(Más tarde)

=== SET_TELEOP_VECTOR

El comando SET_TELEOP_VECTOR indica al controlador de movimiento que se mueva
a lo largo de un vector específico en el espacio cartesiano.

(Más tarde)

=== SONDA

El comando PROBE indica al controlador de movimiento que se mueva hacia un
punto específico en el espacio cartesiano, deteniendo y grabando su
posición si se activa la entrada de la sonda.

(Más tarde)

=== CLEAR_PROBE_FLAG

El comando CLEAR_PROBE_FLAG se usa para restablecer la entrada de la sonda en
preparación para un comando PROBE. (Pregunta: ¿por qué no debería la SONDA?
comando restablecer automáticamente la entrada?)

(Más tarde)

=== SET_xix

Hay aproximadamente 15 comandos SET_xxx, donde xxx es el nombre de
Algún parámetro de configuración. Se anticipa que habrá
varios comandos SET más a medida que se agregan más parámetros. me gustaría
encuentre una forma más limpia de establecer y leer los parámetros de configuración. los
los métodos existentes requieren que se agreguen muchas líneas de código a múltiples
archivos cada vez que se agrega un parámetro. Gran parte de ese código es idéntico o
casi idéntico para cada parámetro.


== Compensación de error de contragolpe y tornillo

 +

== Controlador de tareas (EMCTASK)

=== Estado

La tarea tiene tres posibles estados internos: * E-stop *, * E-stop Reset *,
y * Máquina encendida *.

imagen :: task-state-transitions.svg [align = "center"]

== controlador IO (EMCIO)

El controlador de E / S es un módulo separado que acepta comandos NML de TASK. +
Interactúa con E / S externas utilizando pines HAL. +
iocontrol.cc se carga a través del script linuxcnc antes de TASK. +
Actualmente hay dos versiones de iocontrol. La segunda versión maneja los errores de hardware de cambio de herramienta +
 +

Actualmente ESTOP / Enable, el refrigerante, el lubricante y el cambio de herramienta se manejan con +
iocontrol. Estos son eventos de velocidad relativamente baja, las E / S coordinadas de alta velocidad se manejan en movimiento. +
 +

emctaskmain.cc envía comandos de E / S a través de taskclass.cc +
Las funciones de Taskclass envían mensajes NML a iocontrol.cc +
taskclass usa los comandos definidos en c ++ en su archivo o, +
si está definido, ejecuta comandos basados ​​en python definidos en archivos proporcionados por el usuario. +
 +

Proceso de bucle principal de iocontrol:

- registros para señales SIGTERM y SIGINT del sistema operativo. +
- comprueba si las entradas HAL han cambiado +
- comprueba si read_tool_inputs () indica que el cambio de herramienta ha finalizado y establece emcioStatus.status +
- busca mensajes NML relacionados con E / S +
 +

números de mensaje nml: de emc.hh:

#define EMC_IO_INIT_TYPE ((NMLTYPE) 1601) +
#define EMC_TOOL_STAT_TYPE ((NMLTYPE) 1199) +
#define EMC_TOOL_INIT_TYPE ((NMLTYPE) 1101) +
#define EMC_TOOL_HALT_TYPE ((NMLTYPE) 1102) +
#define EMC_TOOL_ABORT_TYPE ((NMLTYPE) 1103) +
#define EMC_TOOL_PREPARE_TYPE ((NMLTYPE) 1104) +
#define EMC_TOOL_LOAD_TYPE ((NMLTYPE) 1105) +
#define EMC_TOOL_UNLOAD_TYPE ((NMLTYPE) 1106) +
#define EMC_TOOL_LOAD_TOOL_TABLE_TYPE ((NMLTYPE) 1107) +
#define EMC_TOOL_SET_OFFSET_TYPE ((NMLTYPE) 1108) +
#define EMC_TOOL_SET_NUMBER_TYPE ((NMLTYPE) 1109) +
// el siguiente mensaje se envía a io al comienzo de un M6 +
// incluso antes de que emccanon emita el movimiento a la posición de cambio de herramienta +
#define EMC_TOOL_START_CHANGE_TYPE ((NMLTYPE) 1110) +

== Interfaces de usuario

 +

== libnml Introducción

libnml se deriva del NIST rcslib sin todas las plataformas múltiples
apoyo. Muchos de los contenedores alrededor del código específico de la plataforma han sido
eliminado junto con gran parte del código que no es requerido por LinuxCNC. Está
Esperaba que quedara suficiente compatibilidad con rcslib para que
las aplicaciones pueden implementarse en plataformas que no sean Linux y aún ser
capaz de comunicarse con LinuxCNC.

Este capítulo no pretende ser una guía definitiva para usar libnml
(o rcslib), en cambio, eventualmente proporcionará una visión general de cada
Clase C ++ y sus funciones miembro. Inicialmente, la mayoría de estas notas
Se agregarán comentarios aleatorios a medida que el código se analice y modifique.

== LinkedList

Clase base para mantener una lista vinculada. Este es uno de los principales edificios
bloques utilizados para pasar mensajes NML y datos internos variados
estructuras

== LinkedListNode

Clase base para producir una lista vinculada - Propósito, para mantener punteros a
los nodos anteriores y siguientes, puntero a los datos y el tamaño de la
datos.

No se asigna memoria para el almacenamiento de datos.

== SharedMemory

Proporciona un bloque de memoria compartida junto con un semáforo (heredado
de la clase semáforo). La creación y destrucción del semáforo es
manejado por el constructor y destructor SharedMemory.

== ShmBuffer

Clase para pasar mensajes NML entre procesos locales mediante un uso compartido
memoria intermedia Gran parte del funcionamiento interno se hereda del CMS
clase.

== Temporizador

La clase Timer proporciona un temporizador periódico limitado solo por el
resolución del reloj del sistema. Si, por ejemplo, un proceso necesita ser
ejecutar cada 5 segundos, independientemente del tiempo que lleve ejecutar el proceso,
El siguiente fragmento de código demuestra cómo:

[fuente, c]
----
principal()
{
    temporizador = nuevo temporizador (5.0); / * Inicializa un temporizador con un ciclo de 5 segundos * /
    mientras que (0) {
        / * Hacer algún proceso * /
        timer.wait (); / * Espere hasta el siguiente intervalo de 5 segundos * /
    }
    borrar temporizador;
}
----

== Semáforo

La clase Semaphore proporciona un método de exclusiones mutuas para
accediendo a un recurso compartido. La función para obtener un semáforo puede
bloquear hasta que el acceso esté disponible, regresar después de un tiempo de espera o regresar
inmediatamente con o sin ganar el semáforo. El constructor
crear un semáforo o adjuntarlo a uno existente si la ID ya está en
utilizar.

Semaphore :: destroy () debe ser invocado solo por el último proceso.

== CMS

En el corazón de libnml está la clase CMS, contiene la mayor parte de
funciones utilizadas por libnml y finalmente NML. Muchos de los internos
las funciones se sobrecargan para permitir un hardware específico dependiente
métodos de paso de datos. En definitiva, todo gira en torno a un
bloque central de memoria (denominado "búfer de mensajes" o simplemente
'buffer'). Este búfer puede existir como un bloque de memoria compartida al acceder
otros procesos CMS / NML, o un búfer local y privado para la transmisión de datos
transferido por la red o interfaces seriales.

El búfer se asigna dinámicamente en tiempo de ejecución para permitir una mayor
flexibilidad del subsistema CMS / NML. El tamaño del búfer debe ser grande.
suficiente para acomodar el mensaje más grande, una pequeña cantidad para mensajes internos
use y permita que el mensaje se codifique si se elige esta opción
(los datos codificados se cubrirán más adelante). La siguiente figura es un
Vista interna del espacio del búfer.

imagen :: CMS_buffer.png [align = "center"]

.CMS buffer

La clase base de CMS es la principal responsable de crear el
vías de comunicación e interfaz con el O.S.

//////////////////////////////////////////////////////////////////////////////////////////////////////////// //////////////////////
== Notas NML / * FIX ME * /

Una colección de notas y pensamientos al azar mientras estudias el libnml
y código rcslib.

Gran parte de esto necesita ser editado y reescrito de manera coherente
antes de la publicación
//////////////////////////////////////////////////////////////////////////////////////////////////////////// /////////////////////

== Formato del archivo de configuración

La configuración NML consta de dos tipos de formatos de línea. Uno para
Buffers, y un segundo para Procesos que se conectan a los buffers.

=== Línea de búfer

El formato NIST original de la línea de búfer es:

* 'B nombre tipo host tamaño neut RPC # buffer # max_procs key [configuraciones específicas de tipo]'

* 'B': identifica esta línea como una configuración de búfer.
* 'nombre': es el identificador del búfer.
* 'tipo': describe el tipo de búfer: SHMEM, LOCMEM, FILEMEM, PHANTOM o GLOBMEM.
* 'host': es una dirección IP o un nombre de host para el servidor NML
* 'tamaño': es el tamaño del búfer
* 'neut': un booleano para indicar si los datos en el búfer están codificados en un
formato independiente de la máquina, o sin formato.
* 'RPC #' - Obsoleto - Soporte de lugar retenido solo para compatibilidad con versiones anteriores.
* 'buffer #': un número de ID único que se usa si un servidor controla múltiples buffers.
* 'max_procs': son los procesos máximos permitidos para conectarse a este búfer.
* 'clave' - es un identificador numérico para un búfer de memoria compartida

=== Tipo de configuraciones específicas

El tipo de búfer implica opciones de configuración adicionales mientras que el
El sistema operativo host impide ciertas combinaciones. En una tentativa de
destilar la documentación publicada en un formato coherente, solo el * SHMEM *
El tipo de buffer será cubierto.

* 'mutex = os_sem': modo predeterminado para proporcionar el bloqueo del semáforo de la memoria intermedia.
* 'mutex = none': no ​​utilizado
* 'mutex = no_interrupts' - no aplicable en un sistema Linux
* 'mutex = no_switching' - no aplicable en un sistema Linux
* 'mutex = mao split': divide el búfer en la mitad (o más) y permite
un proceso para acceder a parte del búfer mientras que un segundo proceso es
escribiendo a otra parte.
* 'TCP = (número de puerto)': especifica qué puerto de red utilizar.
* 'UDP = (número de puerto)' - ídem
* 'STCP = (número de puerto)' - ídem
* 'serialPortDevName = (puerto serie)' - Sin documentar.
* 'passwd = file_name.pwd': agrega una capa de seguridad al búfer mediante
requiriendo que cada proceso proporcione una contraseña.
* 'bsem': la documentación del NIST implica una clave para un semáforo de bloqueo,
y si bsem = -1, se evitan las lecturas de bloqueo.
* 'cola': permite pasar mensajes en cola.
* 'ascii' - Codifica mensajes en formato de texto plano
* 'disp': codifica los mensajes en un formato adecuado para mostrar (???)
* 'xdr': codifica mensajes en Representación de datos externos. (Ver rpc / xdr.h para más detalles).
* 'diag': habilita los diagnósticos almacenados en el búfer (¿temporizaciones y recuentos de bytes?)

=== Línea de proceso

El formato NIST original de la línea de proceso es:

* P nombre tipo de buffer host ops servidor timeout master c_num [configuraciones específicas de tipo] *

* 'P': identifica esta línea como una configuración de proceso.
* 'nombre': es el identificador del proceso.
* 'buffer' - es uno de los buffers definidos en otra parte del archivo de configuración.
* 'tipo': define si este proceso es local o remoto en relación con el búfer.
* 'host': especifica en qué parte de la red se está ejecutando este proceso.
* 'ops': proporciona al proceso acceso de solo lectura, solo escritura o de lectura / escritura al búfer.
* 'servidor': especifica si este proceso ejecutará un servidor para este búfer.
* 'tiempo de espera': establece las características de tiempo de espera para los accesos al búfer.
* 'maestro': indica si este proceso es responsable de crear y destruir el búfer.
* 'c_num': un número entero entre cero y (max_procs -1)

=== Comentarios de configuración

Algunas de las combinaciones de configuración no son válidas, mientras que otras
implican ciertas restricciones. En un sistema Linux, GLOBMEM es obsoleto,
mientras que PHANTOM solo es realmente útil en la etapa de prueba de un
aplicación, igualmente para FILEMEM. LOCMEM es de poca utilidad para un
aplicación multiproceso, y solo ofrece un rendimiento limitado
ventajas sobre SHMEM. Esto deja a SHMEM como el único tipo de búfer para usar
con LinuxCNC.

La opción neut solo se usa en un sistema multiprocesador donde
arquitecturas diferentes (e incompatibles) comparten un bloque de
memoria. La probabilidad de ver un sistema de este tipo fuera de un
museo o establecimiento de investigación es remoto y solo es relevante para
Tampones GLOBMEM.

El número RPC está documentado como obsoleto y solo se conserva
por razones de compatibilidad.

Con un nombre de búfer único, tener una identidad numérica parece ser
inútil. Necesita revisar el código para identificar la lógica. Asimismo, el
el campo clave al principio parece ser redundante, y podría derivarse
del nombre del búfer.

El propósito de limitar el número de procesos permitidos para conectarse
cualquier búfer no está claro a partir de la documentación existente y de la
código fuente original Permitir múltiples procesos no especificados para
conectarse a un búfer no es más difícil de implementar.

Los tipos de mutex se reducen a uno de dos, el predeterminado "os_sem" o "mao
división". La mayoría de los mensajes NML son relativamente cortos y se pueden copiar
hacia o desde el búfer con retrasos mínimos, por lo que las lecturas divididas no son
esencial.

La codificación de datos solo es relevante cuando se transmite a un proceso remoto:
Usar TCP o UDP implica codificación XDR. Mientras que la codificación ASCII puede tener
algún uso en diagnósticos o para pasar datos a un sistema integrado que
no implementa NML.

Los protocolos UDP tienen menos controles en los datos y permiten un porcentaje de
paquetes para ser descartados. TCP es más confiable, pero es marginalmente más lento.

Si LinuxCNC se va a conectar a una red, uno esperaría que sea
local y detrás de un firewall. Sobre la única razón para permitir el acceso a
LinuxCNC a través de Internet sería para diagnósticos remotos. Esto puede ser
logrado de manera mucho más segura utilizando otros medios, tal vez por una web
interfaz.

El comportamiento exacto cuando el tiempo de espera se establece en cero o un valor negativo es
claro de los documentos del NIST. Solo los valores INF y positivos son
mencionado. Sin embargo, enterrado en el código fuente de rcslib, es evidente
que se aplica lo siguiente:

tiempo de espera> 0 Bloqueo de acceso hasta que se alcanza el intervalo de tiempo de espera o
El acceso al búfer está disponible.

timeout = 0 El acceso al búfer solo es posible si no hay otro proceso
está leyendo o escribiendo en ese momento.

timeout <0 o INF El acceso está bloqueado hasta que el búfer esté disponible.

== clase base NML
// ARREGLARME

Expanda las listas y la relación entre NML, NMLmsg y el
clases de cms de nivel inferior.

No debe confundirse con NMLmsg, RCS_STAT_MSG o RCS_CMD_MSG.

NML es responsable de analizar el archivo de configuración, configurando el cms
almacena el búfer y es el mecanismo para enrutar mensajes a la correcta
tampón (s). Para hacer esto, NML crea varias listas para:

* búferes cms creados o conectados.
* procesos y las memorias intermedias a las que se conectan
* una larga lista de funciones de formato para cada tipo de mensaje

Este último elemento es probablemente el núcleo de gran parte de la desalineación de
libnml / rcslib y NML en general. Cada mensaje que se pasa a través de NML
requiere que se adjunte una cierta cantidad de información además de
Los datos reales. Para hacer esto, se invocan varias funciones de formato
secuencia para ensamblar fragmentos del mensaje general. El formato
las funciones incluirán NML_TYPE, MSG_TYPE, además de los datos
declarado en clases NMLmsg derivadas. Cambios en el orden en que
se llaman funciones de formato y también las variables pasadas
romper la compatibilidad con rcslib si está mal: hay razones para
manteniendo la compatibilidad con rcslib y buenas razones para jugar con el
código. La pregunta es, ¿qué conjunto de razones son primordiales?

=== NML internos

==== constructor NML

NML :: NML () analiza el archivo de configuración y lo almacena en una lista vinculada para ser
Pasado a constructores de cms en líneas simples. Es la función de la
Constructor NML para llamar al constructor cms relevante para cada búfer
y mantener una lista de los objetos cms y los procesos asociados
con cada tampón.

Es de los punteros almacenados en las listas que NML puede interactuar con
cms y por qué Doxygen no muestra las relaciones reales involucradas.

[NO UN]
La configuración se almacena en la memoria antes de pasar un puntero a
Una línea específica para el constructor de cms. El constructor de cms luego analiza
la línea nuevamente para extraer un par de variables ... Haría más
tiene sentido hacer TODO el análisis y guardar las variables en una estructura que es
pasado al constructor de cms: esto eliminaría el manejo de cadenas
y reduce el código duplicado en cms ...

==== NML lectura / escritura

Las llamadas a NML :: read y NML :: write realizan tareas similares en modo
tanto como procesar el mensaje: la única variación real está en el
dirección del flujo de datos.

Una llamada a la función de lectura primero obtiene datos del búfer, luego
llama a format_output (), mientras que una función de escritura llamaría
format_input () antes de pasar los datos al búfer. Está dentro
format_xxx () que el trabajo de construir o deconstruir el
Se lleva a cabo el mensaje. Una lista de funciones variadas se llama a su vez para
coloque varias partes del encabezado NML (que no debe confundirse con el cms
encabezado) en el orden correcto: la última función llamada es emcFormat () en
emc.cc.

==== NMLmsg y relaciones NML

NMLmsg es la clase base de la que se derivan todas las clases de mensajes.
Cada clase de mensaje debe tener un ID único definido (y pasado al
constructor) y también una función de actualización (* cms). La actualización () será
llamado por las funciones de lectura / escritura NML cuando se llama al formateador NML
- El puntero al formateador habrá sido declarado en el NML
constructor en algún momento. En virtud de las listas vinculadas que NML crea,
puede seleccionar el puntero de cms que se pasa al formateador y
para lo cual se utilizará el búfer.

== Agregar comandos NML personalizados

LinuxCNC es bastante impresionante, pero algunas partes necesitan algunos ajustes. Como sabes
la comunicación se realiza a través de canales NML, los datos enviados a través de tales
un canal es una de las clases definidas en emc.hh (implementado en
emc.cc). Si alguien necesita un tipo de mensaje que no existe, debería
siga estos pasos para agregar uno nuevo. (El mensaje que agregué en el
ejemplo se llama EMC_IO_GENERIC (hereda EMC_IO_CMD_MSG (hereda
RCS_CMD_MSG)))

. agregue la definición de la clase EMC_IO_GENERIC a emc2 / src / emc / nml_intf / emc.hh
. agregue el tipo define: #define EMC_IO_GENERIC_TYPE ((NMLTYPE) 1605) +
.. (Elegí 1605, porque estaba disponible) para emc2 / src / emc / nml_intf / emc.hh
. agregue el caso EMC_IO_GENERIC_TYPE a emcFormat en emc2 / src / emc / nml_intf / emc.cc
. agregue el caso EMC_IO_GENERIC_TYPE a emc_symbol_lookup en emc2 / src / emc / nml_intf / emc.cc
. agregue EMC_IO_GENERIC :: función de actualización a emc2 / src / emc / nml_intf / emc.cc

Recompile, y el nuevo mensaje debería estar allí. La siguiente parte es
enviar tales mensajes desde algún lugar y recibirlos en otro lugar,
y hacer algunas cosas con eso.


== La tabla de herramientas y el cambiador de herramientas

LinuxCNC interactúa con el hardware del cambiador de herramientas y tiene un interno
abstracción del cambiador de herramientas. LinuxCNC gestiona la información de la herramienta en una herramienta
archivo de tabla


=== Abstracción del cambiador de herramientas en LinuxCNC

LinuxCNC admite dos tipos de hardware de cambiador de herramientas,
llamado _nonrandom_ y _random_. El escenario ini
<< sec: emcio-section, [EMCIO] RANDOM_TOOLCHANGER >> controla cuál de
este tipo de hardware con el que LinuxCNC cree que está conectado.


==== Cambiadores de herramientas no aleatorios

El hardware de cambiador de herramientas no aleatorio vuelve a colocar cada herramienta en el bolsillo que era
originalmente cargado desde.

Ejemplos de hardware de cambiador de herramientas no aleatorio son el cambiador de herramientas "manual",
tornos de herramientas de torno y cambiadores de herramientas de cremallera.

Cuando se configura para un cambiador de herramientas no aleatorio, LinuxCNC no cambia el
número de bolsillo en el archivo de la tabla de herramientas a medida que las herramientas se cargan y descargan.
Interna a LinuxCNC, en el cambio de herramienta, la información de la herramienta se * copia *
del bolsillo fuente de la tabla de herramientas al bolsillo 0 (que representa el
husillo), reemplazando cualquier información de herramienta que estaba allí anteriormente.

NOTA: En LinuxCNC configurado para cambiador de herramientas no aleatorio, la herramienta 0 (T0) tiene
significado especial: "sin herramienta". T0 puede no aparecer en el archivo de tabla de herramientas y
cambiar a T0 dará como resultado que LinuxCNC piense que tiene un huso vacío.


==== Cambiadores de herramientas al azar

El hardware de cambiador de herramientas aleatorio intercambia la herramienta en el eje (si existe) con
la herramienta solicitada sobre cambio de herramienta. Así, el bolsillo donde reside una herramienta
en cambios a medida que se intercambia dentro y fuera del eje.

Un ejemplo de hardware de cambiador de herramientas aleatorio es un cambiador de herramientas de carrusel.

Cuando se configura para un cambiador de herramientas aleatorio, LinuxCNC intercambia el número de bolsillo
de la herramienta antigua y la nueva en el archivo de tabla de herramientas cuando se cargan las herramientas.
Interna a LinuxCNC, en el cambio de herramienta, la información de la herramienta se * intercambia *
entre el bolsillo de origen de la tabla de herramientas y el bolsillo 0 (que representa
el huso). Entonces, después de un cambio de herramienta, el bolsillo 0 en la tabla de herramientas tiene
la información de la herramienta para la nueva herramienta y el bolsillo que la nueva herramienta
vino de tiene la información de la herramienta anterior (la herramienta que era
en el husillo antes del cambio de herramienta), si corresponde.

NOTA: En LinuxCNC configurado para cambiador de herramientas aleatorio, la herramienta 0 (T0) tiene * no *
significado especial. Se trata exactamente como cualquier otra herramienta en la herramienta
colina baja. Es habitual utilizar T0 para representar "sin herramienta" (es decir, una herramienta con
cero TLO), de modo que el eje se pueda vaciar convenientemente cuando sea necesario.


=== La tabla de herramientas

LinuxCNC realiza un seguimiento de las herramientas en un archivo llamado << sec: tool-table, tool
mesa >>. La tabla de herramientas registra la siguiente información para cada herramienta:

número de herramienta ::

Un entero que identifica de forma exclusiva esta herramienta. Los números de herramienta son
manejado de manera diferente por LinuxCNC cuando se configura de forma aleatoria y
cambiadores de herramientas no aleatorios:

* Cuando LinuxCNC está configurado para un cambiador de herramientas no aleatorio, esto
El número debe ser positivo. T0 recibe un manejo especial y no es
permitido aparecer en la tabla de herramientas.

* Cuando LinuxCNC está configurado para un cambiador de herramientas aleatorio este número
debe ser no negativo. T0 está permitido en la tabla de herramientas y es
generalmente se usa para representar "ninguna herramienta", es decir, el bolsillo vacío.

número de bolsillo ::

Un entero que identifica el bolsillo o la ranura en el cambiador de herramientas
hardware donde reside la herramienta. Se manejan los números de bolsillo
de manera diferente por LinuxCNC cuando está configurado para aleatorio y no aleatorio
cambiadores de herramientas:

* Cuando LinuxCNC está configurado para un cambiador de herramientas no aleatorio, el bolsillo
El número en el archivo de herramientas puede ser cualquier número entero positivo (bolsillo
0 no está permitido). LinuxCNC compacta en silencio el bolsillo
números cuando carga el archivo de herramienta, por lo que puede haber una diferencia
entre los números de bolsillo en el archivo de herramientas y el interno
números de bolsillo utilizados por LinuxCNC-with-norandom-toolchanger.

* Cuando LinuxCNC está configurado para un cambiador de herramientas aleatorio, el bolsillo
los números en el archivo de herramientas deben estar entre 0 y 1000, inclusive.
Los bolsillos 1-1000 están en el cambiador de herramientas, el bolsillo 0 es el eje.

diámetro::

Diámetro de la herramienta, en unidades de máquina.

desplazamiento de longitud de herramienta ::

Desplazamiento de longitud de herramienta (también llamado TLO), en hasta 9 ejes, en máquina
unidades. Los ejes que no tienen un TLO especificado obtienen 0.


=== Gcodes que afectan a las herramientas

Los gcodes que usan o afectan la información de la herramienta son:


==== Txxx

Le dice al hardware del cambiador de herramientas que se prepare para cambiar a un determinado
herramienta + xxx +.

Manejado por + Interp :: convert_tool_select () +.

. Se le pide a la máquina que se prepare para cambiar a la herramienta seleccionada por
llamando a la función Canon + SELECT_POCKET () + con el número de bolsillo
de la herramienta solicitada.

.. (saicanon) No-op.

.. (emccanon) Crea un mensaje + EMC_TOOL_PREPARE + con el mensaje solicitado
número de bolsillo y lo envía a Task, que lo envía
a IO. IO recibe el mensaje y le pide a HAL que se prepare
el bolsillo configurando + iocontrol.0.tool-prep-pocket +,
+ iocontrol.0.tool-prep-number +, y + iocontrol.0.tool-prepare +.
IO luego llama repetidamente + read_tool_inputs () + para sondear el pin HAL
+ iocontrol.0.tool-ready +, que señala desde el cambiador de herramientas
hardware, a través de HAL, a IO que la preparación de la herramienta solicitada está completa.
Cuando ese pin se vuelve verdadero, IO establece + emcioStatus.tool.pocketPrepped +
al número de bolsillo de la herramienta solicitada.

. De vuelta en la interfaz, + configuración-> selected_pocket + se le asigna el bolsillo
número de la herramienta solicitada _xxx_.

==== M6

Le dice al cambiador de herramientas que cambie a la herramienta seleccionada actualmente (seleccionada
por el comando Txxx anterior).

Manejado por + Interp :: convert_tool_change () +.

. Se le pide a la máquina que cambie a la herramienta seleccionada
llamando a la función Canon + CHANGE_TOOL () + con
+ configuración-> selected_pocket +.

.. (saicanon) Establece sai + _active_slot + en el bolsillo pasado
número. La información de la herramienta se copia del bolsillo seleccionado
de la tabla de herramientas (es decir, de sai's + _tools [_active_slot] +)
al eje (también conocido como sai + _tools [0] +).

.. (emccanon) Envía un mensaje + EMC_TOOL_LOAD + a la Tarea, que
lo envía a IO. IO sets + emcioStatus.tool.toolInSpindle +
al número de herramienta de la herramienta en el bolsillo identificado
por + emcioStatus.tool.pocketPrepped + (establecido por + Txxx +
alias + SELECT_POCKET () +). Luego solicita que el
El cambiador de herramientas de hardware realiza un cambio de herramienta, configurando
el pin HAL + iocontrol.0.tool-change + a True. Más tarde,
IO's + read_tool_inputs () + detectará que el pin HAL
+ iocontrol.0.tool_changed + se ha establecido en True, lo que indica que
toolchanger ha completado el cambio de herramienta. Cuando esto pasa,
llama a + load_tool () + para actualizar el estado de la máquina.

... + load_tool () + con un cambiador de herramientas no aleatorio
config copia la información de la herramienta del bolsillo seleccionado
al husillo (bolsillo 0).

... + load_tool () + con una herramienta de intercambios de configuración de cambiador de herramientas aleatorio
información entre el bolsillo 0 (el huso) y el seleccionado
bolsillo, luego guarda la mesa de herramientas.

. De vuelta en interp, + settings-> current_pocket + se le asigna el nuevo
herramienta desde + configuración-> selected_pocket + (establecido por + Txxx +). Lo relevante
los parámetros numerados (<< sub: parámetros numerados, # 5400- # 5413 >>) son
actualizado con la nueva información de herramienta del bolsillo 0 (husillo).


==== G43 / G43.1 / G49

Aplicar desplazamiento de longitud de herramienta. G43 usa el TLO de la herramienta cargada actualmente,
o de una herramienta especificada si la palabra H se da en el bloque. G43.1 consigue
TLO de las palabras del eje en el bloque. G49 cancela el TLO (usa 0 para
El desplazamiento para todos los ejes).

Manejado por + Interp :: convert_tool_length_offset () +.

. Comienza construyendo un + EmcPose + que contiene los desplazamientos de 9 ejes
usar. Para + G43.1 +, estas compensaciones de herramientas provienen de palabras de eje en el
bloque actual. Para + G43 + estos desplazamientos provienen de la herramienta actual
(la herramienta en el bolsillo 0), o de la herramienta especificada por la palabra H en
el bloque. Para G49, los desplazamientos son todos 0.

. Los desplazamientos se pasan a la función + USE_TOOL_LENGTH_OFFSET () + de Canon.

.. (saicanon) Graba el TLO en + _tool_offset +.

.. (emccanon) Crea un mensaje + EMC_TRAJ_SET_OFFSET + que contiene el mensaje
compensa y lo envía a la tarea. La tarea copia las compensaciones en
+ emcStatus-> task.toolOffset + y los envía a Motion a través de
un comando + EMCMOT_SET_OFFSET +. Motion copia las compensaciones
a + emcmotStatus-> tool_offset +, donde se usa para compensar
movimientos futuros

. De vuelta en interp, los desplazamientos se registran en + settings-> tool_offset +.
El bolsillo efectivo se registra en + settings-> tool_offset_index +,
aunque este valor nunca se usa.


==== G10 L1 / L10 / L11

Modifica la tabla de herramientas.

Manejado por + Interp :: convert_setup_tool () +.

. Selecciona el número de herramienta de la palabra P en el bloque y encuentra el
bolsillo para esa herramienta:

.. Con una configuración de cambiador de herramientas no aleatorio, este es siempre el
número de bolsillo en el cambiador de herramientas (incluso cuando la herramienta está en
el huso).

.. Con una configuración aleatoria de cambiador de herramientas, si la herramienta está actualmente
cargado utiliza el bolsillo 0 (bolsillo 0 significa "el huso"),
y si la herramienta no está cargada, usa el número de bolsillo en
El cambiador de herramientas. (Esta diferencia es importante).

. Averigua cuáles deberían ser las nuevas compensaciones.

. La nueva información de la herramienta (diámetro, desplazamientos, ángulos y orientación),
junto con el número de herramienta y el número de bolsillo, se pasan al Canon
llame a SET_TOOL_TABLE_ENTRY ().

.. (saicanon) Copie la información de la nueva herramienta en el bolsillo especificado
(en la tabla de herramientas interna de sai, + _tools +).

.. (emccanon) Cree un mensaje + EMC_TOOL_SET_OFFSET + con el nuevo
información de la herramienta y enviarla a Tarea, que la pasa
a IO. IO actualiza el bolsillo especificado en su interno
copia de la tabla de herramientas (+ emcioStatus.tool.toolTable +), y
si la herramienta especificada está cargada actualmente (se compara con
+ emcioStatus.tool.toolInSpindle +) luego la información de la nueva herramienta
se copia en el bolsillo 0 (el eje) también. (FIXME: eso es un
buglet, solo debe copiarse en máquinas no aleatorias). Finalmente IO
guarda la nueva tabla de herramientas.

. De vuelta en interp, si la herramienta modificada está cargada actualmente en el
husillo, y si la máquina es un cambiador de herramientas no aleatorio, entonces
la nueva información de la herramienta se copia del bolsillo de inicio de la herramienta
al bolsillo 0 (el huso) en la copia de interp de la tabla de herramientas,
+ configuración-> tool_table +. (Esta copia no es necesaria en una herramienta aleatoria
máquinas de cambio porque allí, las herramientas no tienen un bolsillo en casa y
en su lugar, acabamos de actualizar la herramienta en el bolsillo 0 directamente).

. Los parámetros numerados relevantes
(<< sub: parámetros numerados, # 5400- # 5413 >>) se actualizan desde la herramienta
información en el huso (copiando la información de interp's
+ configuración-> tool_table + a + configuración-> parámetros +). (FIXME: esto es
un buglet, los params solo deberían actualizarse si era el actual
herramienta que fue modificada).

. Si la herramienta modificada está cargada actualmente en el
eje, y si la configuración es para un cambiador de herramientas no aleatorio, entonces el
la nueva información de herramienta también se escribe en el bolsillo 0 de la tabla de herramientas,
a través de una segunda llamada a SET_TOOL_TABLE_ENTRY (). (Esta segunda tabla de herramientas
la actualización no es necesaria en máquinas de cambio de herramientas aleatorias porque allí,
las herramientas no tienen un bolsillo de casa y en su lugar acabamos de actualizar la herramienta
en el bolsillo 0 directamente.)


==== M61

Establecer el número de herramienta actual. Esto cambia la representación interna de LinuxCNC
de qué herramienta está en el eje, sin mover realmente el cambiador de herramientas
o intercambiando cualquier herramienta.

Manejado por + Interp :: convert_tool_change () +.

Canon: + CHANGE_TOOL_NUMBER () +

settings-> current_pocket tiene asignado el número de bolsillo actualmente
sosteniendo la herramienta especificada por el argumento Q-word.


==== G41 / G41.1 / G42 / G42.1

Habilite la compensación del radio de corte (generalmente se llama _cutter comp_).

Manejado por + Interp :: convert_cutter_compensation_on () +.

No hay llamada de Canon, la composición del cortador ocurre en el intérprete. Usa la herramienta
tabla de la manera esperada: si se proporciona un número de herramienta D-word se ve
arriba el número de bolsillo del número de herramienta especificado en la tabla, y si
no se suministra ninguna palabra D, utiliza la cavidad 0 (el eje).


==== G40

Cancele la compensación del radio de corte.

Manejado por + Interp :: convert_cutter_compensation_off () +.

No hay llamada de Canon, la composición del cortador ocurre en el intérprete. No se usa
la mesa de herramientas.


=== Variables de estado interno

¡Esta no es una lista exhaustiva! La información de la herramienta se difunde a través de
fuera LinuxCNC.


==== IO

+ emcioStatus + es de tipo + EMC_IO_STAT +

emcioStatus.tool.pocketPrepped ::

Cuando IO recibe la señal de HAL de que la preparación del cambiador de herramientas es
completa (después de un comando + Txxx +), esta variable se establece en
bolsillo de la herramienta solicitada. Cuando IO recibe la señal de HAL
que el cambio de herramienta en sí está completo (después de un comando + M6 +),
esta variable se restablece a -1.

emcioStatus.tool.toolInSpindle ::

Número de herramienta de la herramienta instalada actualmente en el eje.
Exportado en el pin HAL + iocontrol.0.tool-number + (s32).

emcioStatus.tool.toolTable [] ::

Una matriz de + CANON_TOOL_TABLE + estructuras, + CANON_POCKETS_MAX + long.
Cargado desde el archivo de la tabla de herramientas al inicio y mantenido allí
después El índice 0 es el huso, los índices 1- (CANON_POCKETS_MAX-1)
son los bolsillos en el cambiador de herramientas. Esta es una copia completa
de la información de la herramienta, mantenida por separado de la de Interp
+ settings.tool_table +.


==== interp

+ settings + es de tipo + settings +, que es + struct setup_struct +.
Definido en + src / emc / rs274ngc / interp_internal.hh +.

settings.selected_pocket ::

Bolsillo de la herramienta seleccionada más recientemente por + Txxx +.

settings.current_pocket ::

Bolsillo original de la herramienta actualmente en el husillo. En otras palabras:
qué cambiador de herramientas guarda la herramienta que está actualmente en el eje
fue cargado desde.

settings.tool_table [] ::

Un conjunto de información de herramientas. El índice en la matriz es el "bolsillo
número "(también conocido como" número de ranura "). El bolsillo 0 es el eje, los bolsillos 1
hasta (CANON_POCKETS_MAX-1) son los bolsillos del cambiador de herramientas.

settings.tool_offset_index ::

No usado. FIXME: Probablemente debería eliminarse.

settings.toolchange_flag ::

Interp establece esto en verdadero cuando llama a Canon CHANGE_TOOL ()
función. Está marcado en + Interp :: convert_tool_length_offset () +
para decidir qué bolsillo usar para G43 (sin palabra H):
+ configuración-> current_pocket + si el cambio de herramienta aún está en progreso,
bolsillo 0 (el husillo) si se completa el cambio de herramienta.

settings.random_toolchanger ::

Establecer desde la variable ini + [EMCIO] RANDOM_TOOLCHANGER + al inicio.
Controla varias herramientas de lógica de manejo de tablas. (IO también lee esto
ini variable y cambia su comportamiento en función de ella. Por ejemplo,
al guardar la tabla de herramientas, el cambiador de herramientas aleatorio guarda la herramienta en
el husillo (bolsillo 0), pero el cambiador de herramientas no aleatorio guarda cada herramienta
en su "bolsillo de casa".)

settings.tool_offset ::

Esta es una variable + EmcPose +.

* Se utiliza para calcular la posición en varios lugares.

* Enviado a Motion a través del mensaje + EMCMOT_SET_OFFSET +.
Todo el movimiento que se hace con los desplazamientos es exportarlos a los pines HAL
+ motion.0.tooloffset. [xyzabcuvw] +. FIXME: exportarlos desde
algún lugar más cercano a la mesa de herramientas (io o interp, probablemente)
y elimine el mensaje EMCMOT_SET_OFFSET.

settings.pockets_max ::

Se usa de manera intercambiable con + CANON_POCKETS_MAX + (una constante #definida,
establecido en 1000 a partir de abril de 2020). FIXME: esta variable de configuración
actualmente no es útil y probablemente debería eliminarse.

settings.tool_table ::

Esta es una matriz de + CANON_TOOL_TABLE + estructuras (definidas en
+ src / emc / nml_intf / emctool.h +), con + CANON_POCKETS_MAX + entradas.
Indizado por "número de bolsillo", también conocido como "número de ranura". El índice 0 es el
husillo, los índices 1- (CANON_POCKETS_MAX-1) son los bolsillos de la herramienta
cambiador En un cambiador de herramientas al azar, los números de bolsillo son significativos.
En un cambiador de herramientas no aleatorio, los bolsillos no tienen sentido; el bolsillo
los números en el archivo de la tabla de herramientas se ignoran y las herramientas se asignan
para + tool_table + ranuras secuencialmente.

settings.tool_change_at_g30 ::
settings.tool_change_quill_up ::
settings.tool_change_with_spindle_on ::

Estos se establecen a partir de variables ini en la sección + [EMCIO] +, y
controlar cómo se realizan los cambios de herramienta.


== Calculo de juntas y ejes

=== En el búfer de estado

El buffer de estado es utilizado por Task y las UI.

FIXME: `axis_mask` y` axes` especifican en exceso el número de ejes

`status.motion.traj.axis_mask` ::

Una máscara de bits con un "1" para los ejes que están presentes y un "0"
para los ejes que no están presentes. X es el bit 0, Y es el bit 1, etc.
Por ejemplo, una máquina con ejes X y Z tendría una `axis_mask`
de 0x5, una máquina XYZ tendría 0x7, y una máquina XYZB
tener un `axis_mask` de 0x17.

`status.motion.traj.axes` (en desuso) ::

El valor de esta variable es uno más que el índice de
eje con el número más alto presente en la máquina. Como en la `axis_mask`,
el índice de X en 0, Y es 1, etc. Una máquina XZ tiene un valor de 'ejes'
de 3, al igual que una máquina XYZ. Una máquina XYZW tiene un valor de 'ejes' 9.
Esta variable no es muy útil y su uso está en desuso.
Use `axis_mask` en su lugar.

`status.motion.traj.joints` ::

Un recuento del número de juntas que tiene la máquina. Un torno normal
tiene 2 articulaciones; uno manejando el eje X y otro manejando el eje Z.
Un molino de pórtico XYYZ tiene 4 articulaciones; uno manejando X, uno manejando un lado
de la Y, uno manejando el otro lado de la Y, y uno manejando Z.
Un molino XYZA también tiene 4 articulaciones.

`status.motion.axis [EMCMOT_MAX_AXIS]` ::

Una matriz de estructuras de eje `EMCMOT_MAX_AXIS`. `axis [n]` es válido
if `(axis_mask & (1 << n))` es True. If `(axis_mask & (1 << n))`
es Falso, entonces `axis [n]` no existe en esta máquina y debe
ser ignorado.

`status.motion.joint [EMCMOT_MAX_JOINTS]` ::

Una matriz de estructuras de unión `EMCMOT_MAX_JOINTS`. `conjunta [0]` a través
`joint [joint-1]` son válidas, las otras no existen en esta máquina
y debe ser ignorado.

Las cosas no están así actualmente en la rama de ejes articulados, pero
Las desviaciones de este diseño se consideran errores. Por un ejemplo de tal
un error, vea el tratamiento de los ejes en src / emc / ini / initraj.cc: loadTraj ().
Indudablemente hay más, y necesito tu ayuda para encontrarlos y
arreglalos.


=== En movimiento

El componente en tiempo real del controlador de movimiento obtiene primero el número de uniones
del parámetro de tiempo de carga `num_joints`. Esto determina cuantos
Se crean juntas por valor de pines HAL al inicio.

El número de articulaciones de Motion se puede cambiar en tiempo de ejecución utilizando el
Comando `EMCMOT_SET_NUM_JOINTS` de la tarea.

El controlador de movimiento siempre funciona en los ejes `EMCMOT_MAX_AXIS`.
Siempre crea nueve conjuntos de pines `axis. *. *`.


